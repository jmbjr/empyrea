from namegen import *
from ctypes import *
import os
import sys
import libtcodpy as libtcod
import time
import pygame
import math
from math import sqrt
import random
from random import randrange
from random import choice
import threading
import multiprocessing
import cPickle
import fnmatch
import inflect
import psyco
import copy
import sqlite3
import gc
import cProfile
import Queue

os.putenv("SDL_VIDEO_CENTERED", "1")
sys.setrecursionlimit(50000)

def LoadInit():
    initdict = {}
    initfile = open('init.txt', 'r')
    init = initfile.readlines()
    initfile.close()
    for line in init:
        line = line.strip('\n')
        if line.startswith('===') or line.startswith('*'):
            continue
        if not line.strip(' '):
            continue
        else:
            sname = line.split(': ')[0]
            setting = line.split(': ')[1]
            initdict[sname] = setting
    return initdict

init = LoadInit()

psyco.log()
psyco.full()

p = inflect.engine()
__author__ = 'D.M. Hagar'
__version__ = '0.3 Alpha Tech Demo by ' + __author__

### List of Reserved ASCII Character Numbers and Their Corresponding Layers ###
# 255 - Main play window
# 189 - Inventory/Construction windows
# 190 - Pathmarker (possibly other miscellaneous graphical features if necessary)

####################################
# Coder's Guide                    #
####################################
##     I. Misc. Functions
##       - f. wchoice, f. dchoice, f. DictCmp, f. ListCmp, f. ListCmp2, f. LenCmp,
##         f. HeightSort, f. modifyList, f. getRivChar, f. MergeTerritory, f. queryTile,
##         f. doNothing, f. DoChar, f. throwSwitches, f. delFile
##     I.A Music/Sound Functions
##    II. Graphical/Menu Classes
##       - c. IntroGraphics, c. CloudNoise, c. WCloudNoise, c. FadeText,
##         c. ButtonBox, c. Menu, c. RelMap c. LeaveWindow, c. ScrollBar,
##         c. InvWindow, c. Dialogue, c. NDialogue, c.OptWindow, c. CWindow,
##         c. ProgressBar
##   III. Misc. Graphical Functions
##       - f. renderButtons, f. renderMenus, f. renderText, f. renderLights, f. renderGraphics,
##         f. drawBox, f. doMenu, f. solidScale, f. textWrap, f. killMenus
##    IV. Input Functions
##       - f. handle_mouse, f. mouse_isvisible, f. handle_keys, f. adjustScreen
##     V. Screen Change Functions
##       - f. doIntroSetup, f. doWorldGenSetup, f. doWorldAtlasSetup
##    VI. Intro
##       - f. doIntro
##   VII. Intro Transition
##       - f. wipeIntro
##  VIII. World Drawing Functions
##       - f. LoadWorld, f. Draw[type]...
##    IX. Land Generation
##       - c. World
##     X. Terrain Feature Naming
##       - c. WorldNaming
##    XI. Entity Generation
##       - c. WorldCreatures
##   XII. History Generation
##       - c. WorldHistory
##  XIII. World Atlas
##       - c. WorldAtlas
##   XIV. Main Game Architecture
##       - c. PlayWorld, c. Pathfinder
##    XV. Thesaurus Entries
##       - f. t
##   XVI. Main Worldgen Loop
##       - f. doWorldGen
##  XVII. Main World Atlas Loop
##       - f. doWorldAtlas
## XVIII. Main Game Loop
##       - c. MainGame
##   XIX. Main Application Loop

####################################
# Load the initial variables.      #
####################################

DOSCREEN = 0
SCREEN_WIDTH = int(init['SCREEN WIDTH'])
SCREEN_HEIGHT = int(init['SCREEN HEIGHT'])
VIEW_WIDTH = SCREEN_WIDTH - 22
VIEW_HEIGHT = SCREEN_HEIGHT - 16
MAP_WIDTH = int(init['WORLD MAP WIDTH'])
MAP_HEIGHT = int(init['WORLD MAP HEIGHT'])
RMAP_WIDTH = int(init['REGION MAP WIDTH'])
RMAP_HEIGHT = int(init['REGION MAP HEIGHT'])
LIMIT_FPS = 30

NoRefresh = False

fontx = 32
fonty = 2055

MVolume = ((int(init['MUSIC VOLUME']) * 1.0) / 100)
SVolume = ((int(init['SFX VOLUME']) * 1.0) / 100)

playerx, oplayerx = 1,1
playery, oplayery = 1,1
PY, PX = 0,0
PCX, PCY = 0,0
bplayery = {}

tpcount = 0
intronoise = libtcod.noise_new(2)
libtcod.noise_set_type(intronoise, libtcod.NOISE_SIMPLEX)
intromap = libtcod.map_new(SCREEN_WIDTH, SCREEN_HEIGHT)
wgpic = libtcod.image_new(MAP_WIDTH, MAP_HEIGHT)
#tfile = open('image\\txt\\title.txt', 'r')
#title = tfile.readlines()
#tfile.close()
TextList = []
LightList = []
GraphicsList = []
ButtonList = []
GButtonList = []
MGButtonList = []
ButtonLock = False
MenuList = []
PathList = []
XConsoles = []
TopWindow = []
GraphicsLayer = libtcod.console_new(SCREEN_WIDTH,SCREEN_HEIGHT)
wpwindow = libtcod.console_new(MAP_WIDTH, MAP_HEIGHT)
wrwindow = libtcod.console_new(RMAP_WIDTH, RMAP_HEIGHT)
wiwindow = libtcod.console_new(VIEW_WIDTH, SCREEN_HEIGHT - VIEW_HEIGHT - 3)
wswindow = libtcod.console_new(SCREEN_WIDTH - VIEW_WIDTH - 3,SCREEN_HEIGHT - 2)
toplayer = libtcod.console_new(VIEW_WIDTH,VIEW_HEIGHT)
PCRlayer = libtcod.console_new(RMAP_WIDTH,RMAP_HEIGHT)
PCWlayer = libtcod.console_new(MAP_WIDTH,MAP_HEIGHT)
LoadScreen = libtcod.console_new(VIEW_WIDTH,VIEW_HEIGHT)
GUILayer = libtcod.console_new(32,9)
GUIBlurb = libtcod.console_new(24,6)
GUIBlurbCon = [GUIBlurb,0,0,24,6,0,0,1.0,1.0,None]
TimeLayer = libtcod.console_new(16,5)
PauseLayer = libtcod.console_new(5,5)

wpfxwindow = libtcod.console_new(MAP_WIDTH, MAP_HEIGHT)
libtcod.console_set_key_color(wpfxwindow,libtcod.magenta)
libtcod.console_set_key_color(LoadScreen,libtcod.magenta)
libtcod.console_set_default_background(wpfxwindow,libtcod.magenta)
libtcod.console_clear(wpfxwindow)
libtcod.console_set_key_color(GUIBlurb,libtcod.magenta)
libtcod.console_set_default_background(GUIBlurb,libtcod.magenta)
libtcod.console_clear(GUIBlurb)

WeatherLayer = []
NoUpdate = False
IntroHover = False
MenuSetting = None
WorldGoing = False
KeyLock = False
MouseLock = False
WorldDone = False
NamingDone = False
CreatureDone = False
HistoryDone = False
DoScaleLayer = False
DoLoadScreen = False
DoHUD = False
NoButtons,NoMenus,NoGraphics = False,False,False
NoMenus = False
NoKeys = False
paraswitch = False
relswitch = False
scaleswitch = False
ctitles = []
curchoice = ''
lastcity = None
moveclouds = False
hpcswitch = False
pathlock = False
MoveLock = False
ignoreclick = True
cannotleave = False
changecursor = False
killkeycheck = False
freeze = False
DoMessageLog = False
lastmove = time.time()

globaljobs = []

LockName = 'None'
RenderTiles = []

wmlev = 180
wwlev = 151

PCcol = libtcod.dark_red
scrollcolor = libtcod.Color(245,240,219)
scrollcolor2 = libtcod.Color(233,216,137)
scrollbcol = libtcod.Color(169,125,47)
scrollbcolh = libtcod.Color(220,163,61)
bannercolor = libtcod.Color(240,239,216)
ViewRad = 10

# Movement Key Dictionary

movekeys = {}
movekeys[libtcod.KEY_UP] = [0,-1]
movekeys[libtcod.KEY_KP8] = [0,-1]
movekeys[libtcod.KEY_DOWN] = [0,1]
movekeys[libtcod.KEY_KP2] = [0,1]
movekeys[libtcod.KEY_LEFT] = [-1,0]
movekeys[libtcod.KEY_KP4] = [-1,0]
movekeys[libtcod.KEY_RIGHT] = [1,0]
movekeys[libtcod.KEY_KP6] = [1,0]
movekeys[libtcod.KEY_KP7] = [-1,-1]
movekeys[libtcod.KEY_KP9] = [1,-1]
movekeys[libtcod.KEY_KP1] = [-1,1]
movekeys[libtcod.KEY_KP3] = [1,1]

# Graphical Button Dictionary

buttondict = {}
buttondict['Inventory'] = [0,70,17,3]
buttondict['Skills and Spells'] = [0,73,17,3]
buttondict['Character'] = [0,76,17,3]
buttondict['Journal'] = [0,79,17,3]
buttondict['Constructions'] = [0,82,17,3]
buttondict['Ground View'] = [0,85,17,3]
buttondict['Options'] = [0,88,17,3]

bannerdict = {}
bannerdict['Type 1'] = [21,12]

####################################
# I. Misc. Functions               #
####################################

def wchoice(lst):
    total = 0
    for pair in lst:
        total += pair[1]
    if str(total) != '1.0':
        raise ValueError
    randlist = []
    for pair in lst:
        randlist += [pair[0]] * int(pair[1] * 1000)
    return choice(randlist)

def dchoice(choicelist,capitalize = 0,possessive = 0):
    global paraswitch, ctitles, curchoice
    if not possessive:
        poss = ''
    else:
        if not paraswitch or not choicelist == ctitles:
            poss = '\'s'
        else:
            poss = 's'
    if not paraswitch or not choicelist == ctitles:
        dchoice = choice(choicelist)
        curchoice = dchoice
        if capitalize:
            return dchoice[0].upper() + dchoice[1:] + poss
        else:
            return dchoice + poss
    else:
        if capitalize:
            return 'It' + poss
        else:
            return 'it' + poss

def DictCmp(x, y):
    if x[1] > y[1]:
        return -1
    elif x[1] == y[1]:
        return 0
    else:
        return 1

def ListCmp(x, y):
    if x[0] > y[0]:
        return -1
    elif x[0] == y[0]:
        return 0
    else:
        return 1

def ListCmp2(x, y):
    if x[1] > y[1]:
        return -1
    elif x[1] == y[1]:
        return 0
    else:
        return 1


def LenCmp(x, y):
    if len(x) > len(y):
        return -1
    elif len(x) == len(y):
        return 0
    else:
        return 1

def HeightSort(x, y):
    if wheightdict['%s,%s' % (x[0],x[1])] > wheightdict['%s,%s' % (y[0],y[1])]:
        return -1
    elif wheightdict['%s,%s' % (x[0],x[1])] == wheightdict['%s,%s' % (y[0],y[1])]:
        return 0
    else:
        return 1

def modifyList(curpos):
    curpos = list(curpos)
    compos = curpos.index(',')
    curpos.remove(',')
    curpos = [curpos[0:compos],curpos[compos:]]
    curpos[0] = int(''.join(map(lambda x: str(x),curpos[0])))
    curpos[1] = int(''.join(map(lambda x: str(x),curpos[1])))
    return curpos

def getRivChar(adjdirs, tributes):
    if len(adjdirs) == 1:
        if 'n' in adjdirs:
            if tributes > 2:
                return lrivsources1
            else:
                return choice([rivsources1,rivsources2])
        elif 's' in adjdirs:
            if tributes > 2:
                return lrivsourcen1
            else:
                return choice([rivsourcen1,rivsourcen2])
        elif 'w' in adjdirs:
            if tributes > 2:
                return lrivsourcee1
            else:
                return choice([rivsourcee1,rivsourcee2])
        elif 'e' in adjdirs:
            if tributes > 2:
                return lrivsourcew1
            else:
                return choice([rivsourcew1,rivsourcew2])
    elif len(adjdirs) == 2:
        if 'w' in adjdirs and 'e' in adjdirs:
            if tributes > 2:
                return [1,6,255]
            else:
                return [15,1,255]
        elif 'w' in adjdirs and 'n' in adjdirs:
            if tributes > 2:
                return [10,6,255]
            else:
                return [24,1,255]
        elif 'w' in adjdirs and 's' in adjdirs:
            if tributes > 2:
                return [9,6,255]
            else:
                return [23,1,255]
        elif 'e' in adjdirs and 'n' in adjdirs:
            if tributes > 2:
                return [7,6,255]
            else:
                return [21,1,255]
        elif 'e' in adjdirs and 's' in adjdirs:
            if tributes > 2:
                return [8,6,255]
            else:
                return [22,1,255]
        elif 'n' in adjdirs and 's' in adjdirs:
            if tributes > 2:
                return [0,6,255]
            else:
                return [14,1,255]
    elif len(adjdirs) == 3:
        if 'w' in adjdirs and 'e' in adjdirs and 'n' in adjdirs:
            if tributes > 2:
                return [4,6,255]
            else:
                return [18,1,255]
        elif 'w' in adjdirs and 'e' in adjdirs and 's' in adjdirs:
            if tributes > 2:
                return [6,6,255]
            else:
                return [20,1,255]
        elif 'n' in adjdirs and 's' in adjdirs and 'e' in adjdirs:
            if tributes > 2:
                return [5,6,255]
            else:
                return [19,1,255]
        elif 'n' in adjdirs and 's' in adjdirs and 'w' in adjdirs:
            if tributes > 2:
                return [3,6,255]
            else:
                return [17,1,255]
    elif len(adjdirs) == 4:
        return [2,6,255]

def MergeTerritory(seq):
    merged = []
    for s in seq:
        if merged.count(s) == 0:
            merged.append(s)
    return merged

def queryTile(x, y, checklist):
    global wheightdict, wfeaturedict, tivar

    qcheck = {}

    if 'Shrubland' in checklist:
        qcheck['Shrubland'] = 'sl' in wfeaturedict['%s,%s' % (x,y)]
    if 'Heathland' in checklist:
        qcheck['Heathland'] = 'hl' in wfeaturedict['%s,%s' % (x,y)]
    if 'Marshland' in checklist:
        qcheck['Marshland'] = 'ml' in wfeaturedict['%s,%s' % (x,y)]
    if 'Cacti Forest' in checklist:
        qcheck['Cacti Forest'] = 'dl' in wfeaturedict['%s,%s' % (x,y)]
    if 'Broadleaf Forest' in checklist:
        qcheck['Broadleaf Forest'] = 'bf' in wfeaturedict['%s,%s' % (x,y)]
    if 'Deciduous Forest' in checklist:
        qcheck['Deciduous Forest'] = 'df' in wfeaturedict['%s,%s' % (x,y)]
    if 'Mixed Forest' in checklist:
        qcheck['Mixed Forest'] = 'mf' in wfeaturedict['%s,%s' % (x,y)]
    if 'Coniferous Forest' in checklist:
        qcheck['Coniferous Forest'] = 'cf' in wfeaturedict['%s,%s' % (x,y)]
    if 'Evergreen Forest' in checklist:
        qcheck['Evergreen Forest'] = 'ef' in wfeaturedict['%s,%s' % (x,y)]
    if 'Tropical Forest' in checklist:
        qcheck['Tropical Forest'] = 'tf' in wfeaturedict['%s,%s' % (x,y)]
    if 'Swamp' in checklist:
        qcheck['Swamp'] = 'sw' in wfeaturedict['%s,%s' % (x,y)]
    if 'Desert' in checklist:
        qcheck['Desert'] = 'd' in wfeaturedict['%s,%s' % (x,y)]
    if 'Cave' in checklist:
        qcheck['Cave'] = 'c' in wfeaturedict['%s,%s' % (x,y)]
    if 'Beach' in checklist:
        qcheck['Beach'] = 'b' in wfeaturedict['%s,%s' % (x,y)]
    if 'River' in checklist:
        qcheck['River'] = 'r' in wfeaturedict['%s,%s' % (x,y)]
    if 'Highland' in checklist:
        qcheck['Highland'] = wmlev - 8 < wheightdict['%s,%s' % (x,y)] < wmlev
    if 'Mountain' in checklist:
        qcheck['Mountain'] = wmlev < wheightdict['%s,%s' % (x,y)]
    if 'Plain' in checklist:
        qcheck['Plain'] = 'pl' in wfeaturedict['%s,%s' % (x,y)]
    if 'Tundra' in checklist:
        qcheck['Tundra'] = wfeaturedict['%s,%s' % (x,y)] == 's' and 152 < wheightdict['%s,%s' % (x,y)] < 168
    if 'Savannah' in checklist:
        qcheck['Savannah'] = len(wfeaturedict['%s,%s' % (x,y)]) == 0 and 152 < wheightdict['%s,%s' % (x,y)] < 168 and \
                             y > (((MAP_HEIGHT / 4) * 3) + tivar[x])
    if 'Glacier' in checklist:
        qcheck['Glacier'] = 'g' in wfeaturedict['%s,%s' % (x,y)]
    if 'River Bank' in checklist:
        qcheck['River Bank'] = 'r' in wfeaturedict['%s,%s' % (x,y)]
    if 'Pond' in checklist:
        qcheck['Pond'] = (float(y) / MAP_HEIGHT * 102) > ivar[x] and 'd' not in wfeaturedict['%s,%s' % (x,y)] and \
                         152 < wheightdict['%s,%s' % (x,y)] < wmlev
    if 'Ocean' in checklist:
        qcheck['Ocean'] = 'o' in wfeaturedict['%s,%s' % (x,y)]
    if 'Lake' in checklist:
        qcheck['Lake'] = 'l' in wfeaturedict['%s,%s' % (x,y)]
    if 'Lakeshore' in checklist:
        qcheck['Lakeshore'] = 'ls' in wfeaturedict['%s,%s' % (x,y)]

    condition = True

    for check in checklist:
        condition = condition and qcheck[check]

    return condition

def doNothing():
    pass

def DoChar(char,charnum = None,store = False,x = None,y = None):
    if not charnum:
        try:
            charnum = char[2]
        except TypeError:
            print char
    #libtcod.sys_update_char(charnum, 11, 1, fontimage, char[0] * 14, char[1] * 14)
    libtcod.console_map_ascii_code_to_font(charnum,char[0],char[1])
    if store:
        GameWorld.wcdict[GameWorld.curz]['%s,%s' % (x,y)] = char
    return charnum

def throwSwitches(subject,switches):
    for switch in switches:
        case = getattr(subject,switch)
        setattr(subject,switch,not case)

def delFile(path):
    os.remove(path)
    
####################################
# I.A Music/Sound Functions        #
####################################

def playMusic(fname,loops=0,start=0.0):
    global MVolume
    pygame.mixer.music.load(fname)
    pygame.mixer.music.play(loops,start)
    pygame.mixer.music.set_volume(MVolume)

def playSound(fname,fadeout=0,volume=1.0):
    global SVolume
    sound = pygame.mixer.Sound(fname)
    sound.play()
    if fadeout:
        sound.fadeout(fadeout)
    sound.set_volume(min(SVolume,volume))
    
    
    return sound

####################################
# II. Graphical/Menu Classes       #
####################################

class PathMarker(threading.Thread):
    # Marks a 'clicked' area.

    def __init__(self, window, x, y, radius = 4):
        threading.Thread.__init__(self)
        self.window = window
        self.x = x
        self.y = y
        self.radius = radius
        self.killswitch = False
        self.sleeptime = 0.05
        if not GameWorld.rswitch:
            self.sleeptime = (0.1)
            self.radius = min(self.radius,2)

    def doMarker(self):
        global Clouds, PCX, PCY, toplayer, lock, LockName
        for num in range(-self.radius,self.radius + 1):
            for num2 in range(-self.radius,self.radius + 1):
                if self.rx - num >= 0 and self.rx - num < VIEW_WIDTH and self.ry >= 0 and self.ry < VIEW_HEIGHT:
                    a = pow(num, 2)
                    b = pow(num2, 2)
                    d = sqrt(a + b)
                    if d <= self.radius and d >= self.radius - 1:
                        lock.acquire()
                        ocol = libtcod.console_get_char_background(self.window, self.mxpos - num, self.mypos - num2)
                        colr = 255 - int(ocol.r)
                        colg = 255 - int(ocol.g)
                        colb = 255 - int(ocol.b)
                        self.col = libtcod.Color(colr,colg,colb)
                        libtcod.console_set_default_foreground(toplayer, self.col)
                        if num == 0 and abs(num2) > 0:
                            circlechar = [8,1,190]
                        elif abs(num) > 0 and num2 == 0:
                            circlechar = [13,0,190]
                        elif (num < 0 and num2 < 0) or (num > 0 and num2 > 0):
                            circlechar = [2,1,190]
                        elif (num > 0 and num2 < 0) or (num < 0 and num2 > 0):
                            circlechar = [15,0,190]
                        elif [num,num2] == [0,0]:
                            circlechar = [14,4,190]
                        if LockName != 'HandleView':
                            libtcod.console_print_ex(toplayer, self.rx - num, self.ry - num2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(circlechar)))
                        lock.release()
        self.radius -= 1

    def run(self):
        global PCX, PCY, toplayer
        self.rx = self.x - (SCREEN_WIDTH - VIEW_WIDTH) + 2
        self.ry = self.y - 2
        self.mxpos = PX + self.x - (SCREEN_WIDTH - VIEW_WIDTH - 2)
        self.mypos = PY + self.y - 2
        libtcod.console_clear(toplayer)
        dist = int(sqrt((pow(PCX - self.mxpos,2) + pow(PCY - self.mypos,2))))
        if dist < 7:
            self.radius -= 7 - dist
        while self.radius > 0:
            if self.killswitch:
                break
            self.doMarker()
            time.sleep(self.sleeptime)
            libtcod.console_clear(toplayer)

class IntroGraphics(threading.Thread):
    # Intro Screen Function

    def __init__(self, x, y, w, h, radius, lightmin = 0, lightmax = 15, color=libtcod.white, con=0, lightcon=None, \
                 xmod = 0, ymod = 0, candlerad = 10, candle1 = (6,12), candle2 = (25,12)):
        threading.Thread.__init__(self)
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.candlerad = candlerad
        self.xmod = xmod
        self.ymod = ymod
        self.color = color
        self.con = con
        self.lightcon = lightcon
        self.radius = radius
        self.lightmax = lightmax
        self.lightmin = lightmin
        self.intro_noise_dx = 0.0
        self.intro_noise_dy = 0.0
        self.cpercdict = {}
        self.killswitch = False
        self.modx = float(self.w) / float(120)
        self.mody = float(self.h) / float(80)
        self.paused = False
        self.candle1,self.candle2 = candle1,candle2
        self.candlecoldict = {}

    def introDraw(self):
        self.intro_noise_dx += 0.01
        self.intro_noise_dy += 0.01
        self.randnum = max(min(self.randnum + randrange(-1,2),self.lightmax),self.lightmin)
        for y in range(self.h):
            for x in range(self.w):
                f = [3.5 * x / (SCREEN_WIDTH - 4) + self.intro_noise_dx,
                     3.5 * y / (SCREEN_HEIGHT - 4) + self.intro_noise_dy]
                value = libtcod.noise_get_fbm(intronoise, f, 3)
                c = int((value + 1.0) / 2.0 * 255)
                if c < 0:
                    c = 0
                elif c > 255:
                    c = 255
                col = libtcod.Color(c / 7, c / 7, c / 7)
                try:
                    mixcol = libtcod.color_lerp(self.color, col, min(self.cpercdict['%s,%s' % (x,y)] + (self.randnum * 0.01),1.0))                    
                except KeyError:
                    mixcol = col
                libtcod.console_set_char_background(self.con, x + self.xmod, y + self.ymod, mixcol, libtcod.BKGND_SET)

    def cpercsetup(self):
        for y in range(-self.radius,self.radius + 1):
            for x in range(-self.radius,self.radius + 1):
                nx = (self.x - x)
                ny = (self.y - y)
                dist = int(sqrt((pow(nx - self.x,2) + pow(ny - self.y,2))))
                if dist < self.radius:
                    self.cpercdict['%s,%s' % (nx,ny)] = ((dist * 1.0) / (self.radius * 1.0))

    def doCandles(self):
        # Candle 1
        for x in range(-self.candlerad,self.candlerad + 1):
            for y in range(-self.candlerad,self.candlerad + 1):
                dist = int(sqrt((pow((self.candle1[0] - x) - self.candle1[0],2) + pow((self.candle1[1] - y) - self.candle1[1],2))))
                if dist < self.candlerad:
                    dperc = 1.0 - ((dist * 1.0) / (self.candlerad * 1.0))
                    dpercmod = random.randrange(-8,8) * 0.01
                    dperc = max(min(dperc + dpercmod,0.95),0.0)
                    fcol = libtcod.color_lerp(libtcod.white,self.color,dperc)
                    bcol = libtcod.color_lerp(libtcod.Color(2,0,0),self.color,dperc)
                    self.candlecoldict['%s,%s' % (self.candle1[0] - x,self.candle1[1] - y)] = fcol
        # Candle 2
        for x in range(-self.candlerad,self.candlerad + 1):
            for y in range(-self.candlerad,self.candlerad + 1):
                dist = int(sqrt((pow((self.candle2[0] - x) - self.candle2[0],2) + pow((self.candle2[1] - y) - self.candle2[1],2))))
                if dist < self.candlerad:
                    dperc = 1.0 - ((dist * 1.0) / (self.candlerad * 1.0))
                    dpercmod = random.randrange(-8,8) * 0.01
                    dperc = max(min(dperc + dpercmod,0.95),0.0)
                    fcol = libtcod.color_lerp(libtcod.white,self.color,dperc)
                    bcol = libtcod.color_lerp(libtcod.Color(2,0,0),self.color,dperc)
                    self.candlecoldict['%s,%s' % (self.candle2[0] - x,self.candle2[1] - y)] = fcol

    def run(self):
        self.randnum = randrange(self.lightmin,self.lightmax)
        self.cpercsetup()
        while not self.killswitch:
            if not self.paused:
                self.introDraw()
                self.doCandles()
                time.sleep(0.03)
            else:
                time.sleep(0.5)
        libtcod.console_delete(self.con)
        del self

class CloudNoise(threading.Thread):
    # This class creates and displays clouds on reflective surfaces, and also displays their shadows.

    def __init__(self,window,rheightmap,vrskip = {},bskip = {}):
        global PX, PY, PCX, PCY
        threading.Thread.__init__(self)
        self.cloudnoise = libtcod.noise_new(2)
        libtcod.noise_set_type(self.cloudnoise, libtcod.NOISE_SIMPLEX)
        self.window = window
        self.rheightmap = rheightmap
        self.cloudnoise_dx = 0.0
        self.cloudnoise_dy = 0.0
        self.ocolordict = {}
        self.ofcolordict = {}
        self.ncolordict = {}
        self.nfcolordict = {}
        self.vrskip = vrskip
        self.bskip = bskip
        self.colorswitch = False
        self.killswitch = False
        self.curdrawing = False
        self.initdone = False
        self.OPX = PX
        self.OPY = PY
        self.OPCX = PCX
        self.OPCY = PCY
        self.paused = False
        self.hover = False

    def run(self):
        global MouseLock, MoveLock, pathlock, PX, PY
        while not self.killswitch:
            if not self.paused:
                self.render()
            if not self.initdone:
                self.initdone = True
            self.OPX = PX
            self.OPY = PY
        del self

    def render(self):
        global moveclouds, PX, PY, PCX, PCY, PCcol, GraphicsList, GameWorld
        if not self.colorswitch:
            self.getColor(self.window)
            self.colorswitch = True
        if moveclouds:
            self.curdrawing = True
            if not self.colorswitch:
                self.getColor(self.window)
                self.colorswitch = True
            if not self.hover:
                self.cloudnoise_dx += 0.005
                self.cloudnoise_dy += 0.005
            ylist = range(-5,VIEW_HEIGHT + 5)
            xlist = range(-5,VIEW_WIDTH + 5)
            for y in ylist:
                for x in xlist:
                    while self.paused:
                        time.sleep(0.1)
                    while not moveclouds:
                        time.sleep(0.1)
                    nx = x + PX
                    ny = y + PY
                    if nx > RMAP_WIDTH - 1:
                        continue
                    elif nx < 0:
                        continue
                    elif ny > RMAP_HEIGHT - 1:
                        continue
                    elif ny < 0:
                        continue
                    try:
                        GameWorld.ldict['%s,%s' % (nx,ny)]
                        leaf = True
                    except KeyError:
                        leaf = False
                    if isinstance(self.rheightmap['%s,%s' % (nx,ny)],str):
                        f = [3.5 * nx / (VIEW_WIDTH - 4) + self.cloudnoise_dx,
                             3.5 * ny / (VIEW_HEIGHT - 4) + self.cloudnoise_dy]
                        value = libtcod.noise_get_fbm(self.cloudnoise, f, 3)
                        c = int((value + 1.0) / 2.0 * 255)
                        c = max(min(c,255),0)
                        cperc = (float(c) / 255)
                        if cperc < .5:
                            cperc = 0
                        else:
                            cperc -= .5
                            cperc *= 2.0
                        shadow = GameWorld.shadowdict['%s,%s' % (nx,ny)]
                        shadow[1] = cperc
                        GameWorld.shadowdict['%s,%s' % (nx,ny)] = shadow
                        col = libtcod.color_lerp(self.ocolordict['%s,%s' % (nx,ny)],libtcod.white,min(cperc,0.9))
                        col2 = libtcod.color_lerp(self.ofcolordict['%s,%s' % (nx,ny)],libtcod.white,cperc)
                        libtcod.console_set_char_background(self.window, nx, ny, col, libtcod.BKGND_SET)
                        libtcod.console_set_char_foreground(self.window, nx, ny, col2)
                    else:
                        num = (PCX - x)
                        num2 = (PCY - y)
                        a = pow(num, 2)
                        b = pow(num2, 2)
                        d = sqrt(a + b)
                        try:
                            self.vrskip['%s,%s' % (nx,ny)]
                            vr = True
                        except KeyError:
                            vr = False
                        try:
                            self.bskip['%s,%s' % (nx,ny)]
                            br = True
                        except KeyError:
                            br = False
                        if (not vr or d < ViewRad) and not br:
                            f = [3.5 * nx / (VIEW_WIDTH - 4) + self.cloudnoise_dx,
                                 3.5 * ny / (VIEW_HEIGHT - 4) + self.cloudnoise_dy]
                            value = libtcod.noise_get_fbm(self.cloudnoise, f, 3)
                            c = int((value + 1.0) / 2.0 * 255)
                            c = max(min(c,255),0)
                            cperc = (float(c) / 255)
                            if cperc < .5:
                                cperc = 0
                            else:
                                cperc -= .5
                                cperc *= 2.0
                            cperc = min(cperc,0.2)
                            shadow = GameWorld.shadowdict['%s,%s' % (nx,ny)]
                            shadow[1] = cperc
                            GameWorld.shadowdict['%s,%s' % (nx,ny)] = shadow
                            cperc = max(shadow[0],shadow[1])
                            try:
                                self.ncolordict['%s,%s' % (nx,ny)]
                                color = self.ncolordict['%s,%s' % (nx,ny)]
                            except KeyError:
                                color = self.ocolordict['%s,%s' % (nx,ny)]
                            try:
                                self.nfcolordict['%s,%s' % (nx,ny)]
                                fcolor = self.nfcolordict['%s,%s' % (nx,ny)]
                            except KeyError:
                                fcolor = self.ofcolordict['%s,%s' % (nx,ny)]
                            if cperc == 0:
                                libtcod.console_set_char_background(self.window, nx, ny, color, libtcod.BKGND_SET)
                                if (nx,ny) != (PCX,PCY):
                                    libtcod.console_set_char_foreground(self.window, nx, ny, fcolor)                                
                                continue
                            col = libtcod.color_lerp(color,libtcod.black,cperc)
                            col2 = libtcod.color_lerp(fcolor,libtcod.black,cperc)
                            libtcod.console_set_char_background(self.window, nx, ny, col, libtcod.BKGND_SET)
                            libtcod.console_set_char_foreground(self.window, nx, ny, col2)
            self.curdrawing = False

    def getColor(self,window):
        global MouseLock, MoveLock
        for x in range(RMAP_WIDTH):
            for y in range(RMAP_HEIGHT):
                self.ocolordict['%s,%s' % (x,y)] = libtcod.console_get_char_background(window,x,y)
                if not self.ofcolordict.get('%s,%s' % (x,y)):
                    self.ofcolordict['%s,%s' % (x,y)] = libtcod.console_get_char_foreground(window,x,y)

class WCloudNoise(threading.Thread):
    # This class creates and displays clouds on the world map.

    def __init__(self,window,vrskip = {}):
        threading.Thread.__init__(self)
        self.cloudnoise = libtcod.noise_new(2)
        libtcod.noise_set_type(self.cloudnoise,libtcod.NOISE_SIMPLEX)
        self.window = window
        self.cloudnoise_dx = 0.0
        self.cloudnoise_dy = 0.0
        self.ocolordict = {}
        self.ofcolordict = {}
        self.vrskip = vrskip
        self.colorswitch = False
        self.killswitch = False
        self.curdrawing = False
        self.initdone = False
        self.OPX = PX
        self.OPY = PY
        self.paused = False

    def run(self):
        global MouseLock, MoveLock, pathlock
        while not self.killswitch:
            if not self.paused:
                self.render()
            if not self.initdone:
                self.initdone = True
            self.OPX = PX
            self.OPY = PY
        del self

    def render(self):
        global moveclouds, PX, PY, PCX, PCY, PCcol, lock
        if not self.colorswitch:
            self.getColor(self.window)
            self.colorswitch = True
        if moveclouds:
            self.curdrawing = True
            if not self.colorswitch:
                self.getColor(self.window)
                self.colorswitch = True
            self.cloudnoise_dx += 0.005
            self.cloudnoise_dy += 0.005
            ylist = range(-5,VIEW_HEIGHT + 5)
            xlist = range(-5,VIEW_WIDTH + 5)
            ylist.sort(key=lambda y: abs((VIEW_HEIGHT / 2) - y),reverse=True)
            xlist.sort(key=lambda x: abs((VIEW_WIDTH / 2) - x),reverse=True)
            for y in ylist:
                for x in xlist:
                    while self.paused:
                        time.sleep(0.1)
                    while not moveclouds:
                        time.sleep(0.1)
                    nx = max(min(x + PX,MAP_WIDTH - 1),0)
                    ny = max(min(y + PY,MAP_HEIGHT - 1),0)
                    f = [3.5 * nx / int(500 * .2) + self.cloudnoise_dx,
                         3.5 * ny / int(300 * .2) + self.cloudnoise_dy]
                    value = libtcod.noise_get_fbm(self.cloudnoise, f, 3)
                    c = int((value + 1.0) / 2.0 * 255)
                    c = max(min(c,255),0)
                    cperc = (float(c) / 255)
                    if cperc < .5:
                        cperc = 0
                    else:
                        cperc -= .5
                        cperc *= 2.0
                        cperc = min(cperc,0.9)
                    if [self.OPX,self.OPY] == [PX,PY]:
                        try:
                            if GameWorld.clouddict['%s,%s' % (nx,ny)] == 0 and cperc == 0:
                                continue
                        except KeyError:
                            if cperc == 0:
                                GameWorld.clouddict['%s,%s' % (nx,ny)] = cperc
                                continue
                    if wheightdict['%s,%s' % (nx,ny)] < 152 and 'g' not in wfeaturedict['%s,%s' % (nx,ny)]:
                        lock.acquire()
                        GameWorld.clouddict['%s,%s' % (nx,ny)] = cperc
                        col = libtcod.color_lerp(self.ocolordict['%s,%s' % (nx,ny)],libtcod.white,cperc)
                        col2 = libtcod.color_lerp(self.ofcolordict['%s,%s' % (nx,ny)],libtcod.white,cperc)
                        libtcod.console_set_char_background(self.window, nx, ny, col, libtcod.BKGND_SET)
                        libtcod.console_set_char_foreground(self.window, nx, ny, col2)
                        lock.release()
            self.curdrawing = False

    def getColor(self,window):
        global MouseLock, MoveLock
        for x in range(MAP_WIDTH):
            for y in range(MAP_HEIGHT):
                self.ocolordict['%s,%s' % (x,y)] = libtcod.console_get_char_background(window,x,y)
                if not self.ofcolordict.get('%s,%s' % (x,y)):
                    self.ofcolordict['%s,%s' % (x,y)] = libtcod.console_get_char_foreground(window,x,y)

class FadeText(threading.Thread):
    # This class updates fading text.

    def __init__(self, text, x, y, speed=50, con=0, fadefrom=False, fadeto=libtcod.white, align='left', conwidth=VIEW_WIDTH, wait=0, domouse = False, \
                 hookmethod = None, hoverhook = None, unhoverhook = None):
        global TextList
        self.hoverswitch = False
        threading.Thread.__init__(self)
        self.fadevar = 0
        self.text = text
        self.tcopy = text
        self.x = x
        self.y = y
        self.con = con
        self.fadefrom = fadefrom
        self.fadeto = fadeto
        self.ofadeto = copy.copy(fadeto)
        self.align = align
        self.speed = speed
        self.conwidth = conwidth
        self.wait = wait
        self.killswitch = False
        self.domouse = domouse
        self.firstfade = False
        self.playsound = True
        self.hookmethod = hookmethod
        if hoverhook:
            self.hoverhook = hoverhook
        if unhoverhook:
            self.unhoverhook = unhoverhook
        if domouse:
            self.covercells = {}
            self.coverswitch = False
        TextList = TextList + [self]

    def textDraw(self):
        global TextList
        lock.acquire()
        if self.fadevar < self.speed:
            if not self.fadefrom:
                fadefrom = libtcod.console_get_char_background(self.con, self.x, self.y)
            else:
                fadefrom = self.fadefrom
            libtcod.console_set_default_foreground(self.con, fadefrom)
            self.fadevar += 1
            self.text = copy.copy(self.tcopy)
            if type(self.text) == list:
                lineskip = 0
                if self.align == 'center':
                    while len(self.text) > 0:
                        breakindex = self.text.index('break')
                        line = copy.copy(self.text[:breakindex])
                        self.text = self.text[breakindex + 1:]
                        charnum = 0
                        for char in line:
                            mixcolor = fadefrom
                            mixcolor = libtcod.color_lerp(fadefrom, self.fadeto, (min(self.fadevar + charnum,self.speed)) * (1.0 / self.speed))
                            libtcod.console_set_default_foreground(self.con, mixcolor)
                            if self.domouse:
                                if not self.coverswitch:
                                    self.covercells['%s,%s' % (self.x - (len(line) / 2) + charnum,self.y + lineskip)] = True
                            if self.align == 'center':
                                libtcod.console_set_default_foreground(self.con, mixcolor)
                                libtcod.console_print_ex(self.con, self.x - (len(line) / 2) + charnum, self.y + lineskip, libtcod.BKGND_NONE, libtcod.CENTER, chr(DoChar(char)))
                            charnum += 1
                        lineskip += 1
            else:
                charnum = 0
                yplus = 0
                lines = self.text.split('\n')
                curline = 0
                for char in self.text:
                    try:
                        if char == '\n':
                            charnum = 0
                            yplus += 1
                            continue
                    except IndexError:
                        pass
                    mixcolor = fadefrom
                    mixcolor = libtcod.color_lerp(fadefrom, self.fadeto, (min(self.fadevar + charnum,self.speed)) * (1.0 / self.speed))
                    libtcod.console_set_default_foreground(self.con, mixcolor)
                    if self.align == 'left':
                        libtcod.console_print_ex(self.con, self.x + charnum, self.y + yplus, libtcod.BKGND_NONE, libtcod.LEFT, char)
                    elif self.align == 'right':
                        libtcod.console_print_ex(self.con, self.x + charnum, self.y + yplus, libtcod.BKGND_NONE, libtcod.RIGHT, char)
                    elif self.align == 'center':
                        libtcod.console_print_ex(self.con, self.x + charnum - (len(lines[curline + yplus]) / 2), self.y + yplus, libtcod.BKGND_NONE, libtcod.CENTER, char)
                    charnum += 1
            self.coverswitch = True
        else:
            self.firstfade = True
        lock.release()

    def run(self):
        global TextList
        while True and not self.killswitch:
            if self in TextList:
                time.sleep(0.1)
                continue
            break

class ButtonBox():
    # This class instantiates clickable buttons.

    def __init__(self, window, x, y, text, ID, offx = 0, offy = 0, tcolor = libtcod.black, tbcolor = None, \
                 hovcolor = None):
        global ButtonList, key
        if not tbcolor:
            tbcolor = libtcod.darker_crimson
        self.window = window
        self.x = x
        self.y = y
        self.offx = offx
        self.offy = offy
        self.text = text
        self.ID = ID
        self.tcolor = tcolor
        self.tbcolor = tbcolor
        self.redrawbox = False
        if not hovcolor:
            self.hovcolor = libtcod.crimson
        else:
            self.hovcolor = hovcolor
        self.drawn = False
        ButtonList = ButtonList + [self]
        DrawScroll(self.window, self.x - 2, self.y - 1, len(self.text) + 3,2,1)

    def drawButton(self):
        global killkeycheck
        if self.redrawbox:
            DrawScroll(self.window, self.x - 2, self.y - 1, len(self.text) + 3,2,1)
            self.redrawbox = False

        hoverdict = {}
        hoveropt = False

        for ox in range(self.x + self.offx - 2, self.x + self.offx + 2 + len(self.text)):
            for oy in range(self.y + self.offy, self.y + self.offy + 3):
                hoverdict['%s,%s' % (ox,oy)] = True

        if cursorswitch:
            if hoverdict.get('%s,%s' % (handle_mouse('cx'),handle_mouse('cy') - 1)):
                buttonopt = self.text
                for ox in range(self.x - 1, self.x + 1 + len(self.text)):
                    libtcod.console_set_char_foreground(self.window, ox, self.y, self.hovcolor)
                self.drawn = False
                hoveropt = True
            elif not self.drawn:
                libtcod.console_set_default_foreground(self.window, self.tbcolor)
                libtcod.console_print_ex(self.window, self.x, self.y, libtcod.BKGND_NONE, libtcod.LEFT, self.text[0])
                libtcod.console_set_default_foreground(self.window, self.tcolor)
                libtcod.console_print_ex(self.window, self.x + 1, self.y, libtcod.BKGND_NONE, libtcod.LEFT, self.text[1:])
                self.drawn = True

        if hoveropt and handle_mouse('lbutton_pressed') and not killkeycheck:
            key.c = ord(self.ID)
        
        if self not in ButtonList:
            del self

def GButton(window,x,y,ID,dokey,offx,offy):
    global GButtonList, NoButtons, ButtonLock, buttondict
    button = buttondict[ID]

    FGButtonList = map(lambda x: x[3],GButtonList)
    curbutton = FGButtonList.index(ID)

    if not GButtonList[curbutton][6]:
        ButtonLock = True
        lock.acquire()
        for num in range(button[2]):
            for num2 in range(button[3]):
                libtcod.console_print_ex(0,x + num + offx,y + num2 + offy,libtcod.BKGND_NONE,libtcod.LEFT,' ')
                char = [button[0] + num,button[1] + num2,254]
                libtcod.console_set_default_foreground(window,libtcod.white)
                libtcod.console_print_ex(window,x + num,y + num2,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
        ButtonLock = False
        lock.release()
        GButtonList[curbutton][6] = True

    switched = GButtonList[curbutton][7]
    hoverdict = {}
    for ox in range(x + offx, x + offx + button[2]):
        for oy in range(y + offy, y + offy + button[3]):
            hoverdict['%s,%s' % (ox,oy)] = True
            
    if not ButtonLock:
        hoveropt = False
        if hoverdict.get('%s,%s' % (handle_mouse('cx'),handle_mouse('cy') - 1)):
            if not switched:
                ButtonLock = True
                lock.acquire()
                for num in range(button[2]):
                    for num2 in range(button[3]):
                        libtcod.console_print_ex(0,x + num + offx,y + num2 + offy + 1,libtcod.BKGND_NONE,libtcod.LEFT,' ')
                        char = [button[0] + num,button[1] + num2 + button[3],254]
                        libtcod.console_set_default_foreground(window,libtcod.white)
                        libtcod.console_print_ex(window,x + num,y + num2,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                GButtonList[curbutton][7] = True
                switched = True
                ButtonLock = False
                lock.release()
            hoveropt = True

        if hoveropt and handle_mouse('lbutton_pressed') and not killkeycheck:
            key.c = ord(dokey)
            
        elif (not hoveropt) and switched:
            lock.acquire()
            ButtonLock = True
            for num in range(button[2]):
                for num2 in range(button[3]):
                    libtcod.console_print_ex(0,x + num + offx,y + num2 + offy + 1,libtcod.BKGND_NONE,libtcod.LEFT,' ')
                    char = [button[0] + num,button[1] + num2,254]
                    libtcod.console_set_default_foreground(window,libtcod.white)
                    libtcod.console_print_ex(window,x + num,y + num2,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
            ButtonLock = False
            lock.release()
            GButtonList[curbutton][7] = False
            switched = False

def MGButton(window,x,y,ID,dokey,offx,offy):
    global MGButtonList, NoButtons, ButtonLock, buttondict
    button = buttondict[ID]

    FMGButtonList = map(lambda x: x[3],MGButtonList)
    curbutton = FMGButtonList.index(ID)

    if not MGButtonList[curbutton][6]:
        ButtonLock = True
        lock.acquire()
        for num in range(button[2]):
            for num2 in range(button[3]):
                libtcod.console_print_ex(0,x + num + offx,y + num2 + offy,libtcod.BKGND_NONE,libtcod.LEFT,' ')
                char = [button[0] + num,button[1] + num2,254]
                libtcod.console_set_default_foreground(window,libtcod.white)
                libtcod.console_print_ex(window,x + num,y + num2,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
        ButtonLock = False
        lock.release()
        MGButtonList[curbutton][6] = True

    switched = MGButtonList[curbutton][7]
    hoverdict = {}
    for ox in range(x + offx, x + offx + button[2]):
        for oy in range(y + offy, y + offy + button[3]):
            hoverdict['%s,%s' % (ox,oy)] = True
            
    if not ButtonLock:
        hoveropt = False
        if hoverdict.get('%s,%s' % (handle_mouse('cx'),handle_mouse('cy') - 1)):
            if not switched:
                ButtonLock = True
                lock.acquire()
                for num in range(button[2]):
                    for num2 in range(button[3]):
                        libtcod.console_print_ex(0,x + num + offx,y + num2 + offy + 1,libtcod.BKGND_NONE,libtcod.LEFT,' ')
                        char = [button[0] + num,button[1] + num2 + 29,254]
                        libtcod.console_set_default_foreground(window,libtcod.white)
                        libtcod.console_print_ex(window,x + num,y + num2,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                MGButtonList[curbutton][7] = True
                switched = True
                ButtonLock = False
                lock.release()
            hoveropt = True

        if hoveropt and handle_mouse('lbutton_pressed') and not killkeycheck:
            key.c = ord(dokey)
            
        elif (not hoveropt) and switched:
            lock.acquire()
            ButtonLock = True
            for num in range(button[2]):
                for num2 in range(button[3]):
                    libtcod.console_print_ex(0,x + num + offx,y + num2 + offy + 1,libtcod.BKGND_NONE,libtcod.LEFT,' ')
                    char = [button[0] + num,button[1] + num2,254]
                    libtcod.console_set_default_foreground(window,libtcod.white)
                    libtcod.console_print_ex(window,x + num,y + num2,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
            ButtonLock = False
            lock.release()
            MGButtonList[curbutton][7] = False
            switched = False

class Menu(threading.Thread):
    # This class instantiates navigable menus.

    def __init__(self, window, ox, oy, optionlist, hcolor = None, ocolor = None, \
                 tcolor = None, doback = 1, align = 'left', offx = 0, offy = 0, linespace = 1, \
                 moffset = 0, title = None, talign = 'center', tx = None, ty = None, passvar = None, \
                 tback = False, fhcolor = None, MethodList = None, \
                 BMethodList = None, clipping = True, numbers = True, dialogue = None, \
                 drawbox = False, boxtype = 0, bannertitle = False, bannertype = 'Type 1'):
        global MenuList
        threading.Thread.__init__(self)
        self.window = window
        self.ox = ox
        self.oy = oy
        self.tx = tx
        self.ty = ty
        self.optionlist = optionlist
        self.hcolor = hcolor
        self.ocolor = ocolor
        self.tcolor = tcolor
        self.fhcolor = fhcolor
        self.tback = tback
        self.doback = doback
        self.align = align
        self.offx = offx
        self.offy = offy
        self.clipping = clipping
        self.numbers = numbers
        self.linespace = linespace
        self.moffset = moffset
        self.title = title
        self.bannertitle = bannertitle
        self.talign = talign
        self.passvar = passvar
        self.BMethodList = BMethodList
        self.MethodList = MethodList
        self.dialogue = dialogue
        self.drawbox = drawbox
        self.boxtype = boxtype
        MenuList = MenuList + [self]
        self.menugoing = False

    def drawMenu(self):
        global playery, oplayery, mouse, hoveropt, MenuSetting, Atlas, MenuList, mplayery, relswitch, bplayery, ButtonList, \
               DOSCREEN, PX, PY, GameWorld, hcolor, bgcolor, buttont, NoMenus, lock

        lock.acquire()

        opcelldict = {}

        if not self.hcolor:
            self.hcolor = hcolor
        if not self.ocolor:
            self.ocolor = bgcolor
        if not self.tcolor:
            self.tcolor = buttont
        if not self.fhcolor:
            self.fhcolor = buttonh

        self.menugoing = True
        ParseSwitch = False

        if len(self.optionlist) > 25:
            moptionlist = self.optionlist[0 + (25 * self.moffset):(self.moffset + 1) * 25]
        else:
            moptionlist = self.optionlist

        if self.bannertitle:
            ymod = 5
            xmod = 2
        else:
            ymod = 0
            xmod = 0

        self.oy += (ymod / 2)

        if self.doback:
            if len(self.optionlist) > 25:
                if self.moffset > 0:
                    addnum = 6
                else:
                    addnum = 5
            else:
                addnum = 1
            if self.bannertitle:
                addnum += 3
            if self.drawbox:
                if self.align == 'center':
                    DrawScroll(self.window,self.ox - (10 + (xmod / 2)),self.oy - 3 - ((ymod / 2) + (ymod % 2)),22,len(moptionlist) + addnum + 9 + ymod,self.boxtype)
                else:
                    DrawScroll(self.window,self.ox - 1 - (xmod / 2),self.oy - 3 - ((ymod / 2) + (ymod % 2)),16 + xmod,len(moptionlist) + addnum + 9 + ymod,self.boxtype)
        else:
            if self.drawbox:
                if self.align == 'center':
                    DrawScroll(self.window,self.ox - (10 + (xmod / 2)),self.oy - 3 - ((ymod / 2) + (ymod % 2)),22,len(moptionlist) + 3 + ymod,self.boxtype)
                else:
                    DrawScroll(self.window,self.ox - 1 - (xmod / 2),self.oy - 3 - ((ymod / 2) + (ymod % 2)),16 + xmod,len(moptionlist) + 3 + ymod,self.boxtype)

        if self.title and self.bannertitle:
            DrawBanner(self.window,self.ox,self.oy - 5,self.title)
        else:
            libtcod.console_set_default_foreground(self.window,self.tcolor)
            if self.title and self.talign == 'left':
                if self.align == 'left':
                    libtcod.console_print_ex(self.window, self.ox, self.oy - 2, libtcod.BKGND_NONE, libtcod.LEFT, self.title)
                else:
                    libtcod.console_print_ex(self.window, self.tx, self.ty, libtcod.BKGND_NONE, libtcod.LEFT, self.title)
            elif self.title and self.talign == 'center':
                if self.align == 'center':
                    libtcod.console_print_ex(self.window, self.ox, self.oy - 2, libtcod.BKGND_NONE, libtcod.CENTER, self.title)
                else:
                    libtcod.console_print_ex(self.window, self.tx, self.ty, libtcod.BKGND_NONE, libtcod.CENTER, self.title)

        self.moptionlist = moptionlist
        roptionlist = []
        for option in range(len(moptionlist)):
            if self.clipping:
                if len(moptionlist[option]) > 13 and option > 9:
                    roptionlist.append(moptionlist[option][0:12])
                elif len(moptionlist[option]) > 14 and option < 10:
                    roptionlist.append(moptionlist[option][0:13])
                else:
                    roptionlist.append(moptionlist[option])
            else:
                roptionlist.append(moptionlist[option])
            
        libtcod.console_set_default_foreground(self.window, self.tcolor)
        for option in range(len(moptionlist)):
            opcells = []
            if self.align == 'left':
                if self.numbers:
                    for num in range(self.ox + self.offx, self.ox + self.offx + len(roptionlist[option]) + (len(str(option + 1 + (self.moffset * 25))) + 2)):
                        opcells.append([num,self.oy + self.offy + 1 + (option * self.linespace)])
                else:
                    for num in range(self.ox + self.offx, self.ox + self.offx + len(roptionlist[option]) + (len(str(option + 1 + (self.moffset * 25))))):
                        opcells.append([num,self.oy + self.offy + 1 + (option * self.linespace)])
            elif self.align == 'center':
                if self.numbers:
                    for num in range(self.ox + self.offx - (len(roptionlist[option]) / 2) - len(str(option + 1 + (self.moffset * 25))) - (len(str(roptionlist[option])) % 2), self.ox + self.offx + (len(roptionlist[option]) / 2) + 2):
                        opcells.append([num,self.oy + self.offy + 1 + (option * self.linespace)])
                else:
                    for num in range(self.ox + self.offx - (len(roptionlist[option]) / 2) - len(str(option + 1 + (self.moffset * 25))) + 1, self.ox + self.offx + ((len(roptionlist[option]) + 1) / 2)):
                        opcells.append([num,self.oy + self.offy + 1 + (option * self.linespace)])
            opcelldict[option + 1] = opcells
            if self.align == 'left':
                if self.numbers:
                    libtcod.console_print_ex(self.window, self.ox, self.oy + (option * self.linespace), libtcod.BKGND_NONE, libtcod.LEFT, str(option + 1 + (self.moffset * 25)) + '. ' + roptionlist[option])
                else:
                    libtcod.console_print_ex(self.window, self.ox, self.oy + (option * self.linespace), libtcod.BKGND_NONE, libtcod.LEFT, roptionlist[option])
            elif self.align == 'center':
                if self.numbers:
                    libtcod.console_print_ex(self.window, self.ox, self.oy + (option * self.linespace), libtcod.BKGND_NONE, libtcod.CENTER, str(option + 1 + (self.moffset * 25)) + '. ' + roptionlist[option])
                else:
                    libtcod.console_print_ex(self.window, self.ox, self.oy + (option * self.linespace), libtcod.BKGND_NONE, libtcod.CENTER, roptionlist[option])

        if len(self.optionlist) > 25:
            if self.align == 'left':
                if self.moffset > 0:
                    prevopcells = []
                    for num in range(14):
                        prevopcells.append([self.ox + self.offx + num,self.oy + self.offy + 1 + ((opcelldict.keys()[-1] + 1) * self.linespace)])
                    opcelldict[opcelldict.keys()[-1] + 1] = prevopcells
                    libtcod.console_print_ex(self.window, self.ox, self.oy + len(moptionlist) + 1, libtcod.BKGND_NONE, libtcod.LEFT, '<< Previous <<')
                    moptionlist.append('<< Previous <<')
                if ((self.moffset + 1) * 25) < len(self.optionlist):
                    nextopcells = []
                    for num in range(10):
                        nextopcells.append([self.ox + self.offx + num,self.oy + self.offy + 1 + ((opcelldict.keys()[-1] + 1) * self.linespace)])
                    opcelldict[opcelldict.keys()[-1] + 1] = nextopcells
                    libtcod.console_print_ex(self.window, self.ox, self.oy + len(moptionlist) + 1, libtcod.BKGND_NONE, libtcod.LEFT, '>> Next >>')
                    moptionlist.append('>> Next >>')
            elif self.align == 'center':
                if self.moffset > 0:
                    prevopcells = []
                    for num in range(14):
                        prevopcells.append([self.ox + self.offx + num,self.oy + self.offy + 1 + ((opcelldict.keys()[-1] + 1) * self.linespace)])
                    opcelldict[opcelldict.keys()[-1] + 1] = prevopcells
                    libtcod.console_print_ex(self.window, self.ox, self.oy + len(moptionlist) + 1, libtcod.BKGND_NONE, libtcod.CENTER, '<< Previous <<')
                    moptionlist.append('<< Previous <<')
                if ((self.moffset + 1) * 25) < len(self.optionlist):
                    nextopcells = []
                    for num in range(10):
                        nextopcells.append([self.ox + self.offx + num,self.oy + self.offy + 1 + ((opcelldict.keys()[-1] + 1) * self.linespace)])
                    opcelldict[opcelldict.keys()[-1] + 1] = nextopcells
                    libtcod.console_print_ex(self.window, self.ox, self.oy + len(moptionlist) + 1, libtcod.BKGND_NONE, libtcod.CENTER, '>> Next >>')
                    moptionlist.append('>> Next >>')

        if self.doback == 1:
            if len(self.optionlist) > 25:
                addnum = 4
            else:
                addnum = 1
            if self.bannertitle:
                addnum += 3
            libtcod.console_print_ex(self.window, self.ox, self.oy + len(moptionlist) + addnum, libtcod.BKGND_NONE, libtcod.LEFT, \
                                       "To go back to\n" \
                                       "the prior menu,\n" \
                                       "press the\n" \
                                       "escape key\n" \
                                       "or the right\n" \
                                       "mouse button.")

        if cursorswitch:
            hoveropt = False
            for opt in opcelldict.items():
                if [handle_mouse('cx'),handle_mouse('cy') - 1] in opt[1]:
                    playery = opt[0]
                    hoveropt = True
        if playery > len(moptionlist):
            playery = 1
        if playery < 1:
            playery = len(moptionlist)
        for cell in opcelldict[playery]:
            if not self.tback:
                libtcod.console_set_char_background(self.window, cell[0] - self.offx, cell[1] - self.offy - 1, self.hcolor, libtcod.BKGND_SET)
            libtcod.console_set_char_foreground(self.window, cell[0] - self.offx, cell[1] - self.offy - 1, self.fhcolor)
        if oplayery != playery:
            try:
                for cell in opcelldict[oplayery]:
                    if not self.tback:
                        libtcod.console_set_char_background(self.window, cell[0] - self.offx, cell[1] - self.offy - 1, self.ocolor, libtcod.BKGND_SET)
            except KeyError:
                pass
        if (handle_mouse('lbutton_pressed') or key.vk == libtcod.KEY_ENTER) and moptionlist[playery - 1] == '>> Next >>':
            self.moffset += 1
            doScreenSetup()
            ParseSwitch = True
            playery,oplayery = 1,1
            for button in ButtonList:
                button.redrawbox = True
                button.drawn = False
                button.drawButton()
        if (handle_mouse('lbutton_pressed') or key.vk == libtcod.KEY_ENTER) and moptionlist[playery - 1] == '<< Previous <<':
            self.moffset -= 1
            doScreenSetup()
            ParseSwitch = True
            playery,oplayery = 1,1
            for button in ButtonList:
                button.redrawbox = True
                button.drawn = False
                button.drawButton()

        lock.release()
            
        oplayery = playery
        mplayery = playery + (self.moffset * 25)
        self.oy -= (ymod / 2)

        # Execute Command List

        if MenuSetting != 'WAIndivNation' and relswitch:
            relswitch = False
            
        if (key.vk == libtcod.KEY_ESCAPE or handle_mouse('rbutton_pressed')):
            for method in self.BMethodList:
                method()
            try:
                playery,oplayery = bplayery[MenuSetting][0],bplayery[MenuSetting][1]
                MenuList[0].moffset = bplayery[MenuSetting][2]
            except (KeyError, IndexError):
                playery,oplayery = 1,1
                
        elif ((key.vk == libtcod.KEY_ENTER and not key.lalt) or (hoveropt and handle_mouse('lbutton_pressed'))) and not ParseSwitch:
            bplayery[MenuSetting] = [playery,oplayery,self.moffset]
            playery = 1
            self.doCommandList()


        ParseSwitch = False
        self.menugoing = False

        # Self-Deletion


        if self not in MenuList:
            del self

    def doCommandList(self):
        for method in self.MethodList:
            if method[0] == self.moptionlist[mplayery - 1 - (25 * self.moffset)] or method[0] == True:
                try:
                    method[1](method[2],method[3])
                except:
                    try:
                        method[1](method[2])
                    except:
                        method[1]()
                    
        if self.dialogue:
            if not self.dialogue.killonclick:
                self.dialogue.cancel()

class RelMap(threading.Thread):

    def __init__(self, window, xloc, yloc, xoff, yoff, xdim, ydim, terrcivdict, relimage, civreldict):
        global ButtonList
        threading.Thread.__init__(self)
        self.window = window
        self.xloc = xloc
        self.yloc = yloc
        self.xoff = xoff
        self.yoff = yoff
        self.xdim = xdim
        self.ydim = ydim
        self.terrcivdict = terrcivdict
        self.relimage = relimage
        self.civreldict = civreldict
        ButtonList = ButtonList + [self]

    def drawButton(self):
        global cursorswitch
        libtcod.console_set_default_background(self.window, libtcod.black)
        libtcod.console_clear(self.window)
        DrawScroll(self.window, self.xloc - 1, self.yloc - 1, self.xdim + 1, self.ydim + 1)
        libtcod.image_blit_2x(self.relimage, self.window, self.xloc, self.yloc)
        if cursorswitch:
            for item in self.terrcivdict.items():
                if [handle_mouse('cx'),handle_mouse('cy')] == [int(item[0].partition(',')[0]) + self.xloc + self.xoff,int(item[0].partition(',')[2]) + self.yloc + self.yoff]:
                    civposlist = filter(lambda x: x[1] == item[1],self.terrcivdict.items())
                    for nitem in civposlist:
                        nitemx = int(nitem[0].partition(',')[0])
                        nitemy = int(nitem[0].partition(',')[2])
                        libtcod.console_set_char_background(wawindow, nitemx + self.xloc - 1, nitemy + self.yloc - 1,wcivdict[wcivdict[item[1]] + '-civcol2'],libtcod.BKGND_SET)
                        libtcod.console_set_char_foreground(wawindow, nitemx + self.xloc - 1, nitemy + self.yloc - 1,wcivdict[wcivdict[item[1]] + '-civcol2'])
                    ncivposlist = map(lambda p: [int(p[0].partition(',')[0]),int(p[0].partition(',')[2])],civposlist)
                    ncivposlist.sort(ListCmp)
                    xmax = ncivposlist[0][0]
                    xmin = ncivposlist[-1][0]
                    ncivposlist.sort(ListCmp2)
                    ymax = ncivposlist[0][1]
                    ymin = ncivposlist[-1][1]
                    libtcod.console_set_default_foreground(self.window, wcivdict[wcivdict[item[1]] + '-civcol'])
                    libtcod.console_set_default_background(self.window, libtcod.black)
                    libtcod.console_print_ex(self.window,self.xloc + ((xmax + xmin) / 2),self.yloc + ((ymax + ymin) / 2),libtcod.BKGND_SET, libtcod.CENTER, wcivdict[item[1]].upper())
                    libtcod.console_set_default_foreground(self.window, self.civreldict[item[1]][1])
                    libtcod.console_print_ex(self.window,self.xloc + ((xmax + xmin) / 2),self.yloc + ((ymax + ymin) / 2) + 1,libtcod.BKGND_SET, libtcod.CENTER,'(' + self.civreldict[item[1]][0].upper() + ')') 

        if self not in ButtonList:
            del self

class InvWindow(threading.Thread):
    def __init__(self,window):
        threading.Thread.__init__(self)
        self.init = True
        self.killswitch = False
        self.window = window
        self.otdict = {}
        self.movewindow = False
        self.items = {}

    def run(self):
        global PX, PY, MenuSetting, Clouds, pathlock, MenuList, moveclouds, hoveropt, MoveLock, XConsoles, toplayer
        if not GameWorld.windowlock:
            GameWorld.windowlock = True
            self.mcloudstate = moveclouds
            moveclouds = False
            MoveLock = True
            pathlock = True
            self.conw = 40
            self.conh = 21
            self.CX = PX + (VIEW_WIDTH / 2) - 20
            self.CY = PY + (VIEW_HEIGHT / 2) - 10
            self.invconsole = libtcod.console_new(self.conw,self.conh)
            self.rx = self.CX - PX + (SCREEN_WIDTH - VIEW_WIDTH) - 3
            self.ry = self.CY - PY + 1
            self.InvBar = ScrollBar(self.invconsole, self.conw - 2, 1, self.conh - 2, self.CX - PX + self.conw - 5 + (SCREEN_WIDTH - VIEW_WIDTH), self.CY - PY + 2, \
                                    hcolor = scrollcolor2, arrowcolor = bordercolh2, bgcolor = scrollbcolh, ID = 'InvBar', hookmethod = self.reDraw, \
                                    scrolldims = [self.rx,self.rx + self.conw,self.ry,self.ry + self.conh])
            self.InvBar.start()
            self.InvBar.max = 2
            self.conlist = [self.invconsole,0,0,self.conw,self.conh,self.rx,self.ry,1.0,1.0]
            self.bconlist = [None]
            XConsoles += [self.conlist]

            self.reDraw(redrawbox = True)
            self.ox,self.oy = 0,0
            self.blurbcon = libtcod.console_new(25,20)
            libtcod.console_set_default_background(self.blurbcon, bgcolor2)

            self.moveitem = False

            while not self.killswitch:
                if not GameWorld.topwindow:
                    ccx,ccy = handle_mouse('cx'),handle_mouse('cy')
                    if handle_mouse('lbutton') and self.moveitem and not self.movewindow:
                        if self.bconlist in XConsoles:
                            XConsoles.remove(self.bconlist)
                        if self.op != [handle_mouse('cx'),handle_mouse('cy')]:
                            self.op = [handle_mouse('cx'),handle_mouse('cy')]
                            itemname = self.moveitem[0][0]
                            itemstruct = GameWorld.invdict[self.moveitem[0][1]][itemname]
                            char = [int(itemstruct['CHAR'][0]),int(itemstruct['CHAR'][1]),255]
                            col = libtcod.white
                            libtcod.console_set_default_foreground(toplayer,col)
                            libtcod.console_clear(toplayer)
                            libtcod.console_print_ex(toplayer, handle_mouse('cx') - 20, handle_mouse('cy') - 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                    elif handle_mouse('lbutton_pressed') and self.moveitem:
                        if key.shift and not self.moveitem[0][3] == 1:
                            if type(self.isquares.get('%s,%s' % (ccx,ccy))) == int:
                                if GameWorld.inventory.get(self.isquares['%s,%s' % (ccx,ccy)]):
                                    GameWorld.addMesg('You already have an item in that slot.', col = libtcod.yellow)
                                    GameWorld.inventory[self.moveitem[1]] = self.moveitem[0]
                                else:
                                    self.splitslot = self.isquares['%s,%s' % (ccx,ccy)]
                                    SplitItemDialogue = NDialogue(self.moveitem[0][3],self.Split,item = self.moveitem)
                                    SplitItemDialogue.start()
                                    time.sleep(1.0)
                                    self.moveitem = False
                            elif ccx < self.rx or ccx > self.rx + self.conw or ccy < self.ry or ccy > self.ry + self.conh:
                                DropItemDialogue = NDialogue(self.moveitem[0][3],self.Drop,item = self.moveitem)
                                DropItemDialogue.start()
                                self.moveitem = False
                        elif type(self.isquares.get('%s,%s' % (ccx,ccy))) == int:
                            if GameWorld.inventory.get(self.isquares['%s,%s' % (ccx,ccy)]):
                                if GameWorld.inventory[self.isquares['%s,%s' % (ccx,ccy)]][0] == self.moveitem[0][0] and \
                                   GameWorld.inventory[self.isquares['%s,%s' % (ccx,ccy)]][1] == self.moveitem[0][1]:
                                    GameWorld.inventory[self.isquares['%s,%s' % (ccx,ccy)]][3] += self.moveitem[0][3]
                                else:
                                    GameWorld.inventory[self.moveitem[1]] = GameWorld.inventory[self.isquares['%s,%s' % (ccx,ccy)]]
                                    GameWorld.inventory[self.isquares['%s,%s' % (ccx,ccy)]] = self.moveitem[0]
                            else:
                                GameWorld.inventory[self.isquares['%s,%s' % (ccx,ccy)]] = self.moveitem[0]
                            self.moveitem = False
                            self.reDraw()
                        elif ccx > self.rx and ccx < self.rx + self.conw and ccy > self.ry and ccy < self.ry + self.conh:
                            GameWorld.inventory[self.moveitem[1]] = self.moveitem[0]
                        else:
                            if GameWorld.rswitch:
                                if self.moveitem[0][3] > 1:
                                    dtitle = 'Drop %s %s?' % (p.number_to_words(self.moveitem[0][3]),p.plural_noun(self.moveitem[0][0]))
                                else:
                                    dtitle = 'Drop %s?' % self.moveitem[0][0]
                                DropWindow = Dialogue([('Yes',self.Drop,self.moveitem),('No',self.noDrop,self.moveitem)],title = dtitle)
                                DropWindow.start()
                                time.sleep(1.0)
                            else:
                                GameWorld.addMesg('You can\'t drop items on the world map.', col = libtcod.yellow)
                                self.noDrop(self.moveitem)
                    elif self.items.get('%s,%s' % (ccx - self.rx,ccy - self.ry)) and not self.movewindow:
                        if self.bconlist not in XConsoles:
                            libtcod.console_clear(self.blurbcon)
                            item = self.items['%s,%s' % (ccx - self.rx,ccy - self.ry)][0]
                            itype = item[1]
                            blurb = GameWorld.invdict[itype][item[0]]['BLURB']
                            if '%s' in blurb[0]:
                                wblurb = textWrap(blurb[0] % item[2],23)
                            else:
                                wblurb = textWrap(blurb[0],23)
                            itemname = item[0].capitalize()
                            wblurb[0] = itemname + ' (x%s)' % item[3] + '\n\n' + wblurb[0]
                            wblurb[1] += 2
                            DrawScroll(self.blurbcon, 0, 0, 24, wblurb[1] + 3,1)
                            libtcod.console_set_default_foreground(self.blurbcon, libtcod.black)
                            libtcod.console_print_ex(self.blurbcon, 12, 2, libtcod.BKGND_NONE, libtcod.CENTER, wblurb[0])
                            ccx = max(min(ccx,SCREEN_WIDTH - 3 - 12),0)
                            posy = ccy - 1 - (wblurb[1] + 4)
                            if posy < 2:
                                posy = ccy + 2
                            self.bconlist = [self.blurbcon,0,0,25,wblurb[1] + 4,ccx - 12,posy,1.0,1.0]
                            XConsoles += [self.bconlist]
                        if handle_mouse('lbutton'):
                            self.op = [handle_mouse('cx') + 1,handle_mouse('cy')]
                            self.moveitem = self.items['%s,%s' % (ccx - self.rx,ccy - self.ry)]
                            GameWorld.inventory[self.moveitem[1]] = None
                            libtcod.console_print_ex(self.invconsole,ccx - self.rx,ccy - self.ry,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar([0,0,189])))
                            for x in range(3):
                                libtcod.console_print_ex(self.invconsole,ccx - self.rx - 1 + x,ccy - self.ry + 1,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar([0,0,189])))
                    elif (handle_mouse('cx') in range(self.rx - 4,self.rx + self.conw + 5)) and handle_mouse('cy') in range(self.ry - 4,self.ry + 2):
                        if handle_mouse('lbutton') and handle_mouse('cx') in range(self.rx,self.rx + self.conw + 1) and handle_mouse('cy') == self.ry and \
                           (self.ox,self.oy) != (handle_mouse('cx'),handle_mouse('cy')) and not self.movewindow:
                            self.movewindow = True
                            self.ox,self.oy = handle_mouse('cx'),handle_mouse('cy')
                        elif handle_mouse('lbutton_pressed'):
                            self.movewindow = False
                        elif self.movewindow and (handle_mouse('cx') != self.ox or handle_mouse('cy') != self.oy):
                            nrx,nry = self.rx - (self.ox - handle_mouse('cx')),self.ry - (self.oy - handle_mouse('cy'))
                            if nrx > SCREEN_WIDTH - VIEW_WIDTH - 3 and nrx + self.conw < SCREEN_WIDTH - 1 and nry > 1 and nry + self.conh < VIEW_HEIGHT + 3:
                                self.CX,self.CY = self.CX - (self.ox - handle_mouse('cx')),self.CY - (self.oy - handle_mouse('cy'))
                                self.InvBar.rx,self.InvBar.ry = self.InvBar.rx - (self.ox - handle_mouse('cx')),self.InvBar.ry - (self.oy - handle_mouse('cy'))
                                self.rx,self.ry = nrx,nry
                                self.InvBar.scrolldims = [self.rx,self.rx + self.conw,self.ry,self.ry + self.conh]
                                XConsoles.remove(self.conlist)
                                self.conlist[5],self.conlist[6] = self.rx,self.ry
                                XConsoles += [self.conlist]
                            self.movewindow = False
                    else:
                        libtcod.console_clear(toplayer)
                        if self.bconlist in XConsoles:
                            XConsoles.remove(self.bconlist)
                        libtcod.console_set_char_background(self.invconsole, self.conw - 2, 0, scrollbcol, libtcod.BKGND_SET)
                        if self.moveitem:
                            self.moveitem = False
                            self.reDraw()

    def reDraw(self,redrawbox = False):
        global Clouds, NoGraphics, NoMenus, NoButtons
        NoGraphics,NoMenus,NoButtons = True,True,True
        lock.acquire()
        libtcod.console_set_default_background(self.invconsole, bgcolor2)
        libtcod.console_set_default_foreground(self.invconsole, hcolor2)
        if redrawbox:
            DrawScroll(self.invconsole, 0, 0, self.conw - 1, self.conh - 1, 1)
        libtcod.console_set_default_foreground(self.invconsole, bordercol2)
        seppos = 18
        DrawBanner(self.invconsole, 9, 1, 'Crafting')
        try:
            for y in range(1,self.conh - 1):
                char = self.sepchars[y]
                libtcod.console_print_ex(self.invconsole, seppos, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
        except AttributeError:
            self.sepchars = {}
            for y in range(1,self.conh - 1):
                char = random.choice(vectorchars)
                char[2] = 189
                self.sepchars[y] = char
                libtcod.console_print_ex(self.invconsole, seppos, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))        
        libtcod.console_set_default_foreground(self.invconsole, bordercol2)
        for x in range(1,(self.conw - 2) - seppos):
            for y in range(1,self.conh - 1):
                if x % 4 == 0 and y % 4 == 0:
                    char = fwnborder
                elif x % 4 == 0 and y % 4 != 0:
                    char = vnborder
                elif x % 4 != 0 and y % 4 == 0:
                    char = hnborder
                else:
                    char = [0,0,255]
                char[2] = 189
                libtcod.console_print_ex(self.invconsole, x + seppos, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
        self.items = {}
        self.isquares = {}
        for invnum in range(0 + (self.InvBar.inc * 5),26 + (self.InvBar.inc * 5)):
            posx = seppos + 2 + ((invnum % 5) * 4)
            posy = 2 + (((invnum / 5) - self.InvBar.inc) * 4)
            for num in range(-1,2):
                for num2 in range(-1,2):
                    x = self.rx + posx + num
                    y = self.ry + posy + num2
                    self.isquares['%s,%s' % (x,y)] = invnum
            if GameWorld.inventory.get(invnum):
                item = GameWorld.inventory.get(invnum)
                itemname = item[0]
                numitem = item[3]
                if numitem > 999:
                    numstr = str(numitem)[0] + 'K'
                else:
                    numstr = str(numitem)
                if numitem > 1:
                    libtcod.console_print_ex(self.invconsole, seppos + 2 + ((invnum % 5) * 4), 3 + (((invnum / 5) - self.InvBar.inc) * 4), libtcod.BKGND_NONE, libtcod.CENTER, numstr)
                for tile in range(3):
                    libtcod.console_set_char_foreground(self.invconsole, seppos + 1 + ((invnum % 5) * 4) + tile, 3 + (((invnum / 5) - self.InvBar.inc) * 4), libtcod.black)
                col = libtcod.white
                itemstruct = GameWorld.invdict[item[1]][itemname]
                char = [int(itemstruct['CHAR'][0]),int(itemstruct['CHAR'][1]),189]
                self.items['%s,%s' % (posx,posy)] = [item,invnum,posx,posy]
                libtcod.console_print_ex(self.invconsole, posx, posy, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                libtcod.console_set_char_foreground(self.invconsole, posx, posy, col)
        self.InvBar.reDraw()
        NoGraphics,NoMenus,NoButtons = False,False,False
        lock.release()

    def Drop(self,item = None,number = None):
        global PCX, PCY, Clouds
        if not item:
            item = self.moveitem
        dodrop = False
        if type(number) == int:
            if number == 0:
                GameWorld.inventory[item[1]] = item[0]
            elif item[0][3] == number:
                dodrop = True
            else:
                GameWorld.inventory[item[1]] = copy.copy(item[0])
                GameWorld.inventory[item[1]][3] -= number
                item[0][3] = number
                dodrop = True
        else:
            dodrop = True
        if dodrop:
            if GameWorld.itemdict[GameWorld.curz]['%s,%s' % (PCX,PCY)].get('%s-%s' % (item[0][0],item[0][2])):
                GameWorld.itemdict[GameWorld.curz]['%s,%s' % (PCX,PCY)]['%s-%s' % (item[0][0],item[0][2])][0][3] += item[0][3]
            else:
                GameWorld.itemdict[GameWorld.curz]['%s,%s' % (PCX,PCY)]['%s-%s' % (item[0][0],item[0][2])] = [item[0],time.time()]
            if item[0][3] > 1:
                num = p.number_to_words(item[0][3])
                GameWorld.addMesg('You drop %s %s.' % (num,p.plural_noun(item[0][0])))
            else:
                GameWorld.addMesg('You drop the %s.' % item[0][0])
            itemname = item[0][0]
            itemstruct = GameWorld.invdict[item[0][1]][itemname]
            char = [int(itemstruct['CHAR'][0]),int(itemstruct['CHAR'][1]),255]
            GameWorld.ochar = [libtcod.console_get_char(self.window,PCX,PCY),libtcod.console_get_char_foreground(self.window,PCX,PCY)]
            self.moveitem = False
            self.reDraw()

    def noDrop(self,item = None):
        if not item:
            item = self.moveitem
        GameWorld.inventory[item[1]] = item[0]
        self.moveitem = False
        self.reDraw()

    def Split(self,item,splitnum):
        if splitnum != 0 and item[1] != self.splitslot:
            splititem = copy.copy(item[0])
            splititem[3] = splitnum
            osplititem = copy.copy(item[0])
            osplititem[3] -= splitnum
            if item[0][3] != splitnum:
                GameWorld.inventory[item[1]] = osplititem
            GameWorld.inventory[self.splitslot] = splititem
        else:
            GameWorld.inventory[item[1]] = item[0]
        self.reDraw()

    def close(self):
        global moveclouds, MoveLock, pathlock, XConsoles
        self.killswitch = True
        try:
            self.InvBar.killswitch = True
        except AttributeError:
            pass
        time.sleep(0.1)
        XConsoles.remove(self.conlist)
        try:
            XConsoles.remove(self.bconlist)
        except:
            pass
        moveclouds = self.mcloudstate
        GameWorld.windowlock = False
        MoveLock = False
        pathlock = False
        libtcod.console_delete(self.invconsole)
        libtcod.console_delete(self.blurbcon)
        del self
                    
class Dialogue(threading.Thread):
    def __init__(self,choicelist,title = None,resume = False, \
                 offx = (SCREEN_WIDTH - VIEW_WIDTH - 3) + (VIEW_WIDTH / 2), \
                 offy = (VIEW_HEIGHT / 2), killonclick = False, cornerstyle = 1, \
                 align = 'center', talign = 'center'):
        threading.Thread.__init__(self)
        self.killswitch = False
        self.saved = False
        self.title = title
        self.choicelist = choicelist
        self.resume = resume
        self.offx = offx
        self.offy = offy
        self.killonclick = killonclick
        self.cornerstyle = cornerstyle
        self.align = align
        self.talign = talign

    def run(self):
        global PX, PY, Clouds, pathlock, TopWindow, moveclouds, MoveLock, MouseLock, lock
        lock.acquire()
        pathlock = True
        self.mcloudstate = moveclouds
        moveclouds = False
        MoveLock = True
        GameWorld.windowlock = True
        GameWorld.topwindow = True
        longest = 0
        self.choicenames = []
        for choices in self.choicelist:
            dchoice = choices[0]
            self.choicenames.append(dchoice)
            if len(dchoice) > longest:
                longest = len(dchoice)
        if self.title:
            if len(self.title) > longest:
                longest = len(self.title)
        numchoices = len(self.choicelist)
        self.conw = longest + 4
        if self.title:
            self.conh = numchoices + 6
        else:
            self.conh = numchoices + 4
        self.dialogue = libtcod.console_new(self.conw,self.conh)
        libtcod.console_set_default_background(self.dialogue, libtcod.darkest_azure)
        libtcod.console_set_default_foreground(self.dialogue, libtcod.white)
        if self.align == 'center':
            MPX = self.conw / 2
            MPY = (self.conh / 2) - (len(self.choicelist) / 2)
        elif self.align == 'left':
            MPX = 2
            MPY = (self.conh / 2) - (len(self.choicelist) / 2)
        if self.title:
            MPY += 1
        self.rx = max(min(self.offx - MPX,SCREEN_WIDTH - 2 - self.conw),(SCREEN_WIDTH - VIEW_WIDTH) - 2)
        self.ry = max(min(2 + self.offy - MPY,2 + VIEW_HEIGHT - self.conh),2)
        for x in range(self.conw):
            for y in range(self.conh):
                bcol = libtcod.console_get_char_background(0, x + self.rx, y + self.ry)
                libtcod.console_set_char_background(self.dialogue,x,y,bcol,libtcod.BKGND_SET)
        DrawScroll(self.dialogue, 0, 0, self.conw - 1, self.conh - 1)
        MenuSetting = None
        OMPX = self.rx
        OMPY = self.ry - 2
        self.DialogueMenu = Menu(self.dialogue, MPX, MPY, self.choicenames, align = self.align, talign = self.talign, title = self.title, \
                                 doback = 0, offx = OMPX, offy = OMPY, tback = True, MethodList = self.choicelist, \
                                 BMethodList = [self.cancel], numbers = False, dialogue = self)
        self.DialogueMenu.start()
        self.conlist = [self.dialogue,0,0,self.conw,self.conh,self.rx,self.ry,1.0,1.0]
        TopWindow += [self.conlist]
        lock.release()
        if self.killonclick:
            while not self.killswitch:
                if handle_mouse('lbutton') or handle_mouse('rbutton'):
                    self.cancel()
                
    def cancel(self):
        global moveclouds, MouseLock, MoveLock, PX, PY, TopWindow, MenuList, hoveropt
        MenuList = []
        self.killswitch = True
        GameWorld.topwindow = False
        if self.resume:
            MoveLock = False
            pathlock = False
            moveclouds = self.mcloudstate
            GameWorld.windowlock = False
        TopWindow.remove(self.conlist)
        libtcod.console_delete(self.dialogue)
        if hoveropt and handle_mouse('lbutton'):
            self.DialogueMenu.doCommandList()
        del self

class NDialogue(threading.Thread):
    def __init__(self,maxnum,dofunc,resume = False,item = None,cornerstyle = 1,title = None):
        threading.Thread.__init__(self)
        self.title = title
        self.maxnum = maxnum
        self.resume = resume
        self.killswitch = False
        self.doinc = False
        self.dodec = False
        self.item = item
        self.dofunc = dofunc
        self.cornerstyle = cornerstyle

    def run(self):
        global PX, PY, pathlock, TopWindow, moveclouds, MoveLock, key, NoGraphics, NoMenus, NoButtons, lock
        lock.acquire()
        time.sleep(0.1)
        NoGraphics,NoButtons = True,True
        pathlock = True
        self.mcloudstate = moveclouds
        moveclouds = False
        MoveLock = True
        GameWorld.windowlock = True
        GameWorld.topwindow = True
        strnum = len(str(self.maxnum))
        wadjust = 0
        if strnum > 3:
            wadjust = strnum - 3
        self.conw = 7 + wadjust
        self.conh = 8
        self.ndialogue = libtcod.console_new(self.conw,self.conh)
        libtcod.console_set_default_background(self.ndialogue, libtcod.darkest_azure)
        libtcod.console_set_default_foreground(self.ndialogue, libtcod.black)
        DrawScroll(self.ndialogue, 0, 0, self.conw - 1, self.conh - 1,1)
        MenuSetting = None
        MPX = self.conw / 2
        MPY = self.conh / 2
        OMPX = (SCREEN_WIDTH - VIEW_WIDTH) + (VIEW_WIDTH / 2) - MPX - 3
        OMPY = (VIEW_HEIGHT / 2) - MPY
        self.rx = (SCREEN_WIDTH - VIEW_WIDTH - 3) + (VIEW_WIDTH / 2) - MPX
        self.ry = 2 + (VIEW_HEIGHT / 2) - MPY
        self.conlist = [self.ndialogue,0,0,self.conw,self.conh,self.rx,self.ry,1.0,1.0]
        TopWindow += [self.conlist]
        nsmod = strnum - 1
        for num in range(wadjust,3 + wadjust):
            libtcod.console_print_ex(self.ndialogue, 2 + num, 2, libtcod.BKGND_NONE, libtcod.CENTER, chr(DoChar(uschar)))
            libtcod.console_print_ex(self.ndialogue, 2 + num, 4, libtcod.BKGND_NONE, libtcod.CENTER, chr(DoChar(dschar)))
        curnum = self.maxnum
        libtcod.console_print_ex(self.ndialogue, 3 + wadjust, 6, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(unchecked)))
        lock.release()
        
        while not self.killswitch:
            lock.acquire()
            curstr = str(curnum)
            strnum = len(curstr)
            libtcod.console_set_default_foreground(self.ndialogue, libtcod.black)
            zerostr = (3 - strnum) * '0'
            libtcod.console_print_ex(self.ndialogue, 4 + wadjust, 3, libtcod.BKGND_NONE, libtcod.RIGHT, zerostr + curstr)
            for num in range(3):
                # Top Row
                if [handle_mouse('cx'),handle_mouse('cy')] == [self.rx + num + 2 + wadjust,self.ry + 2] and handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.ndialogue, 2 + num + wadjust, 2, libtcod.desaturated_yellow)
                    self.doinc = 2 - num
                elif [handle_mouse('cx'),handle_mouse('cy')] == [self.rx + num + 2 + wadjust,self.ry + 2]:
                    libtcod.console_set_char_foreground(self.ndialogue, 2 + num + wadjust, 2, libtcod.yellow)
                else:
                    libtcod.console_set_char_foreground(self.ndialogue, 2 + num + wadjust, 2, libtcod.desaturated_yellow)
                # Bottom Row
                if [handle_mouse('cx'),handle_mouse('cy')] == [self.rx + num + 2 + wadjust,self.ry + 4] and handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.ndialogue, 2 + num + wadjust, 4, libtcod.desaturated_yellow)
                    self.dodec = 2 - num
                elif [handle_mouse('cx'),handle_mouse('cy')] == [self.rx + num + 2 + wadjust,self.ry + 4]:
                    libtcod.console_set_char_foreground(self.ndialogue, 2 + num + wadjust, 4, libtcod.yellow)
                else:
                    libtcod.console_set_char_foreground(self.ndialogue, 2 + num + wadjust, 4, libtcod.desaturated_yellow)
            if (type(self.doinc) == int) and handle_mouse('lbutton_pressed'):
                mult = int(pow(10,self.doinc))
                curnum = min(self.maxnum,curnum + mult)
                self.doinc = False
            elif (type(self.dodec) == int) and handle_mouse('lbutton_pressed'):
                mult = int(pow(10,abs(self.dodec)))
                curnum = max(0,curnum - mult)
                self.dodec = False
            if [handle_mouse('cx'),handle_mouse('cy')] == [self.rx + 3 + wadjust,self.ry + 6] or key.vk == libtcod.KEY_ENTER:
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.ndialogue, 3 + wadjust, 6, libtcod.yellow)
                elif key.vk == libtcod.KEY_ENTER:
                    libtcod.console_print_ex(self.ndialogue, 3 + wadjust, 6, libtcod.BKGND_NONE, libtcod.RIGHT, chr(DoChar(checked)))
                    libtcod.console_set_char_foreground(self.ndialogue, 3 + wadjust, 6, libtcod.yellow)
                    time.sleep(0.1)
                    self.killswitch = True
                elif handle_mouse('lbutton_pressed'):
                    self.killswitch = True
                else:
                    libtcod.console_set_default_foreground(self.ndialogue, libtcod.desaturated_yellow)
                    libtcod.console_print_ex(self.ndialogue, 3 + wadjust, 6, libtcod.BKGND_NONE, libtcod.RIGHT, chr(DoChar(checked)))
            else:
                libtcod.console_set_default_foreground(self.ndialogue, libtcod.desaturated_yellow)
                libtcod.console_print_ex(self.ndialogue, 3 + wadjust, 6, libtcod.BKGND_NONE, libtcod.RIGHT, chr(DoChar(unchecked)))
            lock.release()
        NoGraphics,NoButtons = True,True
        self.dofunc(self.item,curnum)
        self.cancel()

    def cancel(self):
        global moveclouds, MouseLock, MoveLock, PX, PY, TopWindow
        GameWorld.topwindow = False
        if self.resume:
            MoveLock = False
            pathlock = False
            moveclouds = self.mcloudstate
            GameWorld.windowlock = False
        TopWindow.remove(self.conlist)
        libtcod.console_delete(self.ndialogue)
        del self

class OptWindow(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.killswitch = False

    def run(self):
        global pathlock, moveclouds, MoveLock, TopWindow, XConsoles
        pathlock = True
        self.mcloudstate = moveclouds
        moveclouds = False
        MoveLock = True
        GameWorld.windowlock = True

        self.oconsole = libtcod.console_new(19,19)
        libtcod.console_set_default_background(self.oconsole, bgcolor2)
        libtcod.console_clear(self.oconsole)
        DrawScroll(self.oconsole, 0, 0, 18, 18, 1)

        MPX = 9
        MPY = 9
        OMPX = (SCREEN_WIDTH - VIEW_WIDTH) + (VIEW_WIDTH / 2) - MPX - 3
        OMPY = (VIEW_HEIGHT / 2) - MPY
        self.rx = (SCREEN_WIDTH - VIEW_WIDTH - 2) + (VIEW_WIDTH / 2) - MPX
        self.ry = 2 + (VIEW_HEIGHT / 2) - MPY

        DrawScroll(self.oconsole, 5, 2, 8, 2)
        libtcod.console_set_default_foreground(self.oconsole, libtcod.black)
        libtcod.console_print_ex(self.oconsole, 9, 3, libtcod.BKGND_NONE, libtcod.CENTER, 'Audio')

        DrawScroll(self.oconsole, 5, 6, 8, 2)
        libtcod.console_set_default_foreground(self.oconsole, libtcod.black)
        libtcod.console_print_ex(self.oconsole, 9, 7, libtcod.BKGND_NONE, libtcod.CENTER, 'Video')

        DrawScroll(self.oconsole, 3, 10, 12, 2)
        libtcod.console_set_default_foreground(self.oconsole, libtcod.black)
        libtcod.console_print_ex(self.oconsole, 9, 11, libtcod.BKGND_NONE, libtcod.CENTER, 'Save Game')

        DrawScroll(self.oconsole, 3, 14, 12, 2)
        libtcod.console_set_default_foreground(self.oconsole, libtcod.black)
        libtcod.console_print_ex(self.oconsole, 9, 15, libtcod.BKGND_NONE, libtcod.CENTER, 'Load Game')

        self.conlist = [self.oconsole,0,0,19,19,self.rx,self.ry,1.0,1.0]
        XConsoles += [self.conlist]

        self.savegame,self.loadgame = False,False
        self.doaudio,self.dovideo = False,False
        self.passloop = False

        while not self.killswitch:
            if self.passloop:
                time.sleep(0.1)
                continue
            
            # Adjust Audio

            if handle_mouse('cx') in range(self.rx + 6,self.rx + 13) and handle_mouse('cy') == self.ry + 3:
                if handle_mouse('lbutton'):
                    for tile in range(7,12):
                        libtcod.console_set_char_background(self.oconsole, tile, 3, hcolor, libtcod.BKGND_SET)
                    self.doaudio = True
                elif handle_mouse('lbutton_pressed') and self.doaudio:
                    time.sleep(0.1)
                    self.doaudio = False
                    self.passloop = True
                    othread = threading.Thread(target=self.doAudio)
                    othread.start()
                else:
                    for tile in range(7,12):
                        libtcod.console_set_char_background(self.oconsole, tile, 3, hcolor2, libtcod.BKGND_SET)
            else:
                for tile in range(6,13):
                    libtcod.console_set_char_background(self.oconsole, tile, 3, scrollcolor, libtcod.BKGND_SET)

            # Adjust Video

            if handle_mouse('cx') in range(self.rx + 6,self.rx + 13) and handle_mouse('cy') == self.ry + 7:
                if handle_mouse('lbutton'):
                    for tile in range(7,12):
                        libtcod.console_set_char_background(self.oconsole, tile, 7, hcolor, libtcod.BKGND_SET)
                    self.dovideo = True
                elif handle_mouse('lbutton_pressed') and self.dovideo:
                    time.sleep(0.1)
                    self.dovideo = False
                    self.passloop = True
                    othread = threading.Thread(target=self.doVideo)
                    othread.start()
                else:
                    for tile in range(7,12):
                        libtcod.console_set_char_background(self.oconsole, tile, 7, hcolor2, libtcod.BKGND_SET)
            else:
                for tile in range(6,13):
                    libtcod.console_set_char_background(self.oconsole, tile, 7, scrollcolor, libtcod.BKGND_SET)
            
            # Save Game

            if handle_mouse('cx') in range(self.rx + 4,self.rx + 15) and handle_mouse('cy') == self.ry + 11:
                if handle_mouse('lbutton'):
                    for tile in range(5,14):
                        libtcod.console_set_char_background(self.oconsole, tile, 11, hcolor, libtcod.BKGND_SET)
                    self.savegame = True
                elif handle_mouse('lbutton_pressed') and self.savegame:
                    time.sleep(0.1)
                    self.savegame = False
                    self.passloop = True
                    othread = threading.Thread(target=self.saveGame)
                    othread.start()
                else:
                    for tile in range(5,14):
                        libtcod.console_set_char_background(self.oconsole, tile, 11, hcolor2, libtcod.BKGND_SET)
            else:
                for tile in range(4,15):
                    libtcod.console_set_char_background(self.oconsole, tile, 11, scrollcolor, libtcod.BKGND_SET)

            # Load Game
                    
            if handle_mouse('cx') in range(self.rx + 4,self.rx + 15) and handle_mouse('cy') == self.ry + 15:
                if handle_mouse('lbutton'):
                    for tile in range(5,14):
                        libtcod.console_set_char_background(self.oconsole, tile, 15, hcolor, libtcod.BKGND_SET)
                    self.loadgame = True
                elif handle_mouse('lbutton_pressed') and self.loadgame:
                    time.sleep(0.1)
                    self.loadgame = False
                    self.passloop = True
                    othread = threading.Thread(target=self.loadGame)
                    othread.start()
                else:
                    for tile in range(5,14):
                        libtcod.console_set_char_background(self.oconsole, tile, 15, hcolor2, libtcod.BKGND_SET)
            else:
                for tile in range(4,15):
                    libtcod.console_set_char_background(self.oconsole, tile, 15, scrollcolor, libtcod.BKGND_SET)

    def doAudio(self):
        global XConsoles, WeatherLayer, TopWindow, toplayer, freeze, Clouds, GameWorld, MVolume, SVolume, \
               Nographics, NoButtons, NoMenus
    
        time.sleep(0.1)
        self.audiowindow = libtcod.console_new(24,30)
        libtcod.console_set_default_background(self.audiowindow, libtcod.darkest_azure)
        libtcod.console_clear(self.audiowindow)
        DrawBox(self.audiowindow, 0, 0, 23, 29, 1, libtcod.desaturated_yellow, libtcod.desaturated_flame)
        srx = (SCREEN_WIDTH - VIEW_WIDTH - 2) + (VIEW_WIDTH / 2) - 12
        sry = 1 + (VIEW_HEIGHT / 2) - 15

        libtcod.console_set_default_foreground(self.audiowindow, hcolor2)
        libtcod.console_set_default_background(self.audiowindow, scrollcolor2)
        char = [23,3,255]
        libtcod.console_print_ex(self.audiowindow, 22, 0, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))

        self.MVBar = WScrollBar(self.audiowindow, 2, 7, 20, srx + 2, sry + 7, arrowcolor = scrollcolor2, \
                                bgcolor = libtcod.darker_azure, hcolor = scrollcolor2)
        self.MVBar.max = 100
        self.MVBar.inc = int(MVolume * 100)
        self.MVBar.reDraw()

        self.SVBar = WScrollBar(self.audiowindow, 2, 12, 20, srx + 2, sry + 12, arrowcolor = scrollcolor2, \
                                bgcolor = libtcod.darker_azure, hcolor = scrollcolor2)
        self.SVBar.max = 100
        self.SVBar.inc = int(SVolume * 100)
        self.SVBar.reDraw()

        self.aconlist = [self.audiowindow,0,0,24,30,srx,sry,1.0,1.0]
        XConsoles = [self.aconlist]
        moinc = self.MVBar.inc
        soinc = self.SVBar.inc

        first = True

        DrawBanner(self.audiowindow,12,2,'Audio Options')
        DrawScroll(self.audiowindow, 6, 8, 12, 2)
        DrawScroll(self.audiowindow, 6, 13, 12, 2)

        while True:
            lock.acquire()
            NoGraphics, NoButtons, NoMenus = True,True,True
            mvstr = str(int(self.MVBar.inc))
            svstr = str(int(self.SVBar.inc))

            if moinc != self.MVBar.inc or first:
                if len(mvstr) < 3:
                    for space in range(3 - len(mvstr)):
                        mvstr = ' ' + mvstr
                libtcod.console_set_default_foreground(self.audiowindow,libtcod.black)
                libtcod.console_print_ex(self.audiowindow, 7, 9, libtcod.BKGND_NONE, libtcod.LEFT, 'Music: %s' % mvstr)
                MVolume = (self.MVBar.inc * 1.0) / 100
                pygame.mixer.music.set_volume(MVolume)

            if soinc != self.SVBar.inc or first:
                if len(svstr) < 3:
                    for space in range(3 - len(svstr)):
                        svstr = ' ' + svstr
                libtcod.console_set_default_foreground(self.audiowindow,libtcod.black)
                libtcod.console_print_ex(self.audiowindow, 7, 14, libtcod.BKGND_NONE, libtcod.LEFT, 'Sound: %s' % svstr)
                SVolume = (self.SVBar.inc * 1.0) / 100
                
            first = False

            NoGraphics, NoButtons, NoMenus = False,False,False
            lock.release()
            moinc = self.MVBar.inc
            soinc = self.SVBar.inc
            if self.killswitch:
                break
            if [handle_mouse('cx'),handle_mouse('cy')] == [srx + 22,sry]:
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_background(self.audiowindow, 22, 0, libtcod.sky, libtcod.BKGND_SET)
                elif handle_mouse('lbutton_pressed'):
                    time.sleep(0.1)
                    libtcod.console_set_char_background(self.audiowindow, 22, 0, libtcod.black, libtcod.BKGND_SET)
                    break
                
        XConsoles = [self.conlist]
        self.MVBar.killswitch = True
        self.SVBar.killswitch = True
        del self.MVBar
        del self.SVBar
        libtcod.console_delete(self.audiowindow)
        self.passloop = False
        
    def doVideo(self):
        pass

    def createSave(self):
        if GameWorld.rswitch:
            GameWorld.packMap()
        glist = ['moveclouds','hpcswitch','pathlock','KeyLock','MouseLock','MoveLock','ignoreclick','cannotleave','changecursor', \
                 'killkeycheck','MenuSetting','PX','PY','PCX','PCY','OPCX','OPCY','PCcol','toplayer']
        gwlist = ['regiondict','invdict','inventory','rswitch','messagelog','lastmessage','lastmessagecount','setupdone','rinit','winit', \
                  'rdict','windowlock','groundview','invopen','cmopen','optopen','topwindow','loading','linkedareas','rtree','wobstructed', \
                  'wcdict','zgrid','ztop','translayer','itemdict','curz','rtypes','subtypes','maintype','tempzone','wlev','mlev', \
                  'shadowdict','clouddict','rheightmap','rterraindict','flood']
        savefile = {}
        savefile['globals'] = {}
        savefile['GameWorld'] = {}
        for gname in glist:
            savefile['globals'][gname] = copy.copy(globals()[gname])
        for attr in gwlist:
            savefile['GameWorld'][attr] = copy.copy(getattr(GameWorld,attr))
        return savefile

    def loadSave(self,save):
        global XConsoles, WeatherLayer, TopWindow, toplayer, freeze, Clouds, GameWorld
        savefile = GameWorld.saves[save]
        Clouds.killswitch = True
        time.sleep(0.1)
        libtcod.console_set_default_background(GameWorld.window, libtcod.black)
        libtcod.console_clear(GameWorld.window)
        XConsoles = []
        WeatherLayer = []
        TopWindow = []
        libtcod.console_clear(0)
        time.sleep(0.1)
        globals().update(savefile['globals'])
        for gattr in savefile['GameWorld'].keys():
            setattr(GameWorld, gattr, savefile['GameWorld'][gattr])
        GameWorld.dispMesgLog()
        doScreenSetup()
        GameWorld.updateStatus()
        if GameWorld.rswitch:
            libtcod.console_clear(wrwindow)
            GameWorld.loadMap(GameWorld.curregion)
        adjustScreen()
        GameWorld.handlePCchar()
        GameWorld.handlePCview()
        

    def saveGame(self):
        global XConsoles, killkeycheck, lock, wdict
        killkeycheck = True
        time.sleep(0.1)
        self.savewindow = libtcod.console_new(24,30)
        libtcod.console_set_default_background(self.savewindow, libtcod.darkest_azure)
        libtcod.console_clear(self.savewindow)
        DrawBox(self.savewindow, 0, 0, 23, 29, 1, libtcod.desaturated_yellow, libtcod.desaturated_flame)
        DrawBox(self.savewindow, 2, 2, 19, 2, 0, libtcod.darker_azure, btype = 'thin')
        DrawBox(self.savewindow, 2, 10, 19, 17, 0, libtcod.desaturated_yellow, libtcod.desaturated_yellow, btype = 'thin')
        DrawBox(self.savewindow, 4, 6, 5, 2, 0, libtcod.desaturated_yellow, libtcod.desaturated_red, btype = 'thin')
        DrawBox(self.savewindow, 12, 6, 7, 2, 0, libtcod.desaturated_yellow, libtcod.desaturated_red, btype = 'thin')
        libtcod.console_set_default_foreground(self.savewindow, libtcod.light_yellow)
        libtcod.console_print_ex(self.savewindow, 5, 7, libtcod.BKGND_NONE, libtcod.LEFT, 'Save')
        libtcod.console_print_ex(self.savewindow, 13, 7, libtcod.BKGND_NONE, libtcod.LEFT, 'Delete')

        libtcod.console_set_default_foreground(self.savewindow, hcolor2)
        libtcod.console_set_default_background(self.savewindow, scrollcolor2)
        char = [23,3,255]
        libtcod.console_print_ex(self.savewindow, 22, 0, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
        for x in range(3,21):
            for y in range(11,27):
                libtcod.console_set_char_background(self.savewindow, x, y, libtcod.black, libtcod.BKGND_SET)
        for x in range(3,20):
            libtcod.console_set_char_background(self.savewindow, x, 11, libtcod.darker_azure, libtcod.BKGND_SET)
        for tile in range(3,21):
            libtcod.console_set_char_background(self.savewindow, tile, 3, libtcod.black, libtcod.BKGND_SET)
        srx = (SCREEN_WIDTH - VIEW_WIDTH - 2) + (VIEW_WIDTH / 2) - 12
        sry = 1 + (VIEW_HEIGHT / 2) - 15
        self.sconlist = [self.savewindow,0,0,24,30,srx,sry,1.0,1.0]
        XConsoles = [self.sconlist]
        savestr = ''
        lasttime = time.time() - 0.3
        oldkey = 0
        SBar = ScrollBar(self.savewindow, 20, 11, 16, srx + 20, sry + 11, arrowcolor = scrollcolor2, \
                         bgcolor = libtcod.darker_azure, hcolor = globals()['hcolor'])
        if not os.path.exists('.\\data\\world\\%s' % GameWorld.world):
            os.makedirs('.\\data\\world\\%s' % GameWorld.world)
        slist = os.listdir('.\\data\\world\\%s' % GameWorld.world)
        slist = filter(lambda x: x[-4:] == '.svp', slist)
        for save in range(len(slist)):
            slist[save] = slist[save][:-4]
        SBar.max = max(len(slist) - 16,0)
        oldkey = 0
        curswitch = False
        save = False
        redo = False
        self.holdloop = False
        self.overwrite = False
        self.delete = False
        oinc = SBar.inc
        selectnum = 0
        invalid = ['[',']','/','\\','=','+','<','>',':',';','"',',','*','.']
        savefile = self.createSave()
        savelist = ['*NEW SAVE*']
        for save in slist:
            savelist.append(save)
        libtcod.console_set_default_foreground(self.savewindow, libtcod.white)
        for save in range(len(savelist))[:16]:
            libtcod.console_print_ex(self.savewindow, 11, 11 + save, libtcod.BKGND_NONE, libtcod.CENTER, savelist[save])
        while True:
            if self.holdloop:
                time.sleep(0.1)
                continue
            elif self.overwrite:
                savestr = savestr.strip(' ')
                GameWorld.saves[savestr] = savefile
                GameWorld.addMesg('Saving...')
                os.remove('.\\data\\world\\%s\\%s.svp' % (GameWorld.world,savestr))
                sfile = open('.\\data\\world\\%s\\%s.svp' % (GameWorld.world,savestr),'wb')
                gc.disable()
                cPickle.dump(savefile, sfile, -1)
                gc.enable()
                sfile.close()
                GameWorld.addMesg('Save point \'%s\' overwritten successfully.' % savestr)
                break
            elif self.delete:
                os.remove('.\\data\\world\\%s\\%s.svp' % (GameWorld.world,savestr))
                GameWorld.addMesg('Save point  \'%s\' deleted.' % savelist[selectnum])
                break
            newkey = key.c
            stimer = (time.time() - lasttime)
            if key.vk == libtcod.KEY_BACKSPACE and stimer >= 0.05:
                if len(savestr) > 0:
                    savestr = savestr[:-1]
                for tile in range(3 + len(savestr),21):
                    libtcod.console_print_ex(self.savewindow, tile, 3, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                lock.acquire()
                libtcod.console_set_default_foreground(self.savewindow, libtcod.white)
                libtcod.console_print_ex(self.savewindow, 3, 3, libtcod.BKGND_NONE, libtcod.LEFT, savestr)
                lock.release()
                lasttime = time.time()
            elif newkey and stimer >= 0.05:
                if newkey == oldkey and stimer < 0.2:
                    continue
                if len(savestr) == 18:
                    continue
                savestr += chr(key.c)
                lock.acquire()
                libtcod.console_set_default_foreground(self.savewindow, libtcod.white)
                libtcod.console_print_ex(self.savewindow, 3, 3, libtcod.BKGND_NONE, libtcod.LEFT, savestr)
                lock.release()
                lasttime = time.time()
                oldkey = newkey
            elif not key.pressed:
                lasttime = time.time() - 0.18
            lock.acquire()
            if time.time() % 1.0 > .5 and len(savestr) < 18 and not curswitch:
                libtcod.console_set_default_foreground(self.savewindow, libtcod.white)
                libtcod.console_print_ex(self.savewindow, 3 + len(savestr), 3, libtcod.BKGND_NONE, libtcod.LEFT, '|')
                curswitch = True
            elif time.time() % 1.0 < .5 and len(savestr) < 18 and curswitch:
                libtcod.console_print_ex(self.savewindow, 3 + len(savestr), 3, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                curswitch = False
            lock.release()
            if SBar.inc != oinc or redo:
                lock.acquire()
                for tile in range(3 + len(savestr),21):
                    libtcod.console_print_ex(self.savewindow, tile, 3, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                libtcod.console_set_default_foreground(self.savewindow, libtcod.white)
                libtcod.console_print_ex(self.savewindow, 3, 3, libtcod.BKGND_NONE, libtcod.LEFT, savestr)
                for y in range(11,27):
                    for x in range(3,20):
                        libtcod.console_set_char_background(self.savewindow, x, y, libtcod.black, libtcod.BKGND_SET)
                libtcod.console_set_default_foreground(self.savewindow, libtcod.white)
                for save in range(len(savelist))[SBar.inc:16 + SBar.inc]:
                    for x in range(3,20):
                        libtcod.console_print_ex(self.savewindow, x, 11 + save - SBar.inc, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                    libtcod.console_print_ex(self.savewindow, 11, 11 + save - SBar.inc, libtcod.BKGND_NONE, libtcod.CENTER, savelist[save])
                if selectnum in range(len(savelist))[SBar.inc:16 + SBar.inc]:
                    for x in range(3,20):
                        libtcod.console_set_char_background(self.savewindow, x, 11 + selectnum - SBar.inc, libtcod.darker_azure, libtcod.BKGND_SET)
                redo = False
                lock.release()
            lock.acquire()
            if handle_mouse('cx') in range(srx + 5,srx + 9) and handle_mouse('cy') == sry + 7:
                if handle_mouse('lbutton'):
                    for tile in range(5,9):
                        libtcod.console_set_char_background(self.savewindow, tile, 7, libtcod.darker_flame, libtcod.BKGND_SET)
                    save = True
                elif handle_mouse('lbutton_pressed') and save:
                    time.sleep(0.1)
                    if len(savestr) > 0:
                        killsave = False
                        for char in savestr:
                            if char in invalid:
                                killsave = True
                        if not killsave:
                            skip = False
                            for save in savelist:
                                if savestr == save:
                                    self.holdloop = True
                                    lock.release()
                                    SWindow = Dialogue([('Yes',throwSwitches,self,['holdloop','overwrite']),('No',throwSwitches,self,['holdloop'])],title = 'Overwrite \'%s\'?' % savestr)
                                    SWindow.start()
                                    skip = True
                            if skip:
                                continue
                            savestr = savestr.strip(' ')
                            GameWorld.addMesg('Saving...')
                            sfile = open('.\\data\\world\\%s\\%s.svp' % (GameWorld.world,savestr),'wb')
                            gc.disable()
                            cPickle.dump(savefile, sfile, -1)
                            gc.enable()
                            sfile.close()
                            GameWorld.addMesg('Save point \'%s\' added successfully.' % savestr)
                            lock.release()
                            break
                    save = False
                else:
                    for tile in range(5,9):
                        libtcod.console_set_char_background(self.savewindow, tile, 7, libtcod.desaturated_flame, libtcod.BKGND_SET)
            else:
                for tile in range(5,9):
                    libtcod.console_set_char_background(self.savewindow, tile, 7, libtcod.darker_azure, libtcod.BKGND_SET)
            if handle_mouse('cx') in range(srx + 13,srx + 19) and handle_mouse('cy') == sry + 7:
                if handle_mouse('lbutton'):
                    for tile in range(13,19):
                        libtcod.console_set_char_background(self.savewindow, tile, 7, libtcod.darker_flame, libtcod.BKGND_SET)
                    delete = True
                elif handle_mouse('lbutton_pressed') and delete:
                    time.sleep(0.1)
                    if selectnum != 0:
                        self.holdloop = True
                        lock.release()
                        DWindow = Dialogue([('Yes',throwSwitches,self,['holdloop','delete']),('No',throwSwitches,self,['holdloop'])],title = 'Delete \'%s\'?' % savelist[selectnum])
                        DWindow.start()
                        continue
                else:
                    for tile in range(13,19):
                        libtcod.console_set_char_background(self.savewindow, tile, 7, libtcod.desaturated_flame, libtcod.BKGND_SET)
            else:
                for tile in range(13,19):
                    libtcod.console_set_char_background(self.savewindow, tile, 7, libtcod.darker_azure, libtcod.BKGND_SET)
            lock.release()
            if handle_mouse('cx') in range(srx + 3,srx + 20) and handle_mouse('cy') in range(sry + 11,sry + 27):
                if handle_mouse('lbutton'):
                    try:
                        savelist[handle_mouse('cy') - sry - 11 + SBar.inc]
                        selectnum = handle_mouse('cy') - sry - 11 + SBar.inc
                        savestr = savelist[selectnum]
                        if savestr == '*NEW SAVE*':
                            savestr = ''
                        redo = True
                    except IndexError:
                        pass
            if [handle_mouse('cx'),handle_mouse('cy')] == [srx + 22,sry]:
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_background(self.savewindow, 22, 0, libtcod.sky, libtcod.BKGND_SET)
                elif handle_mouse('lbutton_pressed'):
                    time.sleep(0.1)
                    libtcod.console_set_char_background(self.savewindow, 22, 0, libtcod.black, libtcod.BKGND_SET)
                    break
            oinc = SBar.inc
                
        XConsoles = [self.conlist]
        SBar.killswitch = True
        del SBar
        libtcod.console_delete(self.savewindow)
        killkeycheck = False
        self.passloop = False

    def loadGame(self):
        global XConsoles, killkeycheck, lock
        killkeycheck = True
        time.sleep(0.1)
        self.loadwindow = libtcod.console_new(24,30)
        libtcod.console_set_default_background(self.loadwindow, libtcod.darkest_azure)
        libtcod.console_clear(self.loadwindow)
        DrawBox(self.loadwindow, 0, 0, 23, 29, 1, libtcod.desaturated_yellow, libtcod.desaturated_flame)
        DrawBox(self.loadwindow, 2, 6, 19, 21, 0, libtcod.desaturated_yellow, libtcod.desaturated_yellow, btype = 'thin')
        DrawBox(self.loadwindow, 4, 2, 5, 2, 0, libtcod.desaturated_yellow, libtcod.desaturated_red, btype = 'thin')
        DrawBox(self.loadwindow, 12, 2, 7, 2, 0, libtcod.desaturated_yellow, libtcod.desaturated_red, btype = 'thin')
        libtcod.console_set_default_foreground(self.loadwindow, libtcod.light_yellow)
        libtcod.console_print_ex(self.loadwindow, 5, 3, libtcod.BKGND_NONE, libtcod.LEFT, 'Load')
        libtcod.console_print_ex(self.loadwindow, 13, 3, libtcod.BKGND_NONE, libtcod.LEFT, 'Delete')

        libtcod.console_set_default_foreground(self.loadwindow, hcolor2)
        libtcod.console_set_default_background(self.loadwindow, scrollcolor2)
        char = [23,3,189]
        libtcod.console_print_ex(self.loadwindow, 22, 0, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
        for x in range(3,21):
            for y in range(7,27):
                libtcod.console_set_char_background(self.loadwindow, x, y, libtcod.black, libtcod.BKGND_SET)
        for x in range(3,20):
            libtcod.console_set_char_background(self.loadwindow, x, 7, libtcod.darker_azure, libtcod.BKGND_SET)
        srx = (SCREEN_WIDTH - VIEW_WIDTH - 2) + (VIEW_WIDTH / 2) - 12
        sry = 1 + (VIEW_HEIGHT / 2) - 15
        self.lconlist = [self.loadwindow,0,0,24,30,srx,sry,1.0,1.0]
        XConsoles = [self.lconlist]
        self.LBar = ScrollBar(self.loadwindow, 20, 7, 20, srx + 20, sry + 7, arrowcolor = scrollcolor2,
                         bgcolor = libtcod.darker_azure, hcolor = globals()['hcolor'])
        if not os.path.exists('.\\data\\world\\%s' % GameWorld.world):
            os.makedirs('.\\data\\world\\%s' % GameWorld.world)
        slist = os.listdir('.\\data\\world\\%s' % GameWorld.world)
        slist = filter(lambda x: x[-4:] == '.svp', slist)
        for save in range(len(slist)):
            slist[save] = slist[save][:-4]
        self.LBar.max = max(len(slist) - 20,0)
        curswitch = False
        redo = False
        load = False
        delete = False
        self.holdloop = False
        self.delete = False
        oinc = self.LBar.inc
        selectnum = 0
        savelist = []
        for save in slist:
            savelist.append(save)
        if len(savelist) == 0:
            savelist.append('-NO SAVES-')
        libtcod.console_set_default_foreground(self.loadwindow, libtcod.white)
        for save in range(len(savelist))[:20]:
            libtcod.console_print_ex(self.loadwindow, 11, 7 + save, libtcod.BKGND_NONE, libtcod.CENTER, savelist[save])
            
        doload = False
        while True:
            if self.holdloop:
                time.sleep(0.1)
                continue
            elif self.delete:
                GameWorld.saves.pop(savelist[selectnum])
                GameWorld.addMesg('Save point \'%s\' deleted.' % savelist[selectnum])
                break
            if self.LBar.inc != oinc or redo:
                lock.acquire()
                for y in range(7,27):
                    for x in range(3,20):
                        libtcod.console_set_char_background(self.loadwindow, x, y, libtcod.black, libtcod.BKGND_SET)
                libtcod.console_set_default_foreground(self.loadwindow, libtcod.white)
                for save in range(len(savelist))[self.LBar.inc:20 + self.LBar.inc]:
                    for x in range(3,20):
                        libtcod.console_print_ex(self.loadwindow, x, 7 + save - self.LBar.inc, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                    libtcod.console_print_ex(self.loadwindow, 11, 7 + save - self.LBar.inc, libtcod.BKGND_NONE, libtcod.CENTER, savelist[save])
                if selectnum in range(len(savelist))[self.LBar.inc:20 + self.LBar.inc]:
                    for x in range(3,20):
                        libtcod.console_set_char_background(self.loadwindow, x, 7 + selectnum - self.LBar.inc, libtcod.darker_azure, libtcod.BKGND_SET)
                redo = False
                lock.release()
            lock.acquire()
            if handle_mouse('cx') in range(srx + 5,srx + 9) and handle_mouse('cy') == sry + 3:
                if handle_mouse('lbutton'):
                    for tile in range(5,9):
                        libtcod.console_set_char_background(self.loadwindow, tile, 3, libtcod.darker_flame, libtcod.BKGND_SET)
                    load = True
                elif handle_mouse('lbutton_pressed') and load:
                    time.sleep(0.1)
                    load = False
                    if savelist[selectnum] != '-NO SAVES-':
                        doload = True
                    lock.release()
                    break
                else:
                    for tile in range(5,9):
                        libtcod.console_set_char_background(self.loadwindow, tile, 3, libtcod.desaturated_flame, libtcod.BKGND_SET)
            else:
                for tile in range(5,9):
                    libtcod.console_set_char_background(self.loadwindow, tile, 3, libtcod.darker_azure, libtcod.BKGND_SET)
            if handle_mouse('cx') in range(srx + 13,srx + 19) and handle_mouse('cy') == sry + 3:
                if handle_mouse('lbutton'):
                    for tile in range(13,19):
                        libtcod.console_set_char_background(self.loadwindow, tile, 3, libtcod.darker_flame, libtcod.BKGND_SET)
                    delete = True
                elif handle_mouse('lbutton_pressed') and delete:
                    time.sleep(0.1)
                    if savelist[selectnum] != '-NO SAVES-':
                        self.holdloop = True
                        lock.release()
                        DWindow = Dialogue([('Yes',throwSwitches,self,['holdloop','delete']),('No',throwSwitches,self,['holdloop'])],title = 'Delete \'%s\'?' % savelist[selectnum])
                        DWindow.start()
                        continue
                else:
                    for tile in range(13,19):
                        libtcod.console_set_char_background(self.loadwindow, tile, 3, libtcod.desaturated_flame, libtcod.BKGND_SET)
            else:
                for tile in range(13,19):
                    libtcod.console_set_char_background(self.loadwindow, tile, 3, libtcod.darker_azure, libtcod.BKGND_SET)
            lock.release()
            if handle_mouse('cx') in range(srx + 3,srx + 20) and handle_mouse('cy') in range(sry + 7,sry + 27):
                if handle_mouse('lbutton'):
                    try:
                        savelist[handle_mouse('cy') - sry - 7 + self.LBar.inc]
                        selectnum = handle_mouse('cy') - sry - 7 + self.LBar.inc
                        redo = True
                    except IndexError:
                        pass
            if [handle_mouse('cx'),handle_mouse('cy')] == [srx + 22,sry]:
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_background(self.loadwindow, 22, 0, libtcod.sky, libtcod.BKGND_SET)
                elif handle_mouse('lbutton_pressed'):
                    time.sleep(0.1)
                    libtcod.console_set_char_background(self.loadwindow, 22, 0, libtcod.black, libtcod.BKGND_SET)
                    break
            oinc = self.LBar.inc
                
        self.LBar.killswitch = True
        del self.LBar
        if doload:
            self.loadSave(savelist[selectnum])
            GameWorld.addMesg('Save point \'%s\' loaded successfully.' % savelist[selectnum])
        libtcod.console_delete(self.loadwindow)
        XConsoles = [self.conlist]
        killkeycheck = False
        self.passloop = False
        if doload:
            GameWorld.doOptions()

    def close(self):
        global moveclouds, MoveLock, pathlock, XConsoles
        time.sleep(0.1)
        self.killswitch = True
        time.sleep(0.1)
        try:
            XConsoles.remove(self.conlist)
        except:
            pass
        try:
            XConsoles.remove(self.sconlist)
        except:
            pass
        try:
            XConsoles.remove(self.lconlist)
        except:
            pass
        try:
            XConsoles.remove(self.aconlist)
        except:
            pass
        try:
            XConsoles.remove(self.vconlist)
        except:
            pass
        try:
            self.SVBar.killswitch = True
            self.MVBar.killswitch = True
        except:
            pass
        try:
            self.SBar.killswitch = True
        except:
            pass
        try:
            self.LBar.killswitch = True
        except:
            pass
        moveclouds = self.mcloudstate
        GameWorld.windowlock = False
        MoveLock = False
        pathlock = False
        libtcod.console_delete(self.oconsole)
        del self

class CWindow(threading.Thread):
    def __init__(self,conw = 12,conh = 12):
        threading.Thread.__init__(self)
        self.conw = conw
        self.conh = conh
        self.killswitch = False
        self.typenum = 0
        self.xoff,self.yoff = 0,0

    def run(self):
        global pathlock, moveclouds, MoveLock, TopWindow, XConsoles
        pathlock = True
        self.mcloudstate = moveclouds
        moveclouds = False
        MoveLock = True
        GameWorld.windowlock = True
        
        self.cconsole = libtcod.console_new(RMAP_WIDTH,RMAP_HEIGHT)
        libtcod.console_set_default_background(self.cconsole, libtcod.black)
        libtcod.console_clear(self.cconsole)
        DrawBox(self.cconsole, 0, 0, self.conw - 1, self.conh - 1, 1, bordercol, bordercolh2)

        self.tconsole = libtcod.console_new(20,36)
        libtcod.console_set_default_background(self.tconsole, bgcolor)
        libtcod.console_clear(self.tconsole)
        DrawBox(self.tconsole, 0, 0, 19, 35, 1, bordercol, bordercolh2)

        libtcod.console_set_default_foreground(self.tconsole, hcolor2)
        libtcod.console_set_default_background(self.tconsole, scrollcolor2)
        libtcod.console_print_ex(self.tconsole, 12, 28, libtcod.BKGND_SET, libtcod.LEFT, 'Save')
        DrawBox(self.tconsole, 11, 27, 5, 2, color = bordercol, cornercolor = libtcod.desaturated_red, btype = 'thin')
        
        libtcod.console_set_default_foreground(self.tconsole, hcolor2)
        libtcod.console_set_default_background(self.tconsole, scrollcolor2)
        libtcod.console_print_ex(self.tconsole, 4, 28, libtcod.BKGND_SET, libtcod.LEFT, 'Load')
        DrawBox(self.tconsole, 3, 27, 5, 2, color = bordercol, cornercolor = libtcod.desaturated_red, btype = 'thin')

        libtcod.console_set_default_foreground(self.tconsole, hcolor2)
        libtcod.console_set_default_background(self.tconsole, scrollcolor2)
        libtcod.console_print_ex(self.tconsole, 4, 32, libtcod.BKGND_SET, libtcod.LEFT, 'Place Design')
        DrawBox(self.tconsole, 3, 31, 13, 2, color = bordercol, cornercolor = libtcod.desaturated_red, btype = 'thin')

        libtcod.console_set_default_foreground(self.tconsole, bordercolh2)
        libtcod.console_print_ex(self.tconsole, 3, 5, libtcod.BKGND_NONE, libtcod.LEFT, 'X')
        libtcod.console_print_ex(self.tconsole, 7, 5, libtcod.BKGND_NONE, libtcod.LEFT, 'Y')
        libtcod.console_print_ex(self.tconsole, 11, 5, libtcod.BKGND_NONE, libtcod.LEFT, 'Z')
        libtcod.console_set_default_foreground(self.tconsole, bordercol)

        libtcod.console_set_default_foreground(self.tconsole, hcolor2)
        libtcod.console_set_default_background(self.tconsole, scrollcolor2)
        libtcod.console_print_ex(self.tconsole, 14, 3, libtcod.BKGND_SET, libtcod.LEFT, 'Set')
        DrawBox(self.tconsole, 13, 2, 4, 2, color = bordercol, cornercolor = libtcod.desaturated_red, btype = 'thin')

        libtcod.console_set_default_foreground(self.tconsole, bordercol)
        
        for x in range(3):
            libtcod.console_set_char_background(self.tconsole, 2 + x, 3, libtcod.black, libtcod.BKGND_SET)
            libtcod.console_print_ex(self.tconsole, 2 + x, 2, libtcod.BKGND_NONE, libtcod.CENTER, chr(DoChar(uschar)))
            libtcod.console_print_ex(self.tconsole, 2 + x, 4, libtcod.BKGND_NONE, libtcod.CENTER, chr(DoChar(dschar)))

        for x in range(3):
            libtcod.console_set_char_background(self.tconsole, 6 + x, 3, libtcod.black, libtcod.BKGND_SET)
            libtcod.console_print_ex(self.tconsole, 6 + x, 2, libtcod.BKGND_NONE, libtcod.CENTER, chr(DoChar(uschar)))
            libtcod.console_print_ex(self.tconsole, 6 + x, 4, libtcod.BKGND_NONE, libtcod.CENTER, chr(DoChar(dschar)))

        for x in range(2):
            libtcod.console_set_char_background(self.tconsole, 10 + x, 3, libtcod.black, libtcod.BKGND_SET)
            libtcod.console_print_ex(self.tconsole, 10 + x, 2, libtcod.BKGND_NONE, libtcod.CENTER, chr(DoChar(uschar)))
            libtcod.console_print_ex(self.tconsole, 10 + x, 4, libtcod.BKGND_NONE, libtcod.CENTER, chr(DoChar(dschar)))

        for y in range(16,19):
            libtcod.console_print_ex(self.tconsole, 4, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(lschar)))
            libtcod.console_print_ex(self.tconsole, 8, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(rschar)))
        for x in range(5,8):
            libtcod.console_set_char_background(self.tconsole, x, 16, libtcod.desaturated_red, libtcod.BKGND_SET)
            libtcod.console_set_char_background(self.tconsole, x, 17, libtcod.desaturated_green, libtcod.BKGND_SET)
            libtcod.console_set_char_background(self.tconsole, x, 18, libtcod.desaturated_blue, libtcod.BKGND_SET)
        libtcod.console_set_default_foreground(self.tconsole, bordercol)
        for x in range(5,8):
            libtcod.console_print_ex(self.tconsole, x, 15, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(uschar)))
            libtcod.console_print_ex(self.tconsole, x, 19, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(dschar)))

        for x in range(3,17):
            for y in range(7,10):
                libtcod.console_set_char_background(self.tconsole, x, y, libtcod.black, libtcod.BKGND_SET)

        libtcod.console_print_ex(self.tconsole, 2, 8, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(lschar)))       
        libtcod.console_print_ex(self.tconsole, 17, 8, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(rschar)))
        libtcod.console_set_default_foreground(self.tconsole, hcolor2)
        libtcod.console_print_ex(self.tconsole, 10, 10, libtcod.BKGND_NONE, libtcod.CENTER, 'Material')        

        libtcod.console_set_default_foreground(self.tconsole, bordercol)
        libtcod.console_print_ex(self.tconsole, 5, 21, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(checked)))
        libtcod.console_set_default_foreground(self.tconsole, hcolor2)
        libtcod.console_print_ex(self.tconsole, 7, 21, libtcod.BKGND_NONE, libtcod.LEFT, 'FG')
        libtcod.console_set_default_foreground(self.tconsole, bordercol)
        libtcod.console_print_ex(self.tconsole, 11, 21, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(unchecked)))
        libtcod.console_set_default_foreground(self.tconsole, hcolor2)
        libtcod.console_print_ex(self.tconsole, 13, 21, libtcod.BKGND_NONE, libtcod.LEFT, 'BG')
        libtcod.console_set_default_foreground(self.tconsole, bordercol)

        libtcod.console_print_ex(self.tconsole, 2, 24, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(lschar)))
        libtcod.console_print_ex(self.tconsole, 17, 24, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(rschar)))

        libtcod.console_print_ex(self.tconsole, 10, 16, libtcod.BKGND_NONE, libtcod.LEFT, 'R')
        libtcod.console_print_ex(self.tconsole, 10, 17, libtcod.BKGND_NONE, libtcod.LEFT, 'G')
        libtcod.console_print_ex(self.tconsole, 10, 18, libtcod.BKGND_NONE, libtcod.LEFT, 'B')
        libtcod.console_set_char_foreground(self.tconsole, 10, 16, libtcod.desaturated_red)
        libtcod.console_set_char_foreground(self.tconsole, 10, 17, libtcod.desaturated_green)
        libtcod.console_set_char_foreground(self.tconsole, 10, 18, libtcod.desaturated_blue)

        libtcod.console_set_default_foreground(self.tconsole, hcolor2)
        libtcod.console_print_ex(self.tconsole, 10, 13, libtcod.BKGND_NONE, libtcod.CENTER, 'Type')
        libtcod.console_set_default_foreground(self.tconsole, bordercol)
        libtcod.console_print_ex(self.tconsole, 2, 12, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(lschar)))
        libtcod.console_print_ex(self.tconsole, 17, 12, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(rschar)))
        libtcod.console_set_char_foreground(self.tconsole, 2, 12, bordercol)
        libtcod.console_set_char_foreground(self.tconsole, 10, 12, bordercol)
        
        for tile in range(3,17):
            libtcod.console_set_char_background(self.tconsole, tile, 12, libtcod.black, libtcod.BKGND_SET)
            libtcod.console_set_char_background(self.tconsole, tile, 23, libtcod.black, libtcod.BKGND_SET)
            libtcod.console_set_char_background(self.tconsole, tile, 24, libtcod.black, libtcod.BKGND_SET)
            libtcod.console_set_char_background(self.tconsole, tile, 25, libtcod.black, libtcod.BKGND_SET)

        libtcod.console_set_default_foreground(self.cconsole, bordercol)
        MPX = (self.conw + 20) / 2
        MPY = self.conh / 2
        OMPX = (SCREEN_WIDTH - VIEW_WIDTH) + (VIEW_WIDTH / 2) - MPX - 3
        OMPY = (VIEW_HEIGHT / 2) - MPY
        self.rx = (SCREEN_WIDTH - VIEW_WIDTH - 2) + (VIEW_WIDTH / 2) - MPX
        self.ry = 2 + (VIEW_HEIGHT / 2) - MPY
        self.tcrx = self.rx + self.conw
        self.tcry = 2 + (VIEW_HEIGHT / 2) - 18
        self.conlist = [self.cconsole,0,0,self.conw,self.conh,self.rx,self.ry,1.0,1.0]
        XConsoles += [self.conlist]
        self.tconlist = [self.tconsole,0,0,20,36,self.tcrx,self.tcry,1.0,1.0]
        XConsoles += [self.tconlist]
        self.mconw = self.conw - 2
        self.mconh = self.conh - 2
        self.winc,self.wdec,self.hinc,self.hdec,self.zinc,self.zdec = False,False,False,False,False,False
        self.cinc,self.cdec = False,False
        self.doresize = False
        self.curnum = 0
        self.reqpage = 0
        self.noclick = False
        self.save = False
        self.load = False
        self.changetile = False
        self.changetype = False
        self.reqmats = {}
        self.congrid = {}
        self.conskip = {}
        self.contiles = []
        for z in range(0,100):
            self.congrid[z] = {}
            self.conskip[z] = {}
        self.curentry = GameWorld.builddict[GameWorld.buildtypes[self.typenum]].items()[self.curnum]
        tmat = self.curentry[1]['MATERIALS'][0]
        tcol2 = libtcod.Color(int(GameWorld.matstruct[tmat]['COLOR'][0]),int(GameWorld.matstruct[tmat]['COLOR'][1]), \
                             int(GameWorld.matstruct[tmat]['COLOR'][2]))
        tcol = libtcod.white
        self.fr,self.fg,self.fb = tcol.r,tcol.g,tcol.b
        self.br,self.bg,self.bb = tcol2.r,tcol2.g,tcol2.b

        libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
        libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fr))
        libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fg))
        libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fb))
        self.rminus,self.gminus,self.bminus = False,False,False
        self.rplus,self.gplus,self.bplus = False,False,False
        self.dozinc,self.dozdec = False,False
        self.colswitch = 'fore'
        self.initcoords = False
        self.passloop = False
        self.place = False
        self.didbuild = False
        self.otilegrid = {}
        self.z = 0
        
        while not self.killswitch:
            if self.passloop:
                time.sleep(0.1)
                continue
            lock.acquire()
            libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
            libtcod.console_print_ex(self.tconsole, 9, 12, libtcod.BKGND_NONE, libtcod.CENTER, GameWorld.buildtypes[self.typenum].capitalize())
            self.conwstr = str(self.mconw)
            self.zerostr = '0' * (3 - len(self.conwstr))
            self.conwstr = self.zerostr + self.conwstr
            self.conhstr = str(self.mconh)
            self.zerostr = '0' * (3 - len(self.conhstr))
            self.conhstr = self.zerostr + self.conhstr
            self.zstr = str(self.z)
            self.zerostr = '0' * (2 - len(self.zstr))
            self.zstr = self.zerostr + self.zstr
            libtcod.console_print_ex(self.tconsole, 4, 3, libtcod.BKGND_NONE, libtcod.RIGHT, self.conwstr)
            libtcod.console_print_ex(self.tconsole, 8, 3, libtcod.BKGND_NONE, libtcod.RIGHT, self.conhstr)
            libtcod.console_print_ex(self.tconsole, 11, 3, libtcod.BKGND_NONE, libtcod.RIGHT, self.zstr)
            
            # X
            for num in range(3):
                # Top Row
                if [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 2,self.tcry + 2] and handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 2 + num, 2, bordercol)
                    self.winc = 2 - num
                elif [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 2,self.tcry + 2]:
                    libtcod.console_set_char_foreground(self.tconsole, 2 + num, 2, hcolor)
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 2 + num, 2, bordercol)
                # Bottom Row
                if [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 2,self.tcry + 4] and handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 2 + num, 4, bordercol)
                    self.wdec = 2 - num
                elif [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 2,self.tcry + 4]:
                    libtcod.console_set_char_foreground(self.tconsole, 2 + num, 4, hcolor)
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 2 + num, 4, bordercol)
            # Y
            for num in range(3):
                # Top Row
                if [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 6,self.tcry + 2] and handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 6 + num, 2, bordercol)
                    self.hinc = 2 - num
                elif [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 6,self.tcry + 2]:
                    libtcod.console_set_char_foreground(self.tconsole, 6 + num, 2, hcolor)
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 6 + num, 2, bordercol)
                # Bottom Row
                if [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 6,self.tcry + 4] and handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 6 + num, 4, bordercol)
                    self.hdec = 2 - num
                elif [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 6,self.tcry + 4]:
                    libtcod.console_set_char_foreground(self.tconsole, 6 + num, 4, hcolor)
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 6 + num, 4, bordercol)
            # Z
            for num in range(2):
                # Top Row
                if [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 10,self.tcry + 2] and handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 10 + num, 2, bordercol)
                    self.dozinc = True
                elif [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 10,self.tcry + 2] and handle_mouse('lbutton_pressed') and self.dozinc:
                    self.zinc = 1 - num
                    self.dozinc = False
                elif [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 10,self.tcry + 2]:
                    libtcod.console_set_char_foreground(self.tconsole, 10 + num, 2, hcolor)
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 10 + num, 2, bordercol)
                # Bottom Row
                if [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 10,self.tcry + 4] and handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 10 + num, 4, bordercol)
                    self.dozdec = True
                elif [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 10,self.tcry + 4] and handle_mouse('lbutton_pressed') and self.dozdec:
                    self.zdec = 1 - num
                    self.dozdec = False
                elif [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 10,self.tcry + 4]:
                    libtcod.console_set_char_foreground(self.tconsole, 10 + num, 4, hcolor)
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 10 + num, 4, bordercol)

            # 'Set' Button
            if handle_mouse('cx') in range(self.tcrx + 14,self.tcrx + 17) and handle_mouse('cy') == self.tcry + 3:
                if handle_mouse('lbutton'):
                    for tile in range(14,17):
                        libtcod.console_set_char_background(self.tconsole, tile, 3, bgcolor2, libtcod.BKGND_SET)
                    self.doresize = True
                elif handle_mouse('lbutton_pressed') and self.doresize:
                    time.sleep(0.1)
                    self.doresize = False
                    self.reSize()
                    self.reDraw()
                else:
                    for tile in range(14,17):
                        libtcod.console_set_char_background(self.tconsole, tile, 3, bordercolh2, libtcod.BKGND_SET)
            else:
                for tile in range(14,17):
                    libtcod.console_set_char_background(self.tconsole, tile, 3, buttonback, libtcod.BKGND_SET)

            # Display Required Materials
            self.oreqmats = copy.copy(self.reqmats)
            self.reqmats = {}
            for z in range(100):
                for tile in self.congrid[z].values():
                    if tile:
                        buildtype = tile[0]
                        key = tile[1]
                        self.curentry = GameWorld.builddict[buildtype][key]
                        reqmats = self.curentry['REQMATS']
                        for req in reqmats:
                            reqname = req.split(':')[0]
                            reqnum = int(req.split(':')[1])
                            if not self.reqmats.get(reqname):
                                self.reqmats[reqname] = reqnum
                            else:
                                self.reqmats[reqname] += reqnum
            if not self.oreqmats == self.reqmats:
                for x in range(3,17):
                    for y in range(7,10):
                        libtcod.console_set_default_background(self.tconsole, libtcod.black)
                        libtcod.console_print_ex(self.tconsole, x, y, libtcod.BKGND_SET, libtcod.LEFT, ' ')   
            reqs = self.reqmats.items()
            for req in range(3):
                try:
                    rnum = self.reqpage * 3
                    reqname = reqs[rnum + req][0]
                    reqnum = str(reqs[rnum + req][1])
                    libtcod.console_print_ex(self.tconsole, 10, 7 + req, libtcod.BKGND_NONE, libtcod.CENTER, reqname.capitalize() + ': ' + reqnum)
                except IndexError:
                    pass
                    
            # Type Selection
                    
            if [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + 2,self.tcry + 12]:
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 2, 12, bordercol)
                    self.changetype = True
                elif handle_mouse('lbutton_pressed') and self.changetype:
                    self.typenum = max(0,self.typenum - 1)
                    self.curnum = 0
                    libtcod.console_set_default_background(self.tconsole, libtcod.black)
                    for tile in range(3,17):
                        libtcod.console_print_ex(self.tconsole, tile, 12, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                        libtcod.console_print_ex(self.tconsole, tile, 23, libtcod.BKGND_SET, libtcod.LEFT, ' ')
                        libtcod.console_print_ex(self.tconsole, tile, 24, libtcod.BKGND_SET, libtcod.LEFT, ' ')
                        libtcod.console_print_ex(self.tconsole, tile, 25, libtcod.BKGND_SET, libtcod.LEFT, ' ')
                    keylist = GameWorld.builddict[GameWorld.buildtypes[self.typenum]].keys()
                    keylist.sort()
                    key = keylist[self.curnum]
                    buildtype = GameWorld.builddict[GameWorld.buildtypes[self.typenum]]
                    self.curentry = GameWorld.builddict[GameWorld.buildtypes[self.typenum]][key]
                    tmat = self.curentry['MATERIALS'][0]
                    tcol2 = libtcod.Color(int(GameWorld.matstruct[tmat]['COLOR'][0]),int(GameWorld.matstruct[tmat]['COLOR'][1]), \
                                         int(GameWorld.matstruct[tmat]['COLOR'][2]))
                    tcol = libtcod.white
##                    if buildtype == 'floor' or buildtype == 'ceiling':
##                        tcol = tcol / 2
                    self.fr,self.fg,self.fb = tcol.r,tcol.g,tcol.b
                    self.br,self.bg,self.bb = tcol2.r,tcol2.g,tcol2.b
                    for y in range(16,19):
                        for x in range(5,8):
                            libtcod.console_print_ex(self.tconsole, x, y, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                    libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
                    if self.colswitch == 'fore':
                        libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fr))
                        libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fg))
                        libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fb))
                    else:
                        libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.br))
                        libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bg))
                        libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bb))
                    self.changetype = False
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 2, 12, hcolor)
            elif [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + 17,self.tcry + 12]:
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 17, 12, bordercol)
                    self.changetype = True
                elif handle_mouse('lbutton_pressed') and self.changetype:
                    self.typenum = min(len(GameWorld.buildtypes) - 1,self.typenum + 1)
                    self.curnum = 0
                    libtcod.console_set_default_background(self.tconsole, libtcod.black)
                    for tile in range(3,17):
                        libtcod.console_print_ex(self.tconsole, tile, 12, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                        libtcod.console_print_ex(self.tconsole, tile, 23, libtcod.BKGND_SET, libtcod.LEFT, ' ')
                        libtcod.console_print_ex(self.tconsole, tile, 24, libtcod.BKGND_SET, libtcod.LEFT, ' ')
                        libtcod.console_print_ex(self.tconsole, tile, 25, libtcod.BKGND_SET, libtcod.LEFT, ' ')
                    buildtype = GameWorld.builddict[GameWorld.buildtypes[self.typenum]]
                    keylist = GameWorld.builddict[GameWorld.buildtypes[self.typenum]].keys()
                    keylist.sort()
                    key = keylist[self.curnum]
                    self.curentry = GameWorld.builddict[GameWorld.buildtypes[self.typenum]][key]
                    tmat = self.curentry['MATERIALS'][0]
                    tcol2 = libtcod.Color(int(GameWorld.matstruct[tmat]['COLOR'][0]),int(GameWorld.matstruct[tmat]['COLOR'][1]), \
                                         int(GameWorld.matstruct[tmat]['COLOR'][2]))
                    tcol = libtcod.white
##                    if buildtype == 'floor' or buildtype == 'ceiling':
##                        tcol = tcol / 2
                    self.fr,self.fg,self.fb = tcol.r,tcol.g,tcol.b
                    self.br,self.bg,self.bb = tcol2.r,tcol2.g,tcol2.b
                    for y in range(16,19):
                        for x in range(5,8):
                            libtcod.console_print_ex(self.tconsole, x, y, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                    libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
                    if self.colswitch == 'fore':
                        libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fr))
                        libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fg))
                        libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fb))
                    else:
                        libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.br))
                        libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bg))
                        libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bb))
                    self.changetype = False
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 17, 12, hcolor)

            # Else...
                
            else:
                libtcod.console_set_char_foreground(self.tconsole, 2, 12, bordercol)
                libtcod.console_set_char_foreground(self.tconsole, 17, 12, bordercol)

            # Save

            if handle_mouse('cx') in range(self.tcrx + 12,self.tcrx + 16) and handle_mouse('cy') == self.tcry + 28:
                if handle_mouse('lbutton'):
                    for tile in range(12,16):
                        libtcod.console_set_char_background(self.tconsole, tile, 28, bgcolor2, libtcod.BKGND_SET)
                    self.save = True
                elif handle_mouse('lbutton_pressed') and self.save:
                    time.sleep(0.1)
                    self.save = False
                    self.passloop = True
                    sthread = threading.Thread(target=self.doSave)
                    sthread.start()
                else:
                    for tile in range(12,16):
                        libtcod.console_set_char_background(self.tconsole, tile, 28, bordercolh2, libtcod.BKGND_SET)
            else:
                for tile in range(12,16):
                    libtcod.console_set_char_background(self.tconsole, tile, 28, buttonback, libtcod.BKGND_SET)

            # Load
                    
            if handle_mouse('cx') in range(self.tcrx + 4,self.tcrx + 8) and handle_mouse('cy') == self.tcry + 28:
                if handle_mouse('lbutton'):
                    for tile in range(4,8):
                        libtcod.console_set_char_background(self.tconsole, tile, 28, bgcolor2, libtcod.BKGND_SET)
                    self.load = True
                elif handle_mouse('lbutton_pressed') and self.load:
                    time.sleep(0.1)
                    self.load = False
                    self.passloop = True
                    lthread = threading.Thread(target=self.doLoad)
                    lthread.start()
                else:
                    for tile in range(4,8):
                        libtcod.console_set_char_background(self.tconsole, tile, 28, bordercolh2, libtcod.BKGND_SET)
            else:
                for tile in range(4,8):
                    libtcod.console_set_char_background(self.tconsole, tile, 28, buttonback)                

            # Place Design

            if handle_mouse('cx') in range(self.tcrx + 4,self.tcrx + 16) and handle_mouse('cy') == self.tcry + 32:
                if handle_mouse('lbutton'):
                    for tile in range(4,16):
                        libtcod.console_set_char_background(self.tconsole, tile, 32, bgcolor2, libtcod.BKGND_SET)
                    self.place = True
                elif handle_mouse('lbutton_pressed') and self.place:
                    time.sleep(0.1)
                    self.place = False
                    self.passloop = True
                    pthread = threading.Thread(target=self.doPlace)
                    pthread.start()
                else:
                    for tile in range(4,16):
                        libtcod.console_set_char_background(self.tconsole, tile, 32, bordercolh2, libtcod.BKGND_SET)
            else:
                for tile in range(4,16):
                    libtcod.console_set_char_background(self.tconsole, tile, 32, buttonback, libtcod.BKGND_SET)

            # Alter Window X/Y/Z

            if (type(self.winc) == int) and handle_mouse('lbutton_pressed'):
                mult = int(pow(10,self.winc))
                self.mconw = min(RMAP_WIDTH,self.mconw + mult)
                self.winc = False
            elif (type(self.wdec) == int) and handle_mouse('lbutton_pressed'):
                mult = int(pow(10,abs(self.wdec)))
                self.mconw = max(10,self.mconw - mult)
                self.wdec = False
            elif (type(self.hinc) == int) and handle_mouse('lbutton_pressed'):
                mult = int(pow(10,self.hinc))
                self.mconh = min(RMAP_HEIGHT,self.mconh + mult)
                self.hinc = False
            elif (type(self.hdec) == int) and handle_mouse('lbutton_pressed'):
                mult = int(pow(10,abs(self.hdec)))
                self.mconh = max(10,self.mconh - mult)
                self.hdec = False
            elif (type(self.zinc) == int) and handle_mouse('lbutton_pressed'):
                mult = int(pow(10,self.zinc))
                self.z = min(99,self.z + mult)
                self.reDraw(redrawbox = False)
                self.zinc = False
            elif (type(self.zdec) == int) and handle_mouse('lbutton_pressed'):
                mult = int(pow(10,abs(self.zdec)))
                self.z = max(0,self.z - mult)
                self.reDraw(redrawbox = False)
                self.zdec = False

            ## FG/BG Color Selection ##
            if [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + 5,self.tcry + 21]:
                if not self.colswitch == 'fore':
                    if handle_mouse('lbutton'):
                        libtcod.console_set_char_foreground(self.tconsole, 5, 21, hcolor)
                    elif handle_mouse('lbutton_pressed'):
                        libtcod.console_set_default_foreground(self.tconsole, bordercol)
                        libtcod.console_print_ex(self.tconsole, 5, 21, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(checked)))
                        libtcod.console_print_ex(self.tconsole, 11, 21, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(unchecked)))
                        libtcod.console_set_char_foreground(self.tconsole, 11, 21, bordercol)
                        libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
                        libtcod.console_set_default_background(self.tconsole, libtcod.black)
                        for x in range(5,8):
                            libtcod.console_print_ex(self.tconsole, x, 16, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                            libtcod.console_print_ex(self.tconsole, x, 17, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                            libtcod.console_print_ex(self.tconsole, x, 18, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                        libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fr))
                        libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fg))
                        libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fb))
                        self.colswitch = 'fore'
                    else:
                        libtcod.console_set_char_foreground(self.tconsole, 5, 21, bordercol)
            elif [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + 11,self.tcry + 21]:
                if not self.colswitch == 'back':
                    if handle_mouse('lbutton'):
                        libtcod.console_set_char_foreground(self.tconsole, 11, 21, hcolor)
                    elif handle_mouse('lbutton_pressed'):
                        libtcod.console_set_default_foreground(self.tconsole, bordercol)
                        libtcod.console_print_ex(self.tconsole, 11, 21, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(checked)))
                        libtcod.console_print_ex(self.tconsole, 5, 21, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(unchecked)))
                        libtcod.console_set_char_foreground(self.tconsole, 5, 21, bordercol)
                        libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
                        libtcod.console_set_default_background(self.tconsole, libtcod.black)
                        for x in range(5,8):
                            libtcod.console_print_ex(self.tconsole, x, 16, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                            libtcod.console_print_ex(self.tconsole, x, 17, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                            libtcod.console_print_ex(self.tconsole, x, 18, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                        libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.br))
                        libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bg))
                        libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bb))
                        self.colswitch = 'back'
                    else:
                        libtcod.console_set_char_foreground(self.tconsole, 11, 21, bordercol)
            
            ## RGB Selector ##
            # Individual Colors            
            # Red      
            if handle_mouse('cx') == self.tcrx + 4 and handle_mouse('cy') == self.tcry + 16:
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 4, 16, bordercol)
                    if self.colswitch == 'fore':
                        self.fr = max(self.fr - 1,0)
                    else:
                        self.br = max(self.br - 1,0)
                    for x in range(5,8):
                        libtcod.console_print_ex(self.tconsole, x, 16, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                    libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
                    if self.colswitch == 'fore':
                        libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fr))
                    else:
                        libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.br))
                    time.sleep(0.02)
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 4, 16, hcolor)
            else:
                libtcod.console_set_char_foreground(self.tconsole, 4, 16, bordercol)
            if handle_mouse('cx') == self.tcrx + 8 and handle_mouse('cy') == self.tcry + 16:
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 8, 16, bordercol)
                    if self.colswitch == 'fore':
                        self.fr = min(self.fr + 1,255)
                    else:
                        self.br = min(self.br + 1,255)
                    for x in range(5,8):
                        libtcod.console_print_ex(self.tconsole, x, 16, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                    libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
                    if self.colswitch == 'fore':
                        libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fr))
                    else:
                        libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.br))
                    time.sleep(0.02)
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 8, 16, hcolor)
            else:
                libtcod.console_set_char_foreground(self.tconsole, 8, 16, bordercol)
            # Green
            if handle_mouse('cx') == self.tcrx + 4 and handle_mouse('cy') == self.tcry + 17:
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 4, 17, bordercol)
                    if self.colswitch == 'fore':
                        self.fg = max(self.fg - 1,0)
                    else:
                        self.bg = max(self.bg - 1,0)
                    for x in range(5,8):
                        libtcod.console_print_ex(self.tconsole, x, 17, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                    libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
                    if self.colswitch == 'fore':
                        libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fg))
                    else:
                        libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bg))
                    time.sleep(0.02)
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 4, 17, hcolor)
            else:
                libtcod.console_set_char_foreground(self.tconsole, 4, 17, bordercol)
            if handle_mouse('cx') == self.tcrx + 8 and handle_mouse('cy') == self.tcry + 17:
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 8, 17, bordercol)
                    if self.colswitch == 'fore':
                        self.fg = min(self.fg + 1,255)
                    else:
                        self.bg = min(self.bg + 1,255)
                    for x in range(5,8):
                        libtcod.console_print_ex(self.tconsole, x, 17, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                    libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
                    if self.colswitch == 'fore':
                        libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fg))
                    else:
                        libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bg))
                    time.sleep(0.02)
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 8, 17, hcolor)
            else:
                libtcod.console_set_char_foreground(self.tconsole, 8, 17, bordercol)
            # Blue
            if handle_mouse('cx') == self.tcrx + 4 and handle_mouse('cy') == self.tcry + 18:
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 4, 18, bordercol)
                    if self.colswitch == 'fore':
                        self.fb = max(self.fb - 1,0)
                    else:
                        self.bb = max(self.bb - 1,0)
                    for x in range(5,8):
                        libtcod.console_print_ex(self.tconsole, x, 18, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                    libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
                    if self.colswitch == 'fore':
                        libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fb))
                    else:
                        libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bb))
                    time.sleep(0.02)
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 4, 18, hcolor)
            else:
                libtcod.console_set_char_foreground(self.tconsole, 4, 18, bordercol)
            if handle_mouse('cx') == self.tcrx + 8 and handle_mouse('cy') == self.tcry + 18:
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 8, 18, bordercol)
                    if self.colswitch == 'fore':
                        self.fb = min(self.fb + 1,255)
                    else:
                        self.bb = min(self.bb + 1,255)
                    for x in range(5,8):
                        libtcod.console_print_ex(self.tconsole, x, 18, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                    libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
                    if self.colswitch == 'fore':
                        libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fb))
                    else:
                        libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bb))
                    time.sleep(0.02)
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 8, 18, hcolor)
            else:
                libtcod.console_set_char_foreground(self.tconsole, 8, 18, bordercol)

            # Lightening/Darkening

            for num in range(3):
                # Top Row - Lightening
                if [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 5,self.tcry + 15] and handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 5 + num, 15, bordercol)
                    self.cinc = 2 - num
                elif [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 5,self.tcry + 15]:
                    libtcod.console_set_char_foreground(self.tconsole, 5 + num, 15, hcolor)
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 5 + num, 15, bordercol)
                # Bottom Row - Darkening
                if [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 5,self.tcry + 19] and handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 5 + num, 19, bordercol)
                    self.cdec = 2 - num
                elif [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + num + 5,self.tcry + 19]:
                    libtcod.console_set_char_foreground(self.tconsole, 5 + num, 19, hcolor)
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 5 + num, 19, bordercol)

            # Print RGB Square
            if (type(self.cinc) == int) and handle_mouse('lbutton_pressed'):
                mult = int(pow(10,self.cinc))
                if self.colswitch == 'fore':
                    self.fr = min(255,self.fr + mult)
                    self.fg = min(255,self.fg + mult)
                    self.fb = min(255,self.fb + mult)
                else:
                    self.br = min(255,self.br + mult)
                    self.bg = min(255,self.bg + mult)
                    self.bb = min(255,self.bb + mult)                   
                for y in range(16,19):
                    for x in range(5,8):
                        libtcod.console_print_ex(self.tconsole, x, y, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
                if self.colswitch == 'fore':
                    libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fr))
                    libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fg))
                    libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fb))
                else:
                    libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.br))
                    libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bg))
                    libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bb))
                self.cinc = False
            elif (type(self.cdec) == int) and handle_mouse('lbutton_pressed'):
                mult = int(pow(10,abs(self.cdec)))
                if self.colswitch == 'fore':
                    self.fr = max(0,self.fr - mult)
                    self.fg = max(0,self.fg - mult)
                    self.fb = max(0,self.fb - mult)
                else:
                    self.br = max(0,self.br - mult)
                    self.bg = max(0,self.bg - mult)
                    self.bb = max(0,self.bb - mult)
                for y in range(16,19):
                    for x in range(5,8):
                        libtcod.console_print_ex(self.tconsole, x, y, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
                if self.colswitch == 'fore':
                    libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fr))
                    libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fg))
                    libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fb))
                else:
                    libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.br))
                    libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bg))
                    libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bb))
                self.cdec = False
            if self.colswitch == 'fore':
                RGB = libtcod.Color(self.fr,self.fg,self.fb)
            else:
                RGB = libtcod.Color(self.br,self.bg,self.bb)
            libtcod.console_set_default_foreground(self.tconsole, RGB)
            for x in range(12,15):
                for y in range(16,19):
                    libtcod.console_print_ex(self.tconsole, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(blankchar)))

            ## Tile Switching ##
            if [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + 2,self.tcry + 24]:
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 2, 24, bordercol)
                    self.changetile = True
                elif handle_mouse('lbutton_pressed') and self.changetile:
                    self.curnum = max(0,self.curnum - 1)
                    libtcod.console_set_default_background(self.tconsole, libtcod.black)
                    for tile in range(3,17):
                        libtcod.console_print_ex(self.tconsole, tile, 23, libtcod.BKGND_SET, libtcod.LEFT, ' ')
                        libtcod.console_print_ex(self.tconsole, tile, 24, libtcod.BKGND_SET, libtcod.LEFT, ' ')
                        libtcod.console_print_ex(self.tconsole, tile, 25, libtcod.BKGND_SET, libtcod.LEFT, ' ')
                    buildtype = GameWorld.builddict[GameWorld.buildtypes[self.typenum]]
                    keylist = GameWorld.builddict[GameWorld.buildtypes[self.typenum]].keys()
                    keylist.sort()
                    key = keylist[self.curnum]
                    self.curentry = GameWorld.builddict[GameWorld.buildtypes[self.typenum]][key]
                    tmat = self.curentry['MATERIALS'][0]
                    tcol2 = libtcod.Color(int(GameWorld.matstruct[tmat]['COLOR'][0]),int(GameWorld.matstruct[tmat]['COLOR'][1]), \
                                         int(GameWorld.matstruct[tmat]['COLOR'][2]))
                    tcol = libtcod.white
##                    if buildtype == 'floor' or buildtype == 'ceiling':
##                        tcol = tcol / 2
                    self.fr,self.fg,self.fb = tcol.r,tcol.g,tcol.b
                    self.br,self.bg,self.bb = tcol2.r,tcol2.g,tcol2.b
                    for y in range(16,19):
                        for x in range(5,8):
                            libtcod.console_print_ex(self.tconsole, x, y, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                    libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
                    if self.colswitch == 'fore':
                        libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fr))
                        libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fg))
                        libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fb))
                    else:
                        libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.br))
                        libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bg))
                        libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bb))
                    self.changetile = False
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 2, 24, hcolor)
            else:
                libtcod.console_set_char_foreground(self.tconsole, 2, 24, bordercol)
            if [handle_mouse('cx'),handle_mouse('cy')] == [self.tcrx + 17,self.tcry + 24]:
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.tconsole, 17, 24, bordercol)
                    self.changetile = True
                elif handle_mouse('lbutton_pressed') and self.changetile:
                    maxnum = len(GameWorld.builddict[GameWorld.buildtypes[self.typenum]].keys()) - 1
                    self.curnum = min(maxnum,self.curnum + 1)
                    libtcod.console_set_default_background(self.tconsole, libtcod.black)
                    for tile in range(3,17):
                        libtcod.console_print_ex(self.tconsole, tile, 23, libtcod.BKGND_SET, libtcod.LEFT, ' ')
                        libtcod.console_print_ex(self.tconsole, tile, 24, libtcod.BKGND_SET, libtcod.LEFT, ' ')
                        libtcod.console_print_ex(self.tconsole, tile, 25, libtcod.BKGND_SET, libtcod.LEFT, ' ')
                    buildtype = GameWorld.builddict[GameWorld.buildtypes[self.typenum]]
                    keylist = GameWorld.builddict[GameWorld.buildtypes[self.typenum]].keys()
                    keylist.sort()
                    key = keylist[self.curnum]
                    self.curentry = GameWorld.builddict[GameWorld.buildtypes[self.typenum]][key]
                    tmat = self.curentry['MATERIALS'][0]
                    tcol2 = libtcod.Color(int(GameWorld.matstruct[tmat]['COLOR'][0]),int(GameWorld.matstruct[tmat]['COLOR'][1]), \
                                         int(GameWorld.matstruct[tmat]['COLOR'][2]))
                    tcol = libtcod.white
##                    if buildtype == 'floor' or buildtype == 'ceiling':
##                        tcol = tcol / 2
                    self.fr,self.fg,self.fb = tcol.r,tcol.g,tcol.b
                    self.br,self.bg,self.bb = tcol2.r,tcol2.g,tcol2.b
                    for y in range(16,19):
                        for x in range(5,8):
                            libtcod.console_print_ex(self.tconsole, x, y, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                    libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
                    if self.colswitch == 'fore':
                        libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fr))
                        libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fg))
                        libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fb))
                    else:
                        libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.br))
                        libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bg))
                        libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bb))
                    self.changetile = False
                else:
                    libtcod.console_set_char_foreground(self.tconsole, 17, 24, hcolor)
            else:
                libtcod.console_set_char_foreground(self.tconsole, 17, 24, bordercol)

            # Print Tiles
            keylist = GameWorld.builddict[GameWorld.buildtypes[self.typenum]].keys()
            keylist.sort()
            key = keylist[self.curnum]
            self.curentry = GameWorld.builddict[GameWorld.buildtypes[self.typenum]][key]
            chars = self.curentry['CHARS']
            entryname = textWrap(key, 14)[0]
            libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
            libtcod.console_print_ex(self.tconsole, 10, 24, libtcod.BKGND_NONE, libtcod.CENTER, entryname)
            for tile in range(14):
                if len(chars) > tile:
                    char = [chars[tile][0],chars[tile][1],189]
                    fg = libtcod.Color(self.fr,self.fg,self.fb)
                    bg = libtcod.Color(self.br,self.bg,self.bb)
                    libtcod.console_set_default_foreground(self.tconsole, fg)
                    libtcod.console_set_default_background(self.tconsole, bg)
                    if not 'NOBG' in self.curentry.keys():
                        libtcod.console_print_ex(self.tconsole, 3 + tile, 23, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                    else:
                        libtcod.console_print_ex(self.tconsole, 3 + tile, 23, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))

            ## Now for the actual construction window stuff. ##

            if handle_mouse('cx') > self.rx and handle_mouse('cx') < self.rx + self.conw - 1 and \
               handle_mouse('cy') > self.ry and handle_mouse('cy') < self.ry + self.conh - 1:
                if (hasattr(self, 'HBar') and handle_mouse('cx') == self.rx + self.conw - 2) or \
                   (hasattr(self, 'WBar') and handle_mouse('cy') == self.ry + self.conh - 2):
                    self.initcoords = False
                elif handle_mouse('lbutton') and globals()['key'].lctrl:
                    xplus,yplus = 0,0
                    if hasattr(self, 'WBar'):
                        xplus = self.WBar.inc
                    if hasattr(self, 'HBar'):
                        yplus = self.HBar.inc
                    actx = handle_mouse('cx') - self.rx
                    acty = handle_mouse('cy') - self.ry
                    gridx = actx - 1 + xplus
                    gridy = acty - 1 + yplus
                    if self.congrid[self.z].get('%s,%s' % (gridx,gridy)):
                        tile = self.congrid[self.z]['%s,%s' % (gridx,gridy)]
                        buildtype = tile[0]
                        key = tile[1]
                        char = self.getTile(gridx,gridy,self.z)
                        fg = tile[3]
                        bg = tile[4]
                        if self.colswitch == 'fore':
                            self.fr,self.fg,self.fb = fg.r,fg.g,fg.b
                        else:
                            if bg:
                                self.br,self.bg,self.bb = bg.r,bg.g,bg.b
                        for y in range(16,19):
                            for x in range(5,8):
                                libtcod.console_print_ex(self.tconsole, x, y, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                        libtcod.console_set_default_foreground(self.tconsole, libtcod.white)
                        if self.colswitch == 'fore':
                            libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fr))
                            libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fg))
                            libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.fb))
                        else:
                            libtcod.console_print_ex(self.tconsole, 7, 16, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.br))
                            libtcod.console_print_ex(self.tconsole, 7, 17, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bg))
                            libtcod.console_print_ex(self.tconsole, 7, 18, libtcod.BKGND_NONE, libtcod.RIGHT, str(self.bb))
                    self.noclick = True
                elif handle_mouse('lbutton') and not self.noclick:
                    xplus = 0
                    yplus = 0
                    if hasattr(self, 'WBar'):
                        xplus = self.WBar.inc
                    if hasattr(self, 'HBar'):
                        yplus = self.HBar.inc
                    actx = handle_mouse('cx') - self.rx
                    acty = handle_mouse('cy') - self.ry
                    gridx = actx - 1 + xplus
                    gridy = acty - 1 + yplus
                    buildtype = GameWorld.buildtypes[self.typenum]
                    keylist = GameWorld.builddict[GameWorld.buildtypes[self.typenum]].keys()
                    keylist.sort()
                    key = keylist[self.curnum]
                    self.curentry = GameWorld.builddict[GameWorld.buildtypes[self.typenum]][key]
                    chars = self.curentry['CHARS']
                    fg = libtcod.Color(self.fr,self.fg,self.fb)
                    if not self.initcoords:
                        self.initcoords = [gridx,gridy]
                    if self.initcoords[0] > gridx:
                        lx,sx = self.initcoords[0],gridx
                    else:
                        lx,sx = gridx,self.initcoords[0]
                    if self.initcoords[1] > gridy:
                        ly,sy = self.initcoords[1],gridy
                    else:
                        ly,sy = gridy,self.initcoords[1]
                    
                    for gx in range(sx,lx + 1):
                        for gy in range(sy,ly + 1):
                            nax = gx + 1 - xplus
                            nay = gy + 1 - yplus
                            if self.curentry.get('NOBG'):
                                bg = None
                                if self.congrid[self.z].get('%s,%s' % (gx,gy)):
                                    if self.congrid[self.z]['%s,%s' % (gx,gy)][4]:
                                        bg = self.congrid[self.z]['%s,%s' % (gx,gy)][4]
                            else:
                                bg = libtcod.Color(self.br,self.bg,self.bb)
                            skip = False
                            oldtile = False
                            if self.congrid[self.z].get('%s,%s' % (gx,gy)):
                                oldtile = self.congrid[self.z]['%s,%s' % (gx,gy)]
                                if self.congrid[self.z]['%s,%s' % (gx,gy)][:5] == [buildtype,key,chars,fg,bg]:
                                    skip = True
                            if not skip:
                                if buildtype == 'door' and oldtile:
                                    if oldtile[0] == 'floor':
                                        oldtile[2] = self.getTile(gx,gy,self.z)
                                        self.congrid[self.z]['%s,%s' % (gx,gy)] = [buildtype,key,chars,fg,bg,oldtile]
                                    else:
                                        self.congrid[self.z]['%s,%s' % (gx,gy)] = [buildtype,key,chars,fg,bg]
                                else:
                                    self.congrid[self.z]['%s,%s' % (gx,gy)] = [buildtype,key,chars,fg,bg]
                                self.contiles.append((self.z,gx,gy))
                                if self.conskip[self.z].get('%s,%s' % (gx,gy)):
                                    self.conskip[self.z].pop('%s,%s' % (gx,gy))
                    for gx in range(sx,lx + 1):
                        for gy in range(sy,ly + 1):
                            self.reDrawTile(gx,gy,lx,sx,ly,sy,xplus,yplus)
                            for num in range(-1,2):
                                for num2 in range(-1,2):
                                    if (num,num2) == (0,0):
                                        continue
                                    if nax + num in [-1,self.conw] or \
                                       nay + num2 in [-1,self.conh] or \
                                       nax + num  == self.conw - self.xoff or \
                                       nay + num2 == self.conh - self.yoff:
                                        continue
                                    if buildtype != 'roof':
                                        self.reDrawTile(gx + num,gy + num2,lx,sx,ly,sy,xplus,yplus)         
                elif handle_mouse('lbutton_pressed'):
                    self.initcoords = False
                    self.noclick = False
                elif handle_mouse('rbutton'):
                    xplus = 0
                    yplus = 0
                    if hasattr(self, 'WBar'):
                        xplus = self.WBar.inc
                    if hasattr(self, 'HBar'):
                        yplus = self.HBar.inc
                    actx = handle_mouse('cx') - self.rx
                    acty = handle_mouse('cy') - self.ry
                    gridx = actx - 1 + xplus
                    gridy = acty - 1 + yplus
                    if not self.initcoords:
                        self.initcoords = [gridx,gridy]
                    if self.initcoords[0] > gridx:
                        lx,sx = self.initcoords[0],gridx
                    else:
                        lx,sx = gridx,self.initcoords[0]
                    if self.initcoords[1] > gridy:
                        ly,sy = self.initcoords[1],gridy
                    else:
                        ly,sy = gridy,self.initcoords[1]
                    for gx in range(sx,lx + 1):
                        for gy in range(sy,ly + 1):
                            nax = gx + 1 - xplus
                            nay = gy + 1 - yplus
                            try:
                                self.congrid[self.z].pop('%s,%s' % (gx,gy))
                                self.conskip[self.z].pop('%s,%s' % (gx,gy))
                            except KeyError:
                                pass
                            try:
                                self.contiles.remove((self.z,gx,gy))
                            except ValueError:
                                pass
                            try:
                                self.congrid[self.z - 1]['%s,%s' % (gx,gy)]
                            except KeyError:
                                libtcod.console_print_ex(self.cconsole, nax, nay, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                                libtcod.console_set_char_background(self.cconsole, nax, nay, libtcod.black, libtcod.BKGND_SET)
                            try:
                                if self.congrid[self.z - 1].get('%s,%s' % (gx,gy)):
                                    tile = self.congrid[self.z - 1]['%s,%s' % (gx,gy)]
                                    buildtype = tile[0]
                                    key = tile[1]
                                    self.curentry = GameWorld.builddict[buildtype][key]
                                    if buildtype == 'wall':
                                        char = self.getTile(gx,gy,self.z - 1)
                                        fg = tile[3]
                                        bg = tile[4]
                                        libtcod.console_set_default_foreground(self.cconsole, fg)
                                        libtcod.console_set_default_background(self.cconsole, fg)
                                        char[2] = 189
                                        libtcod.console_print_ex(self.cconsole, nax, nay, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                                    elif buildtype == 'stairs' or buildtype == 'ladder':
                                        char = [tile[2][1][0],tile[2][1][1],189]
                                        fg = tile[3]
                                        bg = tile[4]
                                        libtcod.console_set_default_foreground(self.cconsole, fg)
                                        libtcod.console_set_default_background(self.cconsole, bg)
                                        char[2] = 189
                                        libtcod.console_print_ex(self.cconsole, nax, nay, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))                                
                                    else:
                                        char = self.getTile(gx,gy,self.z - 1)
                                        fg = libtcod.color_lerp(tile[3], libtcod.black, 0.75)
                                        if tile[4]:
                                            bg = libtcod.color_lerp(tile[4], libtcod.black, 0.75)
                                        else:
                                            bg = tile[4]
                                        libtcod.console_set_default_foreground(self.cconsole, fg)
                                        char[2] = 189
                                        if bg:
                                            libtcod.console_set_default_background(self.cconsole, bg)
                                            libtcod.console_print_ex(self.cconsole, nax, nay, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                                        else:
                                            libtcod.console_print_ex(self.cconsole, nax, nay, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                            except KeyError:
                                pass
                elif handle_mouse('rbutton_pressed'):
                    self.initcoords = False
                    self.reDraw(redrawbox = False)
            else:
                self.initcoords = False
            lock.release()

    def reDrawTile(self,gx,gy,lx,sx,ly,sy,xplus,yplus):
        nax = gx + 1 - xplus
        nay = gy + 1 - yplus
        if self.congrid[self.z].get('%s,%s' % (gx,gy)):
            tile = self.congrid[self.z]['%s,%s' % (gx,gy)]
            chars = tile[2]
            buildtype = tile[0]
            key = tile[1]
            randbuildtypes = ['floor'] 
            if buildtype in randbuildtypes:
                if not self.otilegrid.get('%s,%s,%s' % (gx,gy,self.z)):
                    char = self.getTile(gx,gy,self.z)
                    self.otilegrid['%s,%s,%s' % (gx,gy,self.z)] = [key,char]
                else:
                    okey = self.otilegrid['%s,%s,%s' % (gx,gy,self.z)][0]
                    if okey == key:
                        char = self.otilegrid['%s,%s,%s' % (gx,gy,self.z)][1]
                    else:
                        char = self.getTile(gx,gy,self.z)
                        self.otilegrid['%s,%s,%s' % (gx,gy,self.z)] = [key,char]
            else:
                char = self.getTile(gx,gy,self.z)
                try:
                    self.otilegrid.pop('%s,%s,%s' % (gx,gy,self.z))
                except KeyError:
                    pass
            fg = tile[3]
            bg = tile[4]
            self.curentry = GameWorld.builddict[buildtype][key]
            if buildtype == 'roof':
                xmidpoint = ((lx + 1 - sx) * .5) + sx
                ymidpoint = ((ly + 1 - sy) * .5) + sy
                rfg = fg
                rbg = bg
                if self.curentry['SHADOW'][0] == 'quad':
                    xyratio = ((ly + 1 - sy) * 1.0) / ((lx + 1 - sx) * 1.0)
                    yxratio = ((lx + 1 - sx) * 1.0) / ((ly + 1 - sy) * 1.0)
                    if gy >= ymidpoint and abs(xmidpoint - gx) <= (abs(ymidpoint - gy) * yxratio):
                        rfg = libtcod.color_lerp(fg, libtcod.black, 0.5)
                        if bg:
                            rbg = libtcod.color_lerp(bg, libtcod.black, 0.5)
                    elif gx < xmidpoint and abs(ymidpoint - gy) < (abs(xmidpoint - gx) * xyratio):
                        rfg = libtcod.color_lerp(fg, libtcod.black, 0.3)
                        if bg:
                            rbg = libtcod.color_lerp(bg, libtcod.black, 0.3)
                    elif gx > xmidpoint and abs(ymidpoint - gy) <= (abs(xmidpoint - gx) * xyratio):
                        rfg = libtcod.color_lerp(fg, libtcod.black, 0.1)
                        if bg:
                            rbg = libtcod.color_lerp(bg, libtcod.black, 0.1)
                elif self.curentry['SHADOW'][0] == 'vertical':
                    if gy >= ymidpoint:
                        rfg = libtcod.color_lerp(fg, libtcod.black, 0.5)
                        if bg:
                            rbg = libtcod.color_lerp(bg, libtcod.black, 0.5)
                elif self.curentry['SHADOW'][0] == 'horizontal':
                    if gx < xmidpoint:
                        rfg = libtcod.color_lerp(fg, libtcod.black, 0.3)
                        if bg:
                            rbg = libtcod.color_lerp(bg, libtcod.black, 0.3)
                    else:
                        rfg = libtcod.color_lerp(fg, libtcod.black, 0.1)
                        if bg:
                            rbg = libtcod.color_lerp(bg, libtcod.black, 0.1)
                self.congrid[self.z]['%s,%s' % (gx,gy)] = [buildtype,key,chars,fg,bg,rfg,rbg]
                fg = rfg
                bg = rbg
            libtcod.console_set_default_foreground(self.cconsole, fg)
            char[2] = 189
            if bg:
                libtcod.console_set_default_background(self.cconsole, bg)
                libtcod.console_print_ex(self.cconsole, nax, nay, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
            else:
                libtcod.console_print_ex(self.cconsole, nax, nay, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))

    def doSave(self):
        global XConsoles, killkeycheck, lock
        killkeycheck = True
        time.sleep(0.1)
        self.savewindow = libtcod.console_new(24,30)
        libtcod.console_set_default_background(self.savewindow, bgcolor)
        libtcod.console_clear(self.savewindow)
        DrawBox(self.savewindow, 0, 0, 23, 29, 1, bordercol, bordercol2)
        DrawBox(self.savewindow, 2, 2, 19, 2, 0, libtcod.darker_azure, btype = 'thin')
        DrawBox(self.savewindow, 2, 10, 19, 17, 0, bordercol, bordercol, btype = 'thin')
        DrawBox(self.savewindow, 4, 6, 5, 2, 0, bordercol, libtcod.desaturated_red, btype = 'thin')
        DrawBox(self.savewindow, 12, 6, 7, 2, 0, bordercol, libtcod.desaturated_red, btype = 'thin')
        libtcod.console_set_default_foreground(self.savewindow, hcolor2)
        libtcod.console_print_ex(self.savewindow, 5, 7, libtcod.BKGND_NONE, libtcod.LEFT, 'Save')
        libtcod.console_print_ex(self.savewindow, 13, 7, libtcod.BKGND_NONE, libtcod.LEFT, 'Delete')

        libtcod.console_set_default_foreground(self.savewindow, libtcod.gold)
        libtcod.console_set_default_background(self.savewindow, libtcod.black)
        libtcod.console_print_ex(self.savewindow, 22, 0, libtcod.BKGND_SET, libtcod.LEFT, 'X')
        for x in range(3,21):
            for y in range(11,27):
                libtcod.console_set_char_background(self.savewindow, x, y, libtcod.black, libtcod.BKGND_SET)
        for x in range(3,20):
            libtcod.console_set_char_background(self.savewindow, x, 11, libtcod.darker_azure, libtcod.BKGND_SET)
        for tile in range(3,21):
            libtcod.console_set_char_background(self.savewindow, tile, 3, libtcod.black, libtcod.BKGND_SET)
        srx = (SCREEN_WIDTH - VIEW_WIDTH - 2) + (VIEW_WIDTH / 2) - 12
        sry = 1 + (VIEW_HEIGHT / 2) - 15
        self.sconlist = [self.savewindow,0,0,24,30,srx,sry,1.0,1.0]
        XConsoles = [self.sconlist]
        savestr = ''
        lasttime = time.time() - 0.3
        oldkey = 0
        self.SBar = ScrollBar(self.savewindow, 20, 11, 16, srx + 20, sry + 11, arrowcolor = bordercolh2,
                         bgcolor = bgcolor2, hcolor = globals()['hcolor'])
        blist = os.listdir('.\\data\\blueprint')
        blist = filter(lambda x: x[-4:] == '.blp', blist)
        self.SBar.max = max(len(blist) - 16,0)
        oldkey = 0
        curswitch = False
        save = False
        redo = False
        self.holdloop = False
        self.overwrite = False
        self.delete = False
        oinc = self.SBar.inc
        selectnum = 0
        invalid = ['[',']','/','\\','=','+','<','>',':',';','"',',','*','.']
        blueprint = [self.mconw,self.mconh,self.congrid,self.conskip,self.contiles]
        bluelist = ['*NEW BLUEPRINT*']
        for blue in blist:
            bluelist.append(blue[:-4])
        libtcod.console_set_default_foreground(self.savewindow, libtcod.white)
        for blue in range(len(bluelist))[:16]:
            libtcod.console_print_ex(self.savewindow, 11, 11 + blue, libtcod.BKGND_NONE, libtcod.CENTER, bluelist[blue])
        while True:
            if self.holdloop:
                time.sleep(0.1)
                continue
            elif self.overwrite:
                savestr = savestr.strip(' ')
                bpfile = open('.\\data\\blueprint\\%s.blp' % savestr, 'wb')
                gc.disable()
                cPickle.dump(blueprint, bpfile, -1)
                gc.enable()
                bpfile.close()
                GameWorld.addMesg('Blueprint  \'%s\' overwritten successfully.' % savestr)
                break
            elif self.delete:
                delFile('.\\data\\blueprint\\%s.blp' % bluelist[selectnum])
                GameWorld.addMesg('Blueprint  \'%s\' deleted.' % bluelist[selectnum])
                break
            newkey = key.c
            stimer = (time.time() - lasttime)
            if key.vk == libtcod.KEY_ESCAPE and stimer >= 0.05:
                if len(savestr) > 0:
                    savestr = savestr[:-1]
                for tile in range(3 + len(savestr),21):
                    libtcod.console_print_ex(self.savewindow, tile, 3, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                lock.acquire()
                libtcod.console_set_default_foreground(self.savewindow, libtcod.white)
                libtcod.console_print_ex(self.savewindow, 3, 3, libtcod.BKGND_NONE, libtcod.LEFT, savestr)
                lock.release()
                lasttime = time.time()
            elif newkey and stimer >= 0.05:
                if newkey == oldkey and stimer < 0.2:
                    continue
                if len(savestr) == 18:
                    continue
                savestr += chr(key.c)
                lock.acquire()
                libtcod.console_set_default_foreground(self.savewindow, libtcod.white)
                libtcod.console_print_ex(self.savewindow, 3, 3, libtcod.BKGND_NONE, libtcod.LEFT, savestr)
                lock.release()
                lasttime = time.time()
                oldkey = newkey
            elif not key.pressed:
                lasttime = time.time() - 0.18
            lock.acquire()
            if time.time() % 1.0 > .5 and len(savestr) < 18 and not curswitch:
                libtcod.console_set_default_foreground(self.savewindow, libtcod.white)
                libtcod.console_print_ex(self.savewindow, 3 + len(savestr), 3, libtcod.BKGND_NONE, libtcod.LEFT, '|')
                curswitch = True
            elif time.time() % 1.0 < .5 and len(savestr) < 18 and curswitch:
                libtcod.console_print_ex(self.savewindow, 3 + len(savestr), 3, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                curswitch = False
            lock.release()
            if self.SBar.inc != oinc or redo:
                lock.acquire()
                for tile in range(3 + len(savestr),21):
                    libtcod.console_print_ex(self.savewindow, tile, 3, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                libtcod.console_set_default_foreground(self.savewindow, libtcod.white)
                libtcod.console_print_ex(self.savewindow, 3, 3, libtcod.BKGND_NONE, libtcod.LEFT, savestr)
                for y in range(11,27):
                    for x in range(3,20):
                        libtcod.console_set_char_background(self.savewindow, x, y, libtcod.black, libtcod.BKGND_SET)
                libtcod.console_set_default_foreground(self.savewindow, libtcod.white)
                for blue in range(len(bluelist))[self.SBar.inc:16 + self.SBar.inc]:
                    for x in range(3,20):
                        libtcod.console_print_ex(self.savewindow, x, 11 + blue - self.SBar.inc, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                    libtcod.console_print_ex(self.savewindow, 11, 11 + blue - self.SBar.inc, libtcod.BKGND_NONE, libtcod.CENTER, bluelist[blue])
                if selectnum in range(len(bluelist))[self.SBar.inc:16 + self.SBar.inc]:
                    for x in range(3,20):
                        libtcod.console_set_char_background(self.savewindow, x, 11 + selectnum - self.SBar.inc, libtcod.darker_azure, libtcod.BKGND_SET)
                redo = False
                lock.release()
            lock.acquire()
            if handle_mouse('cx') in range(srx + 5,srx + 9) and handle_mouse('cy') == sry + 7:
                if handle_mouse('lbutton'):
                    for tile in range(5,9):
                        libtcod.console_set_char_background(self.savewindow, tile, 7, libtcod.darker_flame, libtcod.BKGND_SET)
                    save = True
                elif handle_mouse('lbutton_pressed') and save:
                    time.sleep(0.1)
                    if len(savestr) > 0:
                        killsave = False
                        for char in savestr:
                            if char in invalid:
                                killsave = True
                        if not killsave:
                            skip = False
                            for blue in bluelist:
                                if savestr == blue:
                                    self.holdloop = True
                                    lock.release()
                                    SWindow = Dialogue([('Yes',throwSwitches,self,['holdloop','overwrite']),('No',throwSwitches,self,['holdloop'])],title = 'Overwrite \'%s\'?' % savestr)
                                    SWindow.start()
                                    skip = True
                            if skip:
                                continue
                            savestr = savestr.strip(' ')
                            bpfile = open('.\\data\\blueprint\\%s.blp' % savestr, 'wb')
                            GameWorld.addMesg('Blueprint \'%s\' saved successfully.' % savestr)
                            gc.disable()
                            cPickle.dump(blueprint, bpfile, -1)
                            gc.enable()
                            bpfile.close()
                            lock.release()
                            break
                    save = False
                else:
                    for tile in range(5,9):
                        libtcod.console_set_char_background(self.savewindow, tile, 7, bordercol2, libtcod.BKGND_SET)
            else:
                for tile in range(5,9):
                    libtcod.console_set_char_background(self.savewindow, tile, 7, libtcod.darker_azure, libtcod.BKGND_SET)
            if handle_mouse('cx') in range(srx + 13,srx + 19) and handle_mouse('cy') == sry + 7:
                if handle_mouse('lbutton'):
                    for tile in range(13,19):
                        libtcod.console_set_char_background(self.savewindow, tile, 7, libtcod.darker_flame, libtcod.BKGND_SET)
                    delete = True
                elif handle_mouse('lbutton_pressed') and delete:
                    time.sleep(0.1)
                    if selectnum != 0:
                        self.holdloop = True
                        lock.release()
                        DWindow = Dialogue([('Yes',throwSwitches,self,['holdloop','delete']),('No',throwSwitches,self,['holdloop'])],title = 'Delete \'%s\'?' % bluelist[selectnum])
                        DWindow.start()
                        continue
                else:
                    for tile in range(13,19):
                        libtcod.console_set_char_background(self.savewindow, tile, 7, bordercol2, libtcod.BKGND_SET)
            else:
                for tile in range(13,19):
                    libtcod.console_set_char_background(self.savewindow, tile, 7, libtcod.darker_azure, libtcod.BKGND_SET)
            lock.release()
            if handle_mouse('cx') in range(srx + 3,srx + 20) and handle_mouse('cy') in range(sry + 11,sry + 27):
                if handle_mouse('lbutton'):
                    try:
                        bluelist[handle_mouse('cy') - sry - 11 + self.SBar.inc]
                        selectnum = handle_mouse('cy') - sry - 11 + self.SBar.inc
                        savestr = bluelist[selectnum]
                        if savestr == '*NEW BLUEPRINT*':
                            savestr = ''
                        redo = True
                    except IndexError:
                        pass
            if [handle_mouse('cx'),handle_mouse('cy')] == [srx + 22,sry]:
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_background(self.savewindow, 22, 0, libtcod.sky, libtcod.BKGND_SET)
                elif handle_mouse('lbutton_pressed'):
                    time.sleep(0.1)
                    libtcod.console_set_char_background(self.savewindow, 22, 0, libtcod.black, libtcod.BKGND_SET)
                    break
            oinc = self.SBar.inc
                
        XConsoles = [self.conlist,self.tconlist]
        self.SBar.killswitch = True
        del self.SBar
        libtcod.console_delete(self.savewindow)
        killkeycheck = False
        self.passloop = False

    def doLoad(self):
        global XConsoles, killkeycheck, lock
        killkeycheck = True
        time.sleep(0.1)
        self.loadwindow = libtcod.console_new(24,30)
        libtcod.console_set_default_background(self.loadwindow, bgcolor)
        libtcod.console_clear(self.loadwindow)
        DrawBox(self.loadwindow, 0, 0, 23, 29, 1, bordercol, bordercol2)
        DrawBox(self.loadwindow, 2, 6, 19, 21, 0, bordercol, bordercol, btype = 'thin')
        DrawBox(self.loadwindow, 4, 2, 5, 2, 0, bordercol, libtcod.desaturated_red, btype = 'thin')
        DrawBox(self.loadwindow, 12, 2, 7, 2, 0, bordercol, libtcod.desaturated_red, btype = 'thin')
        libtcod.console_set_default_foreground(self.loadwindow, hcolor2)
        libtcod.console_print_ex(self.loadwindow, 5, 3, libtcod.BKGND_NONE, libtcod.LEFT, 'Load')
        libtcod.console_print_ex(self.loadwindow, 13, 3, libtcod.BKGND_NONE, libtcod.LEFT, 'Delete')

        libtcod.console_set_default_foreground(self.loadwindow, libtcod.gold)
        libtcod.console_set_default_background(self.loadwindow, libtcod.black)
        libtcod.console_print_ex(self.loadwindow, 22, 0, libtcod.BKGND_SET, libtcod.LEFT, 'X')
        for x in range(3,21):
            for y in range(7,27):
                libtcod.console_set_char_background(self.loadwindow, x, y, libtcod.black, libtcod.BKGND_SET)
        for x in range(3,20):
            libtcod.console_set_char_background(self.loadwindow, x, 7, libtcod.darker_azure, libtcod.BKGND_SET)
        srx = (SCREEN_WIDTH - VIEW_WIDTH - 2) + (VIEW_WIDTH / 2) - 12
        sry = 1 + (VIEW_HEIGHT / 2) - 15
        self.lconlist = [self.loadwindow,0,0,24,30,srx,sry,1.0,1.0]
        XConsoles = [self.lconlist]
        LBar = ScrollBar(self.loadwindow, 20, 7, 20, srx + 20, sry + 7, arrowcolor = bordercolh2, \
                         bgcolor = bgcolor2, hcolor = globals()['hcolor'])
        blist = os.listdir('.\\data\\blueprint')
        blist = filter(lambda x: x[-4:] == '.blp', blist)
        LBar.max = max(len(blist) - 20,0)
        curswitch = False
        redo = False
        load = False
        delete = False
        self.holdloop = False
        self.delete = False
        oinc = LBar.inc
        selectnum = 0
        bluelist = []
        for blue in blist:
            bluelist.append(blue[:-4])
        if len(bluelist) == 0:
            bluelist.append('-NO BLUEPRINTS-')
        libtcod.console_set_default_foreground(self.loadwindow, libtcod.white)
        for blue in range(len(bluelist))[:20]:
            libtcod.console_print_ex(self.loadwindow, 11, 7 + blue, libtcod.BKGND_NONE, libtcod.CENTER, bluelist[blue])

        while True:
            if self.holdloop:
                time.sleep(0.1)
                continue
            elif self.delete:
                delFile('.\\data\\blueprint\\%s.blp' % bluelist[selectnum])
                GameWorld.addMesg('Blueprint  \'%s\' deleted.' % bluelist[selectnum])
                break
            if LBar.inc != oinc or redo:
                lock.acquire()
                for y in range(7,27):
                    for x in range(3,20):
                        libtcod.console_set_char_background(self.loadwindow, x, y, libtcod.black, libtcod.BKGND_SET)
                libtcod.console_set_default_foreground(self.loadwindow, libtcod.white)
                for blue in range(len(bluelist))[LBar.inc:20 + LBar.inc]:
                    for x in range(3,20):
                        libtcod.console_print_ex(self.loadwindow, x, 7 + blue - LBar.inc, libtcod.BKGND_NONE, libtcod.LEFT, ' ')
                    libtcod.console_print_ex(self.loadwindow, 11, 7 + blue - LBar.inc, libtcod.BKGND_NONE, libtcod.CENTER, bluelist[blue])
                if selectnum in range(len(bluelist))[LBar.inc:20 + LBar.inc]:
                    for x in range(3,20):
                        libtcod.console_set_char_background(self.loadwindow, x, 7 + selectnum - LBar.inc, libtcod.darker_azure, libtcod.BKGND_SET)
                redo = False
                lock.release()
            lock.acquire()
            if handle_mouse('cx') in range(srx + 5,srx + 9) and handle_mouse('cy') == sry + 3:
                if handle_mouse('lbutton'):
                    for tile in range(5,9):
                        libtcod.console_set_char_background(self.loadwindow, tile, 3, libtcod.darker_flame, libtcod.BKGND_SET)
                    load = True
                elif handle_mouse('lbutton_pressed') and load:
                    time.sleep(0.1)
                    bluepath = open('.\\data\\blueprint\\%s' % bluelist[selectnum] + '.blp','rb')
                    gc.disable()
                    loadblue = cPickle.load(bluepath)
                    gc.enable()
                    bluepath.close()
                    self.mconw = loadblue[0]
                    self.mconh = loadblue[1]
                    self.congrid = loadblue[2]
                    self.conskip = loadblue[3]
                    self.contiles = loadblue[4]
                    load = False
                    GameWorld.addMesg('Blueprint \'%s\' loaded successfully.' % bluelist[selectnum])
                    lock.release()
                    break
                else:
                    for tile in range(5,9):
                        libtcod.console_set_char_background(self.loadwindow, tile, 3, bordercol2, libtcod.BKGND_SET)
            else:
                for tile in range(5,9):
                    libtcod.console_set_char_background(self.loadwindow, tile, 3, libtcod.darker_azure, libtcod.BKGND_SET)
            if handle_mouse('cx') in range(srx + 13,srx + 19) and handle_mouse('cy') == sry + 3:
                if handle_mouse('lbutton'):
                    for tile in range(13,19):
                        libtcod.console_set_char_background(self.loadwindow, tile, 3, libtcod.darker_flame, libtcod.BKGND_SET)
                    delete = True
                elif handle_mouse('lbutton_pressed') and delete:
                    time.sleep(0.1)
                    if bluelist[selectnum] != '-NO BLUEPRINTS-':
                        self.holdloop = True
                        lock.release()
                        DWindow = Dialogue([('Yes',throwSwitches,self,['holdloop','delete']),('No',throwSwitches,self,['holdloop'])],title = 'Delete \'%s\'?' % bluelist[selectnum])
                        DWindow.start()
                        continue
                else:
                    for tile in range(13,19):
                        libtcod.console_set_char_background(self.loadwindow, tile, 3, bordercol2, libtcod.BKGND_SET)
            else:
                for tile in range(13,19):
                    libtcod.console_set_char_background(self.loadwindow, tile, 3, libtcod.darker_azure, libtcod.BKGND_SET)
            lock.release()
            if handle_mouse('cx') in range(srx + 3,srx + 20) and handle_mouse('cy') in range(sry + 7,sry + 27):
                if handle_mouse('lbutton'):
                    try:
                        bluelist[handle_mouse('cy') - sry - 7 + LBar.inc]
                        selectnum = handle_mouse('cy') - sry - 7 + LBar.inc
                        redo = True
                    except IndexError:
                        pass
            if [handle_mouse('cx'),handle_mouse('cy')] == [srx + 22,sry]:
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_background(self.loadwindow, 22, 0, libtcod.sky, libtcod.BKGND_SET)
                elif handle_mouse('lbutton_pressed'):
                    time.sleep(0.1)
                    libtcod.console_set_char_background(self.loadwindow, 22, 0, libtcod.black, libtcod.BKGND_SET)
                    break
            oinc = LBar.inc
                
        XConsoles = [self.conlist,self.tconlist]
        LBar.killswitch = True
        del LBar
        libtcod.console_delete(self.loadwindow)
        self.reSize()
        self.reDraw()
        killkeycheck = False
        self.passloop = False

    def doPlace(self):
        global TopWindow, XConsoles, killkeycheck, PX, PY, Clouds, DoMenus, DoGraphics, DoButtons
        XConsoles = []
        killkeycheck = True
        canplace = False
        DoButtons,DoGraphics,DoMenus = False,False,False
        self.pconsole = libtcod.console_new(self.mconw,self.mconh)
        lock.acquire()
        zrange = range(100)
        zrange.reverse()
        for x in range(self.mconw):
            for y in range(self.mconh):
                zlev = 0
                for z in zrange:
                    if self.congrid[z].get('%s,%s' % (x,y)):
                        zlev = z
                        break
                if self.congrid[zlev].get('%s,%s' % (x,y)):                    
                    tile = self.congrid[zlev]['%s,%s' % (x,y)]
                    buildtype = tile[0]
                    key = tile[1]
                    self.curentry = GameWorld.builddict[buildtype][key]
                    char = self.getTile(x,y,zlev)
                    fg = tile[3]
                    bg = tile[4]
                    if buildtype == 'roof':
                        fg = tile[5]
                        bg = tile[6]
                    libtcod.console_set_default_foreground(self.pconsole, fg)
                    char[2] = 189
                    if bg:
                        libtcod.console_set_default_background(self.pconsole, bg)
                        libtcod.console_print_ex(self.pconsole, x, y, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                    else:
                        libtcod.console_print_ex(self.pconsole, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
        lock.release()
        DoButtons,DoGraphics,DoMenus = True,True,True

        for x in range(self.mconw):
            for y in range(self.mconh):
                if self.congrid[0].get('%s,%s' % (x,y)):
                    canplace = True
        self.pconlist = [self.pconsole,0,0,self.mconw,self.mconh,None,None,1.0,0.0]
        if canplace:
            while True:
                if handle_mouse('cx') in range(SCREEN_WIDTH - VIEW_WIDTH - 1,SCREEN_WIDTH - 2) and \
                   handle_mouse('cy') in range(3,VIEW_HEIGHT + 2):
                    if handle_mouse('rbutton'):
                        break
                    elif handle_mouse('cx') != self.pconlist[5] or handle_mouse('cy') != self.pconlist[6]:
                        TopWindow = []
                        
                        mx = min(self.mconw,(SCREEN_WIDTH - 1) - handle_mouse('cx'))
                        my = min(self.mconh,(VIEW_HEIGHT + 3) - handle_mouse('cy'))
                        self.pconlist = [self.pconsole,0,0,mx,my,handle_mouse('cx') - 1,handle_mouse('cy') - 1,1.0,0.0]
                        TopWindow = [self.pconlist]
                        noplace = False
                        cx = PX + handle_mouse('cx') - (SCREEN_WIDTH - (VIEW_WIDTH + 1))
                        cy = PY + handle_mouse('cy') - 3
                        for x in range(self.mconw):
                            for y in range(self.mconh):
                                if self.congrid[0].get('%s,%s' % (x,y)):
                                    if GameWorld.wobstructed[GameWorld.curz].get('%s,%s' % (cx + x, cy + y)):
                                        noplace = True
                                    if GameWorld.ldict.get('%s,%s' % (cx + x,cy + y)):
                                        noplace = True
                                    if cx + x > RMAP_WIDTH or cy + y > RMAP_HEIGHT:
                                        noplace = True
                                    if [PCX,PCY] == [cx + x,cy + y]:
                                        noplace = True
                        for contile in self.contiles:
                            z = contile[0]
                            x = contile[1]
                            y = contile[2]
                            try:
                                if GameWorld.zgrid[z + GameWorld.curz].get('%s,%s' % (cx + x,cy + y)):
                                    noplace = True
                            except KeyError:
                                pass

                        if noplace:
                            for x in range(self.mconw):
                                for y in range(self.mconh):
                                    libtcod.console_set_char_foreground(self.pconsole, x, y, libtcod.red)
                        else:
                            for x in range(self.mconw):
                                for y in range(self.mconh):
                                    zlev = 0
                                    for z in zrange:
                                        if self.congrid[z].get('%s,%s' % (x,y)):
                                            zlev = z
                                            break
                                    if self.congrid[zlev].get('%s,%s' % (x,y)):                    
                                        tile = self.congrid[zlev]['%s,%s' % (x,y)]
                                        fg = tile[3]
                                        if tile[0] == 'roof':
                                            fg = tile[5]
                                        libtcod.console_set_char_foreground(self.pconsole, x, y, fg)
                    if handle_mouse('lbutton'):
                        if noplace:
                            GameWorld.addMesg('That\'s an invalid location to build.', col = libtcod.yellow)
                        else:
                            cx = PX + handle_mouse('cx') - (SCREEN_WIDTH - (VIEW_WIDTH + 1))
                            cy = PY + handle_mouse('cy') - 3
                            zrange = range(100)
                            zrange.reverse()
                            for x in range(self.mconw):
                                for y in range(self.mconh):
                                    zlev = 0
                                    for z in zrange:
                                        if self.congrid[z].get('%s,%s' % (x,y)):
                                            zlev = z
                                            break
                                    if self.congrid[zlev].get('%s,%s' % (x,y)):
                                        tile = self.congrid[zlev]['%s,%s' % (x,y)]
                                        buildtype = tile[0]
                                        key = tile[1]
                                        self.curentry = GameWorld.builddict[buildtype][key]
                                        char = self.getTile(x,y,zlev)
                                        char[2] = 255
                                        fg = tile[3]
                                        bg = tile[4]
                                        if buildtype == 'roof':
                                            fg = tile[5]
                                            bg = tile[6]
                                        lighten = 0.0
                                        nzrange = range(zlev)
                                        nzrange.reverse()
                                        for nz in nzrange:
                                            if self.congrid[nz].get('%s,%s' % (x,y)):
                                                lighten = min(0.3,lighten + 0.03)
                                        if buildtype in ['stairs','ladder']:
                                            zlev += 1
                                            char[0] += 1
                                        if not GameWorld.translayer[GameWorld.curz].get('%s,%s' % (cx + x,cy + y)):
                                            oshadow = copy.copy(GameWorld.shadowdict['%s,%s' % (cx + x,cy + y)][0])
                                            GameWorld.shadowdict['%s,%s' % (cx + x,cy + y)][0] = 0.0
                                            GameWorld.shadowdict['%s,%s' % (cx + x,cy + y)].append(oshadow)
                                            Clouds.nfcolordict['%s,%s' % (cx + x,cy + y)] = fg
                                            libtcod.console_set_default_foreground(wrwindow, fg)
                                            if bg:
                                                Clouds.ncolordict['%s,%s' % (cx + x,cy + y)] = bg
                                                libtcod.console_set_default_background(wrwindow, bg)
                                                libtcod.console_print_ex(wrwindow, cx + x, cy + y, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char,255,True,cx + x,cy + y)))
                                            else:
                                                libtcod.console_print_ex(wrwindow, cx + x, cy + y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char,255,True,cx + x,cy + y)))
                                    if self.congrid[zlev].get('%s,%s' % (x,y)) or buildtype in ['stairs','ladder']:
                                        oztop = GameWorld.ztop.get('%s,%s' % (cx + x,cy + y))
                                        if oztop < zlev:
                                            GameWorld.ztop['%s,%s' % (cx + x,cy + y)] = zlev
                                    if zlev > 0:
                                        try:
                                            lbtype = self.congrid[GameWorld.curz]['%s,%s' % (x,y)][0]
                                        except KeyError:
                                            lbtype = None
                                        if (not self.congrid[GameWorld.curz].get('%s,%s' % (x,y))) or \
                                            lbtype in ['pillar','fence']:
                                            GameWorld.translayer[GameWorld.curz]['%s,%s' % (cx + x,cy + y)] = [bg,fg,char,buildtype]
                            for contile in self.contiles:
                                try:
                                    tile = self.congrid[contile[0]]['%s,%s' % (contile[1],contile[2])]
                                except KeyError:
                                    continue
                                buildtype = tile[0]
                                key = tile[1]
                                self.curentry = GameWorld.builddict[buildtype][key]
                                char = self.getTile(contile[1],contile[2],contile[0])
                                char[2] = 255
                                fg = tile[3]
                                bg = tile[4]
                                if buildtype == 'roof':
                                    fg = tile[5]
                                    bg = tile[6]
                                gridlist = [buildtype,key,char,fg,bg]
                                if buildtype == 'door':
                                    try:
                                        gridlist = [buildtype,key,char,fg,bg,'closed',tile[5]]
                                    except IndexError:
                                        gridlist = [buildtype,key,char,fg,bg,'closed']
                                elif buildtype in ['stairs','ladder']:
                                    if not self.congrid[contile[0] + 1].get('%s,%s' % (contile[1],contile[2])):
                                        GameWorld.zgrid[contile[0] + 1]['%s,%s' % (cx + contile[1],cy + contile[2])] = [buildtype,key,copy.copy(char),fg,bg]
                                        GameWorld.zgrid[contile[0] + 1]['%s,%s' % (cx + contile[1],cy + contile[2])][2][0] += 1
                                        GameWorld.zgrid[contile[0] + 1]['%s,%s' % (cx + contile[1],cy + contile[2])].append('down-%s' % buildtype)
                                        gridlist.append('up-%s' % buildtype)
                                elif buildtype == 'roof':
                                    gridlist = [buildtype,key,char,fg,bg]
                                GameWorld.zgrid[contile[0]]['%s,%s' % (cx + contile[1],cy + contile[2])] = gridlist
                                if GameWorld.curz == contile[0] and buildtype in ['wall','door','window','fence','pillar']:
                                    GameWorld.wobstructed[GameWorld.curz]['%s,%s' % (cx + contile[1],cy + contile[2])] = buildtype
                            self.didbuild = True
                            break
                else:
                    TopWindow = []
        else:
            GameWorld.addMesg('You can\'t build something with no first story.', col = libtcod.yellow)
        killkeycheck = False
        libtcod.console_delete(self.pconsole)
        TopWindow = []
        XConsoles = [self.conlist,self.tconlist]
        self.passloop = False
        self.killswitch = True
        time.sleep(0.5)
        GameWorld.doConstruction()

    def getTile(self,x,y,z):
        buildtype = self.congrid[z]['%s,%s' % (x,y)][0]
        key = self.congrid[z]['%s,%s' % (x,y)][1]
        chars = self.congrid[z]['%s,%s' % (x,y)][2]
        u,d,l,r = False,False,False,False
        try:
            if self.congrid[z]['%s,%s' % (x,y - 1)]:
                if self.congrid[z]['%s,%s' % (x,y - 1)][0] == buildtype:
                    u = True
        except KeyError:
            pass
        try:
            if self.congrid[z]['%s,%s' % (x,y + 1)]:
                if self.congrid[z]['%s,%s' % (x,y + 1)][0] == buildtype:
                    d = True
        except KeyError:
            pass
        try:
            if self.congrid[z]['%s,%s' % (x - 1,y)]:
                if self.congrid[z]['%s,%s' % (x - 1,y)][0] == buildtype:
                    l = True
        except KeyError:
            pass
        try:
            if self.congrid[z]['%s,%s' % (x + 1,y)]:
                if self.congrid[z]['%s,%s' % (x + 1,y)][0] == buildtype:
                    r = True
        except KeyError:
            pass
        if buildtype == 'door':
            doorswitch = False
            if self.congrid[z].get('%s,%s' % (x,y - 1)):
                if self.congrid[z]['%s,%s' % (x,y - 1)][0] == 'wall':
                    doorswitch = True
            if self.congrid[z].get('%s,%s' % (x,y + 1)):
                if self.congrid[z]['%s,%s' % (x,y + 1)][0] == 'wall':
                    doorswitch = True
            if doorswitch:
                char = [chars[1][0],chars[1][1],189]
            else:
                char = [chars[0][0],chars[0][1],189]
        elif buildtype == 'fence':
            if u and d and l and r:
                char = [chars[10][0],chars[10][1],189]
            elif u and d and r:
                char = [chars[6][0],chars[6][1],189]
            elif l and r and d:
                char = [chars[7][0],chars[7][1],189]
            elif l and u and d:
                char = [chars[8][0],chars[8][1],189]
            elif l and r and u:
                char = [chars[9][0],chars[9][1],189]
            elif l and d:
                char = [chars[2][0],chars[2][1],189]
            elif l and u:
                char = [chars[3][0],chars[3][1],189]
            elif r and u:
                char = [chars[4][0],chars[4][1],189]
            elif r and d:
                char = [chars[5][0],chars[5][1],189]
            elif r or l:
                char = [chars[1][0],chars[1][1],189]
            else:
                char = [chars[0][0],chars[0][1],189]
        elif buildtype == 'floor':
            char = choice(chars)
            char = [char[0],char[1],189]
        elif buildtype == 'wall':
            if l and r and u and d:
                char = [chars[15][0],chars[15][1],189]
            elif u and d and r:
                char = [chars[14][0],chars[14][1],189]
            elif r and l and u:
                char = [chars[13][0],chars[13][1],189]
            elif u and d and l:
                char = [chars[12][0],chars[12][1],189]
            elif r and l and d:
                char = [chars[11][0],chars[11][1],189]
            elif r and d:
                char = [chars[10][0],chars[10][1],189]
            elif u and r:
                char = [chars[9][0],chars[9][1],189]
            elif u and l:
                char = [chars[8][0],chars[8][1],189]
            elif l and d:
                char = [chars[7][0],chars[7][1],189]
            elif r and l:
                char = [chars[6][0],chars[6][1],189]
            elif u and d:
                char = [chars[5][0],chars[5][1],189]
            elif l:
                char = [chars[4][0],chars[4][1],189]
            elif r:
                char = [chars[3][0],chars[3][1],189]
            elif u:
                char = [chars[2][0],chars[2][1],189]
            elif d:
                char = [chars[1][0],chars[1][1],189]
            else:
                char = [chars[0][0],chars[0][1],189]
        else:
            char = [chars[0][0],chars[0][1],189]           
        return char

    def reDraw(self,redrawbox = True):        
        xplus,yplus = 0,0
        xoff,yoff = 0,0
        if hasattr(self, 'WBar'):
            xplus = self.WBar.inc
            self.WBar.reDraw()
            yoff = 1
        if hasattr(self, 'HBar'):
            yplus = self.HBar.inc
            self.HBar.reDraw()
            xoff = 1
        self.xoff,self.yoff = xoff,yoff
        for x in range(1,self.conw - 1 - xoff):
            for y in range(1,self.conh - 1 - yoff):
                libtcod.console_set_default_background(self.cconsole, libtcod.black)
                libtcod.console_print_ex(self.cconsole, x, y, libtcod.BKGND_SET, libtcod.LEFT, ' ')    
        if redrawbox:
            DrawBox(self.cconsole, 0, 0, self.conw - 1, self.conh - 1, 1, bordercol, bordercolh2)
        for x in range(self.conw - 2 - xoff):
            for y in range(self.conh - 2 - yoff):
                if self.congrid[self.z].get('%s,%s' % (x + xplus,y + yplus)):
                    tile = self.congrid[self.z]['%s,%s' % (x + xplus,y + yplus)]
                    buildtype = tile[0]
                    key = tile[1]
                    self.curentry = GameWorld.builddict[buildtype][key]
                    char = self.getTile(x + xplus,y + yplus,self.z)
                    fg = tile[3]
                    bg = tile[4]
                    if buildtype == 'roof':
                        fg = tile[5]
                        bg = tile[6]
                    libtcod.console_set_default_foreground(self.cconsole, fg)
                    char[2] = 189
                    if bg:
                        libtcod.console_set_default_background(self.cconsole, bg)
                        libtcod.console_print_ex(self.cconsole, x + 1, y + 1, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                    else:
                        libtcod.console_print_ex(self.cconsole, x + 1, y + 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                elif self.z > 0:
                    if self.congrid[self.z - 1].get('%s,%s' % (x + xplus,y + yplus)):
                        tile = self.congrid[self.z - 1]['%s,%s' % (x + xplus,y + yplus)]
                        buildtype = tile[0]
                        key = tile[1]
                        self.curentry = GameWorld.builddict[buildtype][key]
                        if buildtype == 'wall':
                            char = self.getTile(x + xplus,y + yplus,self.z - 1)
                            fg = tile[3]
                            bg = tile[4]
                            char[2] = 189
                            libtcod.console_set_default_foreground(self.cconsole, libtcod.Color(fg.r / 2,fg.g / 2,fg.b / 2))
                            libtcod.console_set_default_background(self.cconsole, fg)
                            libtcod.console_print_ex(self.cconsole, x + 1, y + 1, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                        elif buildtype == 'stairs' or buildtype == 'ladder':
                            char = [tile[2][1][0],tile[2][1][1],189]
                            fg = tile[3]
                            bg = tile[4]
                            char[2] = 189
                            libtcod.console_set_default_foreground(self.cconsole, fg)
                            libtcod.console_set_default_background(self.cconsole, bg)
                            libtcod.console_print_ex(self.cconsole, x + 1, y + 1, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))  
                        else:
                            if not self.otilegrid.get('%s,%s,%s' % (x,y,self.z - 1)):
                                char = self.getTile(x,y,self.z - 1)
                            else:
                                char = self.otilegrid['%s,%s,%s' % (x,y,self.z - 1)][1]
                            fg = libtcod.color_lerp(tile[3], libtcod.black, 0.5)
                            if tile[4]:
                                bg = libtcod.color_lerp(tile[4], libtcod.black, 0.5)
                            else:
                                bg = tile[4]
                            if buildtype == 'roof':
                                fg = fg = libtcod.color_lerp(tile[5], libtcod.black, 0.5)
                                bg = libtcod.color_lerp(tile[6], libtcod.black, 0.5)
                            libtcod.console_set_default_foreground(self.cconsole, fg)
                            char[2] = 189
                            if bg:
                                libtcod.console_set_default_background(self.cconsole, bg)
                                libtcod.console_print_ex(self.cconsole, x + 1, y + 1, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                            else:
                                libtcod.console_print_ex(self.cconsole, x + 1, y + 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))                        
                    

    def reSize(self):
        global XConsoles
        if [self.mconw + 2,self.mconh + 2] != [self.conw,self.conh]:
            xplus,yplus = 0,0
            if hasattr(self, 'WBar'):
                xplus = self.WBar.inc
                self.WBar.killswitch = True
                del self.WBar
            if hasattr(self, 'HBar'):
                yplus = self.HBar.inc
                self.HBar.killswitch = True
                del self.HBar
            XConsoles.remove(self.conlist)
            XConsoles.remove(self.tconlist)
            libtcod.console_set_default_background(self.cconsole, libtcod.black)
            libtcod.console_clear(self.cconsole)
            self.conw,self.conh = min(self.mconw + 2,VIEW_WIDTH - 20),min(self.mconh + 2,VIEW_HEIGHT)
            MPX = (self.conw + 20) / 2
            MPY = self.conh / 2
            OMPX = (SCREEN_WIDTH - VIEW_WIDTH) + (VIEW_WIDTH / 2) - MPX - 3
            OMPY = (VIEW_HEIGHT / 2) - MPY
            self.rx = (SCREEN_WIDTH - VIEW_WIDTH - 2) + (VIEW_WIDTH / 2) - MPX
            self.ry = 2 + (VIEW_HEIGHT / 2) - MPY
            self.tcrx = self.rx + self.conw
            self.tcry = 2 + (VIEW_HEIGHT / 2) - 18
            self.sh = self.mconh - (self.conh - 2)
            self.sw = self.mconw - (self.conw - 2)
            
            if self.mconw + 2 > VIEW_WIDTH - 20:
                self.WBar = WScrollBar(self.cconsole, 1, self.conh - 2, self.conw - 3, self.rx + 1, \
                                      self.ry + self.conh - 2, arrowcolor = bordercolh2, \
                                       bgcolor = bgcolor2, hcolor = globals()['hcolor'], hookmethod = self.reDraw, \
                                       hookarg = False, charnum = 190)
                self.WBar.start()
                self.WBar.max = self.sw
            if self.mconh > VIEW_HEIGHT - 2:
                self.HBar = ScrollBar(self.cconsole, self.conw - 2, 1, self.conh - 3, self.rx + self.conw - 2, \
                                      self.ry + 1, arrowcolor = bordercolh2, bgcolor = bgcolor2, \
                                      hcolor = globals()['hcolor'], hookmethod = self.reDraw, \
                                      hookarg = False, charnum = 190)
                self.HBar.start()
                self.HBar.max = self.sh
            self.conlist = [self.cconsole,0,0,self.conw,self.conh,self.rx,self.ry,1.0,1.0]
            XConsoles += [self.conlist]
            self.tconlist = [self.tconsole,0,0,20,36,self.tcrx,self.tcry,1.0,1.0]
            XConsoles += [self.tconlist]
            for tilex in range(RMAP_WIDTH):
                for tiley in range(RMAP_HEIGHT):
                    try:
                        self.conskip[self.z].pop('%s,%s' % (tilex,tiley))
                    except KeyError:
                        pass

    def close(self):
        global moveclouds, MoveLock, pathlock, XConsoles, MouseLock, NoButtons, NoGraphics, NoMenus
        if hasattr(self, 'WBar'):
            self.WBar.killswitch = True
            del self.WBar
        if hasattr(self, 'HBar'):
            self.HBar.killswitch = True
            del self.HBar
        time.sleep(0.1)
        self.killswitch = True
        time.sleep(0.1)
        XConsoles.remove(self.conlist)
        XConsoles.remove(self.tconlist)
        if self.didbuild:
            GameWorld.addMesg('Recalculating paths...')
            GameWorld.flood[GameWorld.curz] = GameWorld.floodFill(GameWorld.wobstructed,captureimage = True)
            GameWorld.recalcRoutes()
            GameWorld.handlePCview()
            GameWorld.addMesg('Done.')
        moveclouds = self.mcloudstate
        GameWorld.windowlock = False
        MoveLock = False
        pathlock = False
        libtcod.console_delete(self.cconsole)
        libtcod.console_delete(self.tconsole)
        del self

class ProgressBar(threading.Thread):
    def __init__(self,title,total):
        threading.Thread.__init__(self)
        self.title = title
        self.total = total
        self.inc = 0
        self.killswitch = False

    def run(self):
        global TopWindow
        GameWorld.topwindow = True
        self.conw = 15
        self.conh = 5
        self.pconsole = libtcod.console_new(self.conw,self.conh)
        DrawScroll(self.pconsole, 0, 0, self.conw - 1, self.conh - 1, 1)
        libtcod.console_set_default_foreground(self.pconsole, libtcod.black)
        libtcod.console_print_ex(self.pconsole, self.conw / 2, 1, libtcod.BKGND_NONE, libtcod.CENTER, self.title)
        self.rx = (SCREEN_WIDTH - VIEW_WIDTH - 3) + (VIEW_WIDTH / 2) - (self.conw / 2)
        self.ry = (VIEW_HEIGHT / 2)
        self.conlist = [self.pconsole,0,0,self.conw,self.conh,self.rx,self.ry,1.0,1.0]
        TopWindow += [self.conlist]
        libtcod.console_set_default_foreground(self.pconsole, libtcod.light_grey)
        for bartile in range(self.conw - 4):
            libtcod.console_print_ex(self.pconsole, 2 + bartile, 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(196))
        libtcod.console_set_default_foreground(self.pconsole, libtcod.dark_red)
        while not self.killswitch:
            progress = int(((self.inc * 1.0) / ((self.total) * 1.0)) * 11)
            for ptile in range(progress):
                libtcod.console_print_ex(self.pconsole, 2 + ptile, 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(205))
            time.sleep(0.1)
        self.cancel()

    def cancel(self):
        global TopWindow
        GameWorld.topwindow = False
        TopWindow.remove(self.conlist)
        libtcod.console_delete(self.pconsole)

class ScrollBar(threading.Thread):
    def __init__(self,window,x,y,h,rx,ry,arrowcolor = libtcod.white,bgcolor = None, \
                 hcolor = libtcod.yellow,ID = None,hookmethod = None, hookarg = None, \
                 scrolldims = None,charnum = None):
        global GraphicsList
        threading.Thread.__init__(self)
        self.killswitch = False
        self.window = window
        self.x = x
        self.y = y
        self.rx = rx
        self.ry = ry
        self.h = h
        self.arrowcolor = arrowcolor
        self.bgcolor = bgcolor
        self.hcolor = hcolor
        self.ID = ID
        self.max = 0
        self.inc = 0
        self.binc = 0
        self.hookmethod = hookmethod
        self.hookarg = hookarg
        self.didhook = False
        self.movescroll = False
        self.scrolldims = scrolldims
        self.charnum = charnum
        self.type = 'ScrollBar'
        libtcod.console_set_default_foreground(self.window, self.arrowcolor)
        GraphicsList = GraphicsList + [self]
        self.reDraw()

    def reDraw(self):
        if not self.charnum:
            self.charnum = 255
        libtcod.console_set_default_foreground(self.window, self.arrowcolor)
        try:
            incnum = max(int(((self.h - 3) * 1.0) / (self.max * 1.0)),1)
            if abs(self.binc) >= incnum:
                if self.binc > 0:
                    self.inc += 1
                else:
                    self.inc -= 1
                self.binc = 0
            bpos = ((self.y + 1) + int(((self.inc * 1.0) / (self.max * 1.0)) * (self.h - 3))) + self.binc
            if bpos == self.y + 1 and self.max < (self.h - 3):
                self.inc = 0
            rbpos = ((self.ry + 1) + int(((self.inc * 1.0) / (self.max * 1.0)) * (self.h - 3))) + self.binc
        except ZeroDivisionError:
            bpos = (self.y + 1) + self.binc
            rbpos = (self.ry + 1) + self.binc
        self.bpos,self.rbpos = bpos,rbpos
        if not self.bgcolor:
            self.bgcolor = bgcolor
        else:
            libtcod.console_set_default_background(self.window, self.bgcolor)
            for ny in range(1,self.h - 1):
                libtcod.console_set_char_background(self.window, self.x, self.y + ny, self.bgcolor, libtcod.BKGND_SET)
            libtcod.console_set_default_foreground(self.window, self.arrowcolor)
            char = uschar
            char[2] = self.charnum
            libtcod.console_print_ex(self.window, self.x, self.y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
            char = dschar
            char[2] = self.charnum
            libtcod.console_print_ex(self.window, self.x, self.y + self.h - 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
            for tile in range(self.h - 2):
                libtcod.console_set_default_background(self.window, self.bgcolor)
                libtcod.console_print_ex(self.window, self.x, self.y + 1 + tile, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar([0,0,self.charnum])))
            if handle_mouse('lbutton') and handle_mouse('cy') == self.rbpos:
                libtcod.console_set_default_foreground(self.window, self.hcolor)
            libtcod.console_set_default_foreground(self.window,self.arrowcolor)
            char = ballchar
            char[2] = self.charnum
            libtcod.console_print_ex(self.window, self.x, bpos, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))

    def graphDraw(self):
        global GameWorld, GraphicsList
        if not self.killswitch:
            if handle_mouse('cx') == self.rx and handle_mouse('cy') == self.ry:
                libtcod.console_set_char_foreground(self.window, self.x, self.y, self.hcolor)
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.window, self.x, self.y, self.arrowcolor)
                if handle_mouse('lbutton_pressed'):
                    self.inc = max(0,self.inc - 1)
                    self.binc = 0
                    if self.ID == 'MLogBar':
                        GameWorld.dispMesgLog()
                    else:
                        if self.hookmethod:
                            if self.hookarg != None:
                                self.hookmethod(self.hookarg)
                            else:
                                self.hookmethod()
                        self.reDraw()
            elif handle_mouse('cx') == self.rx and handle_mouse('cy') == self.ry + self.h - 1:
                libtcod.console_set_char_foreground(self.window, self.x, self.y + self.h - 1, self.hcolor)
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.window, self.x, self.y + self.h - 1, self.arrowcolor)
                if handle_mouse('lbutton_pressed'):
                    self.inc = min(self.max,self.inc + 1)
                    self.binc = 0
                    if self.ID == 'MLogBar':
                        GameWorld.dispMesgLog()
                    else:
                        if self.hookmethod:
                            if self.hookarg != None:
                                self.hookmethod(self.hookarg)
                            else:
                                self.hookmethod()
                        self.reDraw()
            elif handle_mouse('cx') in range(self.rx - 1,self.rx + 2) and handle_mouse('cy') in range(self.rbpos - 2,self.rbpos + 3):
                if handle_mouse('lbutton') and handle_mouse('cy') == self.rbpos:
                    libtcod.console_set_char_foreground(self.window, self.x, self.bpos, self.hcolor)
                    self.movescroll = True
                    if self.hookmethod:
                        if self.hookarg != None:
                            self.hookmethod(self.hookarg)
                        else:
                            self.hookmethod()
                    self.reDraw()
                elif handle_mouse('lbutton') and (handle_mouse('cx') == self.rx and \
                                                  (self.ry + self.h > handle_mouse('cy') > self.ry)) and self.movescroll:
                    self.binc += handle_mouse('cy') - self.rbpos
                    if self.hookmethod:
                        if self.hookarg != None:
                            self.hookmethod(self.hookarg)
                        else:
                            self.hookmethod()
                    self.reDraw()
                else:
                    self.movescroll = False
                    libtcod.console_set_char_foreground(self.window, self.x, self.bpos, self.arrowcolor)
                if self.ID == 'MLogBar':
                    GameWorld.dispMesgLog()
            elif handle_mouse('cx') == self.rx and handle_mouse('cy') in range(self.ry + 1,self.ry + self.h):
                if handle_mouse('lbutton'):
                    if handle_mouse('cy') > self.rbpos:
                        self.inc += max(1,self.max / 5)
                        self.inc = min(self.inc,self.max)
                        if self.hookmethod:
                            if self.hookarg != None:
                                self.hookmethod(self.hookarg)
                            else:
                                self.hookmethod()
                        self.reDraw()
                    elif handle_mouse('cy') < self.rbpos:
                        self.inc -= max(1,self.max / 5)
                        self.inc = max(self.inc,0)
                        if self.hookmethod:
                            if self.hookarg != None:
                                self.hookmethod(self.hookarg)
                            else:
                                self.hookmethod()
                        self.reDraw()
                    if self.ID == 'MLogBar':
                        GameWorld.dispMesgLog()
            else:
                libtcod.console_set_char_foreground(self.window, self.x, self.y, self.arrowcolor)
                libtcod.console_set_char_foreground(self.window, self.x, self.y + self.h - 1, self.arrowcolor)
                libtcod.console_set_char_foreground(self.window, self.x, self.bpos, self.arrowcolor)
            if self.scrolldims:
                if handle_mouse('cx') in range(self.scrolldims[0],self.scrolldims[1]):
                    if handle_mouse('cy') in range(self.scrolldims[2],self.scrolldims[3]):
                        if handle_mouse('wheel_up'):
                            self.inc = max(0,self.inc - 1)
                            if self.hookmethod:
                                if self.hookarg != None:
                                    self.hookmethod(self.hookarg)
                                else:
                                    self.hookmethod()
                            self.reDraw()
                        elif handle_mouse('wheel_down'):
                            self.inc = min(self.max,self.inc + 1)
                            if self.hookmethod:
                                if self.hookarg != None:
                                    self.hookmethod(self.hookarg)
                                else:
                                    self.hookmethod()
                            self.reDraw()
        else:
            GraphicsList.remove(self)
            del self

class WScrollBar(threading.Thread):
    def __init__(self,window,x,y,w,rx,ry,arrowcolor = libtcod.white,bgcolor = None, \
                 hcolor = libtcod.yellow,ID = None,hookmethod = None,hookarg = None, \
                 charnum = None):
        global GraphicsList
        threading.Thread.__init__(self)
        self.killswitch = False
        self.window = window
        self.x = x
        self.y = y
        self.rx = rx
        self.ry = ry
        self.w = w
        self.arrowcolor = arrowcolor
        self.bgcolor = bgcolor
        self.hcolor = hcolor
        self.ID = ID
        self.max = 0
        self.inc = 0
        self.binc = 0
        self.hookmethod = hookmethod
        self.hookarg = hookarg
        self.movescroll = False
        self.charnum = charnum
        libtcod.console_set_default_foreground(self.window, self.arrowcolor)
        GraphicsList = GraphicsList + [self]
        self.reDraw()

    def reDraw(self):
        libtcod.console_set_default_foreground(self.window, self.arrowcolor)
        if not self.charnum:
            self.charnum = 255
        try:
            incnum = max(int(((self.w - 3) * 1.0) / (self.max * 1.0)),1)
            if abs(self.binc) >= incnum:
                if self.binc > 0:
                    self.inc += 1
                else:
                    self.inc -= 1
                self.binc = 0
            bpos = ((self.x + 1) + int(((self.inc * 1.0) / (self.max * 1.0)) * (self.w - 3))) + self.binc
            if bpos == self.x + 1 and self.max < (self.w - 3):
                self.inc = 0
            rbpos = ((self.rx + 1) + int(((self.inc * 1.0) / (self.max * 1.0)) * (self.w - 3))) + self.binc
        except ZeroDivisionError:
            bpos = (self.x + 1) + self.binc
            rbpos = (self.rx + 1) + self.binc
        self.bpos,self.rbpos = bpos,rbpos
        if not self.bgcolor:
            char = lschar
            char[2] = self.charnum
            libtcod.console_print_ex(self.window, self.x, self.y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
            char = rschar
            char[2] = self.charnum
            libtcod.console_print_ex(self.window, self.x + self.w - 1, self.y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
            for tile in range(self.w - 2):
                libtcod.console_print_ex(self.window, self.x + 1 + tile, self.y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar([0,0,self.charnum])))
            if handle_mouse('lbutton') and handle_mouse('cx') == self.rbpos:
                libtcod.console_set_default_foreground(self.window, self.hcolor)
            libtcod.console_set_default_foreground(self.window,libtcod.arrowcolor)
            char = ballchar
            char[2] = self.charnum
            libtcod.console_print_ex(self.window, self.bpos, self.y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
        else:
            libtcod.console_set_default_background(self.window, self.bgcolor)
            for nx in range(1,self.w - 1):
                libtcod.console_set_char_background(self.window, self.x + nx, self.y, self.bgcolor, libtcod.BKGND_SET)
            libtcod.console_set_default_foreground(self.window, self.arrowcolor)
            char = lschar
            char[2] = self.charnum
            libtcod.console_print_ex(self.window, self.x, self.y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
            char = rschar
            char[2] = self.charnum
            libtcod.console_print_ex(self.window, self.x + self.w - 1, self.y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
            for tile in range(self.w - 2):
                libtcod.console_print_ex(self.window, self.x + 1 + tile, self.y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar([0,0,self.charnum])))
            if handle_mouse('lbutton') and handle_mouse('cx') == self.rbpos:
                libtcod.console_set_default_foreground(self.window, self.hcolor)
            libtcod.console_set_default_background(self.window, self.bgcolor)
            libtcod.console_set_default_foreground(self.window, self.hcolor)
            char = ballchar
            char[2] = self.charnum
            libtcod.console_print_ex(self.window, bpos, self.y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
        

    def graphDraw(self):
        global GameWorld, GraphicsList
        if not self.killswitch:
            if handle_mouse('cx') == self.rx and handle_mouse('cy') == self.ry:
                libtcod.console_set_char_foreground(self.window, self.x, self.y, self.hcolor)
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.window, self.x, self.y, self.arrowcolor)
                if handle_mouse('lbutton_pressed'):
                    self.inc = max(0,self.inc - 1)
                    self.binc = 0
                    if self.hookmethod:
                        if self.hookarg != None:
                            self.hookmethod(self.hookarg)
                        else:
                            self.hookmethod()
                    self.reDraw()
                    if self.ID == 'MLogBar':
                        GameWorld.dispMesgLog()
            elif handle_mouse('cx') == self.rx + self.w - 1 and handle_mouse('cy') == self.ry:
                libtcod.console_set_char_foreground(self.window, self.x + self.w - 1, self.y, self.hcolor)
                if handle_mouse('lbutton'):
                    libtcod.console_set_char_foreground(self.window, self.x + self.w - 1, self.y, self.arrowcolor)
                if handle_mouse('lbutton_pressed'):
                    self.inc = min(self.max,self.inc + 1)
                    self.binc = 0
                    if self.hookmethod:
                        if self.hookarg != None:
                            self.hookmethod(self.hookarg)
                        else:
                            self.hookmethod()
                    self.reDraw()
                    if self.ID == 'MLogBar':
                        GameWorld.dispMesgLog()
            elif handle_mouse('cx') in range(self.rbpos - 2,self.rbpos + 3) and handle_mouse('cy') in range(self.ry - 1,self.ry + 2):
                if handle_mouse('lbutton') and handle_mouse('cx') == self.rbpos:
                    libtcod.console_set_char_foreground(self.window, self.bpos, self.y, self.hcolor)
                    self.movescroll = True
                elif handle_mouse('lbutton') and (handle_mouse('cy') == self.ry and \
                                                  (self.rx + self.w > handle_mouse('cx') > self.rx)) and self.movescroll:
                    self.binc += handle_mouse('cx') - self.rbpos
                    if self.hookmethod:
                        if self.hookarg != None:
                            self.hookmethod(self.hookarg)
                        else:
                            self.hookmethod()
                    self.reDraw()
                else:
                    self.movescroll = False
                    libtcod.console_set_char_foreground(self.window, self.bpos, self.y, self.arrowcolor)
                if self.ID == 'MLogBar':
                    GameWorld.dispMesgLog()
            elif handle_mouse('cx') in range(self.rx + 1,self.rx + self.w) and handle_mouse('cy') == self.ry:
                if handle_mouse('lbutton'):
                    if handle_mouse('cx') > self.rbpos:
                        self.inc += max(1,self.max / 5)
                        self.inc = min(self.inc,self.max)
                        if self.hookmethod:
                            if self.hookarg != None:
                                self.hookmethod(self.hookarg)
                            else:
                                self.hookmethod()
                        self.reDraw()
                    elif handle_mouse('cx') < self.rbpos:
                        self.inc -= max(1,self.max / 5)
                        self.inc = max(self.inc,0)
                        if self.hookmethod:
                            if self.hookarg != None:
                                self.hookmethod(self.hookarg)
                            else:
                                self.hookmethod()
                        self.reDraw()
                    if self.ID == 'MLogBar':
                        GameWorld.dispMesgLog()
            else:
                libtcod.console_set_char_foreground(self.window, self.x, self.y, self.arrowcolor)
                libtcod.console_set_char_foreground(self.window, self.x + self.w - 1, self.y, self.arrowcolor)
                libtcod.console_set_char_foreground(self.window, self.bpos, self.y, self.arrowcolor)
        else:
            GraphicsList.remove(self)
            del self

####################################
# III. Misc. Graphical Functions   #
####################################

def killMenus():
    global MenuList
    MenuList = []

def renderButtons():
    global ButtonList, NoButtons, GButtonList, MGButtonList, globaljobs
    if len(ButtonList) + len(GButtonList) + len(MGButtonList) > 0:
        if not NoButtons:
            for button in ButtonList:
                button.drawButton()
            for button in GButtonList:
                GButton(button[0],button[1],button[2],button[3],button[4],button[5],button[6])
            for button in MGButtonList:
                MGButton(button[0],button[1],button[2],button[3],button[4],button[5],button[6])
    
def renderMenus():
    global MenuList,NoMenus
    if len(MenuList) > 0:
        for menu in MenuList:
            if not NoMenus:
                menu.drawMenu()

def renderText():
    global TextList, mouse, lastsound
    if len(TextList) > 0:
        for text in range(len(TextList)):
            try:
                if hasattr(TextList[text],'covercells'):
                    if TextList[text].covercells.get('%s,%s' % (handle_mouse('cx'),handle_mouse('cy'))):
                        TextList[text].hoverswitch = True
                        if TextList[text].firstfade:
                            if not globals().get('lastsound'):
                                lastsound = 4
                            if TextList[text].playsound:
                                sound = (randrange(1,5))
                                while sound == lastsound:
                                    sound = (randrange(1,5))
                                lastsound = sound
                                doorname = 'sounds\\wav\\ding%s' % sound + '.wav'
                                doorsound = playSound(doorname,volume=0.5)
                            TextList[text].playsound = False
                            TextList[text].fadeto = libtcod.white
                            TextList[text].fadevar -= 1
                            if hasattr(TextList[text],'hoverhook'):
                                TextList[text].hoverhook()
                            if handle_mouse('lbutton_pressed'):
                                TextList[text].hookmethod()
                    else:
                        if TextList[text].hoverswitch:
                            TextList[text].hoverswitch = False
                            if hasattr(TextList[text],'unhoverhook'):
                                TextList[text].unhoverhook()
                        if TextList[text].firstfade:
                            TextList[text].playsound = True
                            TextList[text].fadeto = copy.copy(TextList[text].ofadeto)
                            TextList[text].fadevar -= 1
                TextList[text].textDraw()
            except IndexError:
                pass
    else:
        pass

def renderLights():
    global LightList
    for light in LightList:
        light.lightDraw()

def renderGraphics():
    global GraphicsList, NoGraphics
    for graphic in GraphicsList:
        if not NoGraphics:
            graphic.graphDraw()

def DrawScroll(window,ox,oy,width,height,style = 0):
    global NoGraphics, NoButtons, NoMenus, NoUpdate, lock
    NoGraphics, NoButtons, NoMenus, NoUpdate = True,True,True,True
    libtcod.console_set_default_foreground(window,libtcod.white)

    if style == 0:
        um = scrollum
        bm = scrollbm
        l = scrolll
        r = scrollr
        ul = scrollul
        ur = scrollur
        bl = scrollbl
        br = scrollbr
        scolor = scrollcolor
    elif style == 1:
        um = scroll2um
        bm = scroll2bm
        l = scroll2l
        r = scroll2r
        ul = scroll2ul
        ur = scroll2ur
        bl = scroll2bl
        br = scroll2br
        scolor = scrollcolor2

    for x in range(ox + 1,ox + width):
        libtcod.console_print_ex(window, x, oy, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(um)))
    for x in range(ox + 1,ox + width):
        libtcod.console_print_ex(window, x, oy + height, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bm)))
    for y in range(oy + 1, oy + height):
        libtcod.console_print_ex(window, ox, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(l)))
    for y in range(oy + 1, oy + height):
        libtcod.console_print_ex(window, ox + width, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(r)))
    
    libtcod.console_print_ex(window, ox, oy, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(ul)))
    libtcod.console_print_ex(window, ox + width, oy, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(ur)))
    libtcod.console_print_ex(window, ox, oy + height, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bl)))
    libtcod.console_print_ex(window, ox + width, oy + height, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(br)))

    for x in range(ox + 1,ox + width):
        for y in range(oy + 1,oy + height):
            libtcod.console_print_ex(window,x,y,libtcod.BKGND_NONE,libtcod.LEFT,' ')
            libtcod.console_set_char_background(window,x,y,scolor,libtcod.BKGND_SET)
    NoGraphics, NoButtons, NoMenus, NoUpdate = False,False,False,False

def DrawBanner(window,ox,oy,text,textcolor = None,bannertype = 'Type 1'):
    global NoGraphics, NoButtons, NoMenus, NoUpdate
    NoGraphics, NoButtons, NoMenus, NoUpdate = True,True,True,True
    libtcod.console_set_default_foreground(window,libtcod.white)

    if not textcolor:
        textcolor = buttont
    banner = bannerdict[bannertype]

    for x in range(5):
        for y in range(4):
            char = [banner[0] + x,banner[1] + y,255]
            libtcod.console_print_ex(window,ox + x - (len(text) / 2) - 3,oy + y,libtcod.BKGND_NONE,libtcod.CENTER,chr(DoChar(char)))
    for x in range(len(text) - 2):
        for y in range(4):
            char = [banner[0] + 5,banner[1] + y,255]
            libtcod.console_print_ex(window,ox + x - (len(text) / 2) + 1,oy + y,libtcod.BKGND_NONE,libtcod.CENTER,chr(DoChar(char)))
    for x in range(len(text)):
        libtcod.console_set_char_background(window,ox - (len(text) / 2) + x,oy + 2,bannercolor,libtcod.BKGND_SET)
    for x in range(5):
        for y in range(4):
            char = [banner[0] + x + 6,banner[1] + y,255]
            libtcod.console_print_ex(window,ox + x + (len(text) / 2) + (len(text) % 2) - 2,oy + y,libtcod.BKGND_NONE,libtcod.CENTER,chr(DoChar(char)))
    libtcod.console_set_default_foreground(window,textcolor)
    libtcod.console_print_ex(window,ox,oy + 2,libtcod.BKGND_NONE,libtcod.CENTER,text)
    NoGraphics, NoButtons, NoMenus, NoUpdate = False,False,False,False

def DrawBox(window, ox, oy, width, height, cornerstyle = 0, color = None, \
            cornercolor = None, title = None, tcolor = None, to = 0, \
            btype = 'thick'):
    global NoGraphics, NoButtons, NoMenus, NoUpdate

    NoGraphics, NoButtons, NoMenus, NoUpdate = True,True,True,True
    if not color:
        color = hcolor
    if not cornercolor:
        cornercolor = hcolor2
    if not tcolor:
        tcolor = libtcod.white
    libtcod.console_set_default_foreground(window, color)

    if title:
        for x in range(ox + 1, ox + (width / 2) - (len(title) / 2) - 2 + to):
            char = random.choice(vectorchars)
            libtcod.console_print_ex(window, x, oy, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
        for x in range(ox + (width / 2) + (len(title) / 2) + 3 + to,ox + width):
            char = random.choice(vectorchars)
            libtcod.console_print_ex(window, x, oy, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
        libtcod.console_set_default_foreground(window, cornercolor)
        libtcod.console_print_ex(window, ox + (width / 2) - (len(title) / 2) - 2 + to, oy, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(random.choice(vectorchars))))
        libtcod.console_print_ex(window, ox + (width / 2) + (len(title) / 2) + 2 + to, oy, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(random.choice(vectorchars))))
        libtcod.console_set_default_foreground(window, tcolor)
        libtcod.console_print_ex(window, ox + (width / 2) - (len(title) / 2) + to, oy, libtcod.BKGND_NONE, libtcod.LEFT, title)
        libtcod.console_set_default_foreground(window, color)
    else:
        for x in range(ox + 1,ox + width):
            char = random.choice(vectorchars)
            libtcod.console_print_ex(window, x, oy, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
    for x in range(ox + 1,ox + width):
        char = random.choice(vectorchars)
        libtcod.console_print_ex(window, x, oy + height, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
    for y in range(oy + 1, oy + height):
        char = random.choice(vectorchars)
        libtcod.console_print_ex(window, ox, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
    for y in range(oy + 1, oy + height):
        char = random.choice(vectorchars)
        libtcod.console_print_ex(window, ox + width, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))

    libtcod.console_set_default_foreground(window, cornercolor)
    
    if cornerstyle == 0:
        libtcod.console_print_ex(window, ox, oy, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(random.choice(vectorchars))))
        libtcod.console_print_ex(window, ox + width, oy, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(random.choice(vectorchars))))
        libtcod.console_print_ex(window, ox, oy + height, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(random.choice(vectorchars))))
        libtcod.console_print_ex(window, ox + width, oy + height, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(random.choice(vectorchars))))
    else:
        libtcod.console_print_ex(window, ox, oy, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(random.choice(vectorchars))))
        libtcod.console_print_ex(window, ox + width, oy, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(random.choice(vectorchars))))
        libtcod.console_print_ex(window, ox, oy + height, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(random.choice(vectorchars))))
        libtcod.console_print_ex(window, ox + width, oy + height, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(random.choice(vectorchars))))
    NoGraphics, NoButtons, NoMenus, NoUpdate = False,False,False,False

def DoMenu(window, ox, oy, optionlist, hcolor = libtcod.azure, ocolor = libtcod.darkest_azure, \
           tcolor = libtcod.white, doback = 1, align = 'left', offx = 0, offy = 0, linespace = 1, \
           moffset = 0):
    global playery, oplayery, mouse, hoveropt
    opcelldict = {}

    if len(optionlist) > 25:
        moptionlist = optionlist[0 + (25 * moffset):(moffset + 1) * 25]
    else:
        moptionlist = optionlist
        
    libtcod.console_set_default_foreground(window, tcolor)
    for option in range(len(moptionlist)):
        opcells = []
        if align == 'left':
            for num in range(ox + offx, ox + offx + len(moptionlist[option]) + (len(str(option + 1)) + 2)):
                opcells.append([num,oy + offy + 1 + (option * linespace)])
        elif align == 'center':
            for num in range(ox + offx - (len(moptionlist[option]) / 2) - len(str(option + 1)) - (len(str(moptionlist[option])) % 2), ox + offx + (len(moptionlist[option]) / 2) + 2):
                opcells.append([num,oy + offy + 1 + (option * linespace)])
        opcelldict[option + 1] = opcells
        if align == 'left':
            libtcod.console_print_ex(window, ox, oy + (option * linespace), libtcod.BKGND_NONE, libtcod.LEFT, str(option + 1) + '. ' + moptionlist[option])
        elif align == 'center':
            libtcod.console_print_ex(window, ox, oy + (option * linespace), libtcod.BKGND_NONE, libtcod.CENTER, str(option + 1) + '. ' + moptionlist[option])

    if len(optionlist) > 25:
        if align == 'left':
            if moffset > 0:
                prevopcells = []
                for num in range(14):
                    prevopcells.append([ox + offx + num,oy + offy + 1 + (25 * linespace)])
                opcelldict[26] = prevopcells
                libtcod.console_print_ex(window, ox, oy + len(moptionlist) + 1, libtcod.BKGND_NONE, libtcod.LEFT, '<< Previous <<')
                moptionlist.append('<< Previous <<')
            if (moffset * 25) < len(optionlist):
                nextopcells = []
                for num in range(10):
                    nextopcells.append([ox + offx + num,oy + offy + 2 + (25 * linespace)])
                if moffset > 0:
                    offnum = 2
                    opcelldict[27] = nextopcells
                else:
                    offnum = 1
                    opcelldict[26] = nextopcells
                libtcod.console_print_ex(window, ox, oy + len(moptionlist) + offnum, libtcod.BKGND_NONE, libtcod.LEFT, '>> Next >>')
                moptionlist.append('>> Next >>')
        elif align == 'center':
            if moffset > 0:
                libtcod.console_print_ex(window, ox, oy + len(moptionlist) + 1, libtcod.BKGND_NONE, libtcod.CENTER, '<< Previous 25 >>')
            if (moffset * 25) < len(optionlist):
                libtcod.console_print_ex(window, ox, oy + len(moptionlist) + 2, libtcod.BKGND_NONE, libtcod.CENTER, '<< Next 25 >>')

    if doback == 1:
        if len(optionlist) > 25:
            addnum = 4
        else:
            addnum = 1
        libtcod.console_print_ex(window, ox, oy + len(moptionlist) + addnum, libtcod.BKGND_NONE, libtcod.LEFT, \
                                   "To go back to\n" \
                                   "the prior menu,\n" \
                                   "press the\n" \
                                   "escape key\n" \
                                   "or the right\n" \
                                   "mouse button.")

    if cursorswitch:
        hoveropt = False
        for opt in opcelldict.items():
            if [handle_mouse('cx'),handle_mouse('cy') - 1] in opt[1]:
                playery = opt[0]
                hoveropt = True
    if playery > len(moptionlist):
        playery = 1
    if playery < 1:
        playery = len(moptionlist)
    for cell in opcelldict[playery]:
        libtcod.console_set_char_background(window, cell[0] - offx, cell[1] - offy - 1, hcolor, libtcod.BKGND_SET)
    if oplayery != playery:
        for cell in opcelldict[oplayery]:
            libtcod.console_set_char_background(window, cell[0] - offx, cell[1] - offy - 1, ocolor, libtcod.BKGND_SET)
    if (handle_mouse('lbutton_pressed') or key.vk == libtcod.KEY_ENTER) and moptionlist[playery - 1] == '>> Next >>':
        moffset += 1
    if (handle_mouse('lbutton_pressed') or key.vk == libtcod.KEY_ENTER) and moptionlist[playery - 1] == '<< Previous <<':
        moffset -= 1
        
    oplayery = playery

def solidScale(image, newx, newy, territory = 0):
    imagesize = libtcod.image_get_size(image)
    imageconsole = libtcod.console_new(newx,newy)
    xskip = imagesize[0] / newx
    yskip = imagesize[1] / newy
    xscale = float(newx) / float(imagesize[0] / 10)
    yscale = float(newy) / float(imagesize[1] / 10)
    terrcivdict = {}
    for x in range(newx):
        for y in range(newy):
            col = libtcod.image_get_pixel(image,x * xskip,y * yskip)
            libtcod.console_set_char_background(imageconsole,x,y,col,libtcod.BKGND_SET)
            try:
                civ = wterritorydict['%s,%s' % ((x * xskip) / 10,(y * yskip) / 10)]
                terrcivdict['%s,%s' % (x,y)] = civ
            except KeyError:
                pass
    scaleimage = libtcod.image_from_console(imageconsole)
    
    return [scaleimage,xscale,yscale,terrcivdict]

def textWrap(text, conwidth = VIEW_WIDTH):
    if len(text) > conwidth - 2:
        n = conwidth - 2
        fline = ''
        lines = 1
        while len(text) > n:
            lines += 1
            curtext = list(text[:n])
            curtext.reverse()
            curnum = n
            for curchar in curtext:
                if curchar == ' ':
                    fline += text[:curnum - 1] + '\n'
                    text = text[curnum:]
                    break
                curnum -= 1
        fline += text
        return [fline,lines]
    else:
        return [text,1]

####################################
# IV. Input Functions              #
####################################

def handle_mouse(attribute):
    global mouse, key
    output = getattr(mouse,attribute)
    return output

def mouse_isvisible():
    output = libtcod.mouse_is_cursor_visible()
    return output

def handle_keys():
    global playerx, playery, key, DOSCREEN, WorldGoing, WorldDone, NamingDone, \
           CreatureDone, SCREEN_WIDTH, SCREEN_HEIGHT, movetime, mouse, ButtonList, \
           scaleswitch, NoKeys, MenuSetting, PX, PY, GameWorld, lastcity, MenuList, \
           MouseLock, TextList, PCX, PCY, hpcswitch, pathclass, pathlock, lastmove, \
           movekeys, MoveLock, relswitch, ignoreclick, cannotleave, marker, music, \
           changecursor, Cursor, toplayer, killkeycheck, DoScaleLayer, NoButtons, NoMenus, \
           q, GUITiles, GUICon, XConsoles, moveclouds, GUIBlurbCon

    if not NoKeys:
        if DOSCREEN == 1 and not scaleswitch and not MouseLock:
            if handle_mouse('lbutton') and (handle_mouse('cx') in range(SCREEN_WIDTH - VIEW_WIDTH - 2,SCREEN_WIDTH - 2) and \
                                  handle_mouse('cy') in range(2,VIEW_HEIGHT + 2)):
                playery = min(max(playery - handle_mouse('dcy'),0),MAP_HEIGHT - VIEW_HEIGHT)
                playerx = min(max(playerx - handle_mouse('dcx'),0),MAP_WIDTH - VIEW_WIDTH)

        if DOSCREEN == 2 and not (MoveLock or MouseLock):
            dogui = False
            if GameWorld.rswitch:
                try:
                    # GUI Handling Code
                    GUITiles['%s,%s' % (handle_mouse('cx'),handle_mouse('cy'))]
                    dogui = True
                    if GUICon not in XConsoles:
                        XConsoles += [GUICon]
                    pausebutton = GUITiles['unpause']
                    for tile in pausebutton:
                        if (handle_mouse('cx'),handle_mouse('cy')) == (tile[0] + GUIxloc,tile[1] + GUIyloc):
                            if handle_mouse('lbutton_pressed'):
                                GameWorld.doPause()
                    battlebutton = GUITiles['battle']
                    for tile in battlebutton:
                        if (handle_mouse('cx'),handle_mouse('cy')) == (tile[0] + GUIxloc,tile[1] + GUIyloc):
                            if handle_mouse('lbutton_pressed'):
                                GameWorld.doGUIMenu('battle')
                    groupbutton = GUITiles['group']
                    for tile in groupbutton:
                        if (handle_mouse('cx'),handle_mouse('cy')) == (tile[0] + GUIxloc,tile[1] + GUIyloc):
                            if handle_mouse('lbutton_pressed'):
                                GameWorld.doGUIMenu('group')                    
                    taskbutton = GUITiles['task']
                    for tile in taskbutton:
                        if (handle_mouse('cx'),handle_mouse('cy')) == (tile[0] + GUIxloc,tile[1] + GUIyloc):
                            if handle_mouse('lbutton_pressed'):
                                GameWorld.doGUIMenu('task')
                    addbutton = GUITiles['add']
                    addhover = False
                    for tile in addbutton:
                        if (handle_mouse('cx'),handle_mouse('cy')) == (tile[0] + GUIxloc,tile[1] + GUIyloc):
                            addhover = True
                    if addhover and handle_mouse('lbutton'):
                        addhover = False
                    elif addhover and handle_mouse('lbutton_pressed'):
                        clicksound = playSound('sounds\\wav\\click2.wav')
                        if GUIMenu['page'] < 6:
                            GUIMenu['page'] += 1
                        else:
                            GUIMenu['page'] = 1
                        GameWorld.doGUIMenu(page = GUIMenu['page'])
                    if addhover:
                        libtcod.console_set_default_foreground(GUILayer,libtcod.white)
                        for x in range(2):
                            lock.acquire()
                            char = [button_addh[0] + x,button_addh[1],255]
                            libtcod.console_print_ex(GUILayer,GUITiles['add'][0][0] + x,GUITiles['add'][0][1],libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                            lock.release()
                    else:
                        for x in range(2):
                            lock.acquire()
                            char = [button_add[0] + x,button_add[1],255]
                            libtcod.console_print_ex(GUILayer,GUITiles['add'][0][0] + x,GUITiles['add'][0][1],libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                            lock.release()                        
                    subbutton = GUITiles['sub']
                    subhover = False
                    for tile in subbutton:
                        if (handle_mouse('cx'),handle_mouse('cy')) == (tile[0] + GUIxloc,tile[1] + GUIyloc):
                            subhover = True
                    if subhover and handle_mouse('lbutton'):
                        subhover = False
                    elif subhover and handle_mouse('lbutton_pressed'):
                        clicksound = playSound('sounds\\wav\\click2.wav')
                        if GUIMenu['page'] > 1:
                            GUIMenu['page'] -= 1
                        else:
                            GUIMenu['page'] = 6
                        GameWorld.doGUIMenu(page = GUIMenu['page'])
                    if subhover:
                        libtcod.console_set_default_foreground(GUILayer,libtcod.white)
                        for x in range(2):
                            lock.acquire()
                            char = [button_subh[0] + x,button_subh[1],255]
                            libtcod.console_print_ex(GUILayer,GUITiles['sub'][0][0] + x,GUITiles['sub'][0][1],libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                            lock.release()
                        if handle_mouse('lbutton_pressed'):
                            clicksound = playSound('sounds\\wav\\click2.wav')
                    else:
                        for x in range(2):
                            lock.acquire()
                            char = [button_sub[0] + x,button_sub[1],255]
                            libtcod.console_print_ex(GUILayer,GUITiles['sub'][0][0] + x,GUITiles['sub'][0][1],libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                            lock.release()
                    b1hover = False
                    button1 = GUITiles['button1']
                    for tile in button1:
                        if (handle_mouse('cx'),handle_mouse('cy')) == (tile[0] + GUIxloc,tile[1] + GUIyloc):
                            b1hover = True
                    b2hover = False
                    button2 = GUITiles['button2']
                    for tile in button2:
                        if (handle_mouse('cx'),handle_mouse('cy')) == (tile[0] + GUIxloc,tile[1] + GUIyloc):
                            b2hover = True                    
                    b3hover = False
                    button3 = GUITiles['button3']
                    for tile in button3:
                        if (handle_mouse('cx'),handle_mouse('cy')) == (tile[0] + GUIxloc,tile[1] + GUIyloc):
                            b3hover = True
                    b4hover = False
                    button4 = GUITiles['button4']
                    for tile in button4:
                        if (handle_mouse('cx'),handle_mouse('cy')) == (tile[0] + GUIxloc,tile[1] + GUIyloc):
                            b4hover = True
                    b5hover = False
                    button5 = GUITiles['button5']
                    for tile in button5:
                        if (handle_mouse('cx'),handle_mouse('cy')) == (tile[0] + GUIxloc,tile[1] + GUIyloc):
                            b5hover = True
                    b6hover = False
                    button6 = GUITiles['button6']
                    for tile in button6:
                        if (handle_mouse('cx'),handle_mouse('cy')) == (tile[0] + GUIxloc,tile[1] + GUIyloc):
                            b6hover = True
                    if not (b1hover or b2hover or b3hover or b4hover or b5hover or b6hover):
                        libtcod.console_set_default_background(GUIBlurb,libtcod.magenta)
                        libtcod.console_clear(GUIBlurb)
                        if GUIBlurbCon in XConsoles:
                            XConsoles.remove(GUIBlurbCon)
                    elif b1hover:
                        if GUIBlurbCon not in XConsoles or GUIBlurbCon[9] != 'button1':
                            GUIBlurbCon[9] = 'button1'
                            if GUIMenu[GUIMenu['menu']][GUIMenu['page']][0]:
                                action = GUIMenu[GUIMenu['menu']][GUIMenu['page']][0][2]
                                desc = GUIMenu[GUIMenu['menu']][GUIMenu['page']][0][3]
                                blurb = textWrap(desc,22)
                                blurblen = blurb[1] + 1
                            else:
                                action = 'None'
                                blurb = ['No action assigned.',1]
                                blurblen = 2
                            for x in range(24):
                                for y in range(blurblen + 2):
                                    libtcod.console_set_char_background(GUIBlurb,x,y,bgcolor,libtcod.BKGND_SET)
                            DrawBox(GUIBlurb,0,0,23,blurblen + 1,1,bordercol,bordercolh2)
                            libtcod.console_set_default_foreground(GUIBlurb,libtcod.white)
                            libtcod.console_set_color_control(libtcod.COLCTRL_1,libtcod.light_orange,libtcod.black)
                            libtcod.console_print_ex(GUIBlurb,12,1,libtcod.BKGND_NONE,libtcod.CENTER,'%c' % (libtcod.COLCTRL_1) + action + \
                                                     '%c' % (libtcod.COLCTRL_STOP) + '\n' + blurb[0])
                            GUIBlurbCon[5] = handle_mouse('cx') - 12
                            GUIBlurbCon[6] = handle_mouse('cy') - 6
                            XConsoles += [GUIBlurbCon]
                    elif b2hover:
                        if GUIBlurbCon not in XConsoles or GUIBlurbCon[9] != 'button2':
                            GUIBlurbCon[9] = 'button2'
                            if GUIMenu[GUIMenu['menu']][GUIMenu['page']][1]:
                                action = GUIMenu[GUIMenu['menu']][GUIMenu['page']][1][2]
                                desc = GUIMenu[GUIMenu['menu']][GUIMenu['page']][1][3]
                                blurb = textWrap(desc,22)
                                blurblen = blurb[1] + 1
                            else:
                                action = 'None'
                                blurb = ['No action assigned.',1]
                                blurblen = 2
                            for x in range(24):
                                for y in range(blurblen + 2):
                                    libtcod.console_set_char_background(GUIBlurb,x,y,bgcolor,libtcod.BKGND_SET)
                            DrawBox(GUIBlurb,0,0,23,blurblen + 1,1,bordercol,bordercolh2)
                            libtcod.console_set_default_foreground(GUIBlurb,libtcod.white)
                            libtcod.console_set_color_control(libtcod.COLCTRL_1,libtcod.light_orange,libtcod.black)
                            libtcod.console_print_ex(GUIBlurb,12,1,libtcod.BKGND_NONE,libtcod.CENTER,'%c' % (libtcod.COLCTRL_1) + action + \
                                                     '%c' % (libtcod.COLCTRL_STOP) + '\n' + blurb[0])
                            GUIBlurbCon[5] = handle_mouse('cx') - 12
                            GUIBlurbCon[6] = handle_mouse('cy') - 6
                            XConsoles += [GUIBlurbCon]
                    elif b3hover:
                        if GUIBlurbCon not in XConsoles or GUIBlurbCon[9] != 'button3':
                            GUIBlurbCon[9] = 'button3'
                            if GUIMenu[GUIMenu['menu']][GUIMenu['page']][2]:
                                action = GUIMenu[GUIMenu['menu']][GUIMenu['page']][2][2]
                                desc = GUIMenu[GUIMenu['menu']][GUIMenu['page']][2][3]
                                blurb = textWrap(desc,22)
                                blurblen = blurb[1] + 1
                            else:
                                action = 'None'
                                blurb = ['No action assigned.',1]
                                blurblen = 2
                            for x in range(24):
                                for y in range(blurblen + 2):
                                    libtcod.console_set_char_background(GUIBlurb,x,y,bgcolor,libtcod.BKGND_SET)
                            DrawBox(GUIBlurb,0,0,23,blurblen + 1,1,bordercol,bordercolh2)
                            libtcod.console_set_default_foreground(GUIBlurb,libtcod.white)
                            libtcod.console_set_color_control(libtcod.COLCTRL_1,libtcod.light_orange,libtcod.black)
                            libtcod.console_print_ex(GUIBlurb,12,1,libtcod.BKGND_NONE,libtcod.CENTER,'%c' % (libtcod.COLCTRL_1) + action + \
                                                     '%c' % (libtcod.COLCTRL_STOP) + '\n' + blurb[0])
                            GUIBlurbCon[5] = handle_mouse('cx') - 12
                            GUIBlurbCon[6] = handle_mouse('cy') - 6
                            XConsoles += [GUIBlurbCon]
                    elif b4hover:
                        if GUIBlurbCon not in XConsoles or GUIBlurbCon[9] != 'button4':
                            GUIBlurbCon[9] = 'button4'
                            if GUIMenu[GUIMenu['menu']][GUIMenu['page']][3]:
                                action = GUIMenu[GUIMenu['menu']][GUIMenu['page']][3][2]
                                desc = GUIMenu[GUIMenu['menu']][GUIMenu['page']][3][3]
                                blurb = textWrap(desc,22)
                                blurblen = blurb[1] + 1
                            else:
                                action = 'None'
                                blurb = ['No action assigned.',1]
                                blurblen = 2
                            for x in range(24):
                                for y in range(blurblen + 2):
                                    libtcod.console_set_char_background(GUIBlurb,x,y,bgcolor,libtcod.BKGND_SET)
                            DrawBox(GUIBlurb,0,0,23,blurblen + 1,1,bordercol,bordercolh2)
                            libtcod.console_set_default_foreground(GUIBlurb,libtcod.white)
                            libtcod.console_set_color_control(libtcod.COLCTRL_1,libtcod.light_orange,libtcod.black)
                            libtcod.console_print_ex(GUIBlurb,12,1,libtcod.BKGND_NONE,libtcod.CENTER,'%c' % (libtcod.COLCTRL_1) + action + \
                                                     '%c' % (libtcod.COLCTRL_STOP) + '\n' + blurb[0])
                            GUIBlurbCon[5] = handle_mouse('cx') - 12
                            GUIBlurbCon[6] = handle_mouse('cy') - 6
                            XConsoles += [GUIBlurbCon]
                    elif b5hover:
                        if GUIBlurbCon not in XConsoles or GUIBlurbCon[9] != 'button5':
                            GUIBlurbCon[9] = 'button5'
                            if GUIMenu[GUIMenu['menu']][GUIMenu['page']][4]:
                                action = GUIMenu[GUIMenu['menu']][GUIMenu['page']][4][2]
                                desc = GUIMenu[GUIMenu['menu']][GUIMenu['page']][4][3]
                                blurb = textWrap(desc,22)
                                blurblen = blurb[1] + 1
                            else:
                                action = 'None'
                                blurb = ['No action assigned.',1]
                                blurblen = 2
                            for x in range(24):
                                for y in range(blurblen + 2):
                                    libtcod.console_set_char_background(GUIBlurb,x,y,bgcolor,libtcod.BKGND_SET)
                            DrawBox(GUIBlurb,0,0,23,blurblen + 1,1,bordercol,bordercolh2)
                            libtcod.console_set_default_foreground(GUIBlurb,libtcod.white)
                            libtcod.console_set_color_control(libtcod.COLCTRL_1,libtcod.light_orange,libtcod.black)
                            libtcod.console_print_ex(GUIBlurb,12,1,libtcod.BKGND_NONE,libtcod.CENTER,'%c' % (libtcod.COLCTRL_1) + action + \
                                                     '%c' % (libtcod.COLCTRL_STOP) + '\n' + blurb[0])
                            GUIBlurbCon[5] = handle_mouse('cx') - 12
                            GUIBlurbCon[6] = handle_mouse('cy') - 6
                            XConsoles += [GUIBlurbCon]
                    elif b6hover:
                        if GUIBlurbCon not in XConsoles or GUIBlurbCon[9] != 'button6':
                            GUIBlurbCon[9] = 'button6'
                            if GUIMenu[GUIMenu['menu']][GUIMenu['page']][5]:
                                action = GUIMenu[GUIMenu['menu']][GUIMenu['page']][5][2]
                                desc = GUIMenu[GUIMenu['menu']][GUIMenu['page']][5][3]
                                blurb = textWrap(desc,22)
                                blurblen = blurb[1] + 1
                            else:
                                action = 'None'
                                blurb = ['No action assigned.',1]
                                blurblen = 2
                            for x in range(24):
                                for y in range(blurblen + 2):
                                    libtcod.console_set_char_background(GUIBlurb,x,y,bgcolor,libtcod.BKGND_SET)
                            DrawBox(GUIBlurb,0,0,23,blurblen + 1,1,bordercol,bordercolh2)
                            libtcod.console_set_default_foreground(GUIBlurb,libtcod.white)
                            libtcod.console_set_color_control(libtcod.COLCTRL_1,libtcod.light_orange,libtcod.black)
                            libtcod.console_print_ex(GUIBlurb,12,1,libtcod.BKGND_NONE,libtcod.CENTER,'%c' % (libtcod.COLCTRL_1) + action + \
                                                     '%c' % (libtcod.COLCTRL_STOP) + '\n' + blurb[0])
                            GUIBlurbCon[5] = handle_mouse('cx') - 12
                            GUIBlurbCon[6] = handle_mouse('cy') - 6
                            XConsoles += [GUIBlurbCon]
                except KeyError:
                    if GUICon in XConsoles:
                        XConsoles.remove(GUICon)
                    if GUIBlurbCon in XConsoles:
                        XConsoles.remove(GUIBlurbCon)
                        
            # World Start Site Selection
            if handle_mouse('lbutton') and (handle_mouse('cx') in range(SCREEN_WIDTH - VIEW_WIDTH - 2,SCREEN_WIDTH - 2) and \
                                  handle_mouse('cy') in range(2,VIEW_HEIGHT + 2)) and not dogui:
                if GameWorld.rswitch:
                    PY = min(max(PY - handle_mouse('dcy'),0),RMAP_HEIGHT - VIEW_HEIGHT)
                    PX = min(max(PX - handle_mouse('dcx'),0),RMAP_WIDTH - VIEW_WIDTH)
                    if handle_mouse('dcy') != 0 or handle_mouse('dcx') != 0:
                        pathlock = True
                else:
                    PY = min(max(PY - handle_mouse('dcy'),0),MAP_HEIGHT - VIEW_HEIGHT)
                    PX = min(max(PX - handle_mouse('dcx'),0),MAP_WIDTH - VIEW_WIDTH)
                    if handle_mouse('dcy') != 0 or handle_mouse('dcx') != 0:
                        pathlock = True

                    if not GameWorld.setupdone:
                        city = GameWorld.citygrid['%s,%s' % (PX + handle_mouse('cx') - 20,PY + handle_mouse('cy') - 2)]
                        if city:
                            GameWorld.displayCity(city)
                            lastcity = city

            # Pathfinding
            if handle_mouse('lbutton_pressed') and (handle_mouse('cx') in range(SCREEN_WIDTH - VIEW_WIDTH - 2,SCREEN_WIDTH - 2) and \
                                          handle_mouse('cy') in range(2,VIEW_HEIGHT + 2)) and not dogui:
                if GameWorld.rswitch and not (pathlock or MoveLock):
                    try:
                        pathclass.killswitch = True
                    except NameError:
                        pass
                    try:
                        marker.killswitch = True
                        libtcod.console_clear(toplayer)
                    except NameError:
                        pass
                    marker = PathMarker(GameWorld.window,handle_mouse('cx'),handle_mouse('cy'))
                    marker.start()
                    mxpos = PX + handle_mouse('cx') - (SCREEN_WIDTH - VIEW_WIDTH - 2)
                    mypos = PY + handle_mouse('cy') - 2
                    pathclass = Pathfinder(GameWorld.wobstructed[GameWorld.curz],GameWorld.flood[GameWorld.curz],PCX,PCY,mxpos,mypos)
                    pathclass.start()
                elif GameWorld.setupdone and not (pathlock or MoveLock):
                    try:
                        pathclass.killswitch = True
                    except NameError:
                        pass
                    try:
                        circle.killswitch = True
                        circle.clearCircle()
                    except NameError:
                        pass
                    marker = PathMarker(GameWorld.window,handle_mouse('cx'),handle_mouse('cy'))
                    marker.start()
                    mxpos = PX + handle_mouse('cx') - (SCREEN_WIDTH - VIEW_WIDTH - 2)
                    mypos = PY + handle_mouse('cy') - 2
                    pathclass = Pathfinder(GameWorld.ffobdict,GameWorld.flood[GameWorld.curz],PCX,PCY,mxpos,mypos)
                    pathclass.start()
                else:
                    pathlock = False
                
        if handle_mouse('dx') + handle_mouse('dy') != 0:
            movetime = time.time()

        if not killkeycheck:
            if key.vk == libtcod.KEY_ENTER and key.lalt:
                if not libtcod.console_is_fullscreen():
                    libtcod.sys_set_renderer(libtcod.RENDERER_SDL)
                    libtcod.console_set_fullscreen(not libtcod.console_is_fullscreen())
                    pygame.mixer.init()
                    pygame.mixer.set_num_channels(32)
                else:
                    libtcod.console_set_fullscreen(not libtcod.console_is_fullscreen())
                    libtcod.sys_set_renderer(libtcod.RENDERER_SDL)
                    pygame.mixer.init()
                    pygame.mixer.set_num_channels(32)

            elif key.lctrl and key.c == ord('q'):
                return True

            elif movekeys.get(key.vk):
                if DOSCREEN == 1:
                    if NoKeys == False:
                        playerx = max(min(playerx + movekeys[key.vk][0],MAP_WIDTH - VIEW_WIDTH),0)
                        playery = max(min(playery + movekeys[key.vk][1],MAP_HEIGHT - VIEW_HEIGHT),0)
                elif DOSCREEN == 2:
                    if not MoveLock and GameWorld.setupdone:
                        if time.time() - lastmove < 0.15:
                            pass
                        else:
                            try:
                                pathclass.killswitch = True
                            except NameError:
                                pass
                            lastmove = time.time()
                            PX = PX + movekeys[key.vk][0]
                            PCX = PCX + movekeys[key.vk][0]
                            PY = PY + movekeys[key.vk][1]
                            PCY = PCY + movekeys[key.vk][1]
                            adjustScreen()
                            GameWorld.handlePC()
                            if GameWorld.rswitch:
                                if PCX in [0,RMAP_WIDTH - 1] or PCY in [0,RMAP_HEIGHT - 1] and not killmenu:
                                    GameWorld.leaveRegion()
                else:
                    playerx = playerx + movekeys[key.vk][0]
                    playery = playery + movekeys[key.vk][1]

            elif (key.vk == libtcod.KEY_ESCAPE or handle_mouse('rbutton_pressed')) and (DOSCREEN == 1 or MenuSetting == 'NoWorlds'):
                if NoKeys == False:
                    playery = 1
                    DOSCREEN = 0
                    libtcod.console_clear(0)
                    doIntroSetup()

            elif key.vk == libtcod.KEY_SPACE:
                if DOSCREEN == 2 and GameWorld.setupdone:
                    if not GameWorld.windowlock:
                        GameWorld.doPause()

            elif handle_mouse('rbutton_pressed') and DOSCREEN == 2:
                if GameWorld.rswitch == True:
                    if not GameWorld.windowlock:
                        if handle_mouse('cx') > (SCREEN_WIDTH - VIEW_WIDTH) - 3 and handle_mouse('cx') < (SCREEN_WIDTH - 2) and \
                           handle_mouse('cy') > 1 and handle_mouse('cy') < 2 + VIEW_HEIGHT:
                            mxpos = handle_mouse('cx') - (SCREEN_WIDTH - VIEW_WIDTH - 2) + PX
                            mypos = handle_mouse('cy') - 2 + PY
                            ox,oy = handle_mouse('cx'),handle_mouse('cy') - 1
                            GameWorld.doActionMenu(mxpos,mypos,ox,oy)

            elif key.c == ord('<'):
                if DOSCREEN == 2:
                    if GameWorld.rswitch and not MoveLock and not (pathlock or MoveLock):
                        try:
                            if GameWorld.zgrid[GameWorld.curz]['%s,%s' % (PCX,PCY)][5] in ['up-stairs','up-ladder']:
                                GameWorld.climbStairs(PCX,PCY)
                        except:
                            if not cannotleave:
                                try:
                                    pathclass.killswitch = True
                                except NameError:
                                    pass
                                if not GameWorld.windowlock:
                                    time.sleep(0.3)
                                    GameWorld.leaveRegion()
                            
            elif key.c == ord('>'):
                if DOSCREEN == 2:
                    if not GameWorld.rswitch and not MoveLock:
                        try:
                            pathclass.killswitch = True
                        except:
                            pass
                        MouseLock = True
                        pathlock = True
                        MoveLock = True
                        Clouds.killswitch = True
                        GameWorld.curregion = [PCX,PCY]
                        libtcod.console_set_default_background(wrwindow, libtcod.black)
                        libtcod.console_clear(wrwindow)
                        rthread = threading.Thread(target=GameWorld.doRegion)
                        rthread.start()
                    elif GameWorld.rswitch and not MoveLock and not (pathlock or MoveLock):
                        if GameWorld.zgrid[GameWorld.curz].get('%s,%s' % (PCX,PCY)):
                            try:
                                if GameWorld.zgrid[GameWorld.curz]['%s,%s' % (PCX,PCY)][5] in ['down-stairs','down-ladder']:
                                    GameWorld.descendStairs(PCX,PCY)
                            except IndexError:
                                pass

            elif key.c == ord('-'):
                if DOSCREEN == 2:
                    if GameWorld.rswitch and not MoveLock and not (pathlock or MoveLock):
                        GameWorld.PCDamage = min(GameWorld.PCDamage + 10,GameWorld.PCHP)
                        GameWorld.PCManaDrain = min(GameWorld.PCManaDrain + 10,GameWorld.PCMP)
                        GameWorld.PCPhase = 0
                        GameWorld.updateStatus()
                    elif not GameWorld.setupdone:
                        ButtonList = []
                        libtcod.console_clear(0)
                        doScreenSetup()
                        libtcod.console_clear(wiwindow)
                        DrawTerrain(wpwindow,doClouds = True)
                        libtcod.console_set_default_background(wpfxwindow,libtcod.magenta)
                        libtcod.console_clear(wpfxwindow)
                        GameWorld.displayCity()
                        nborderbutton = ButtonBox(wswindow, 5, 44, '+ Borders', '+')

            elif key.c == ord('+'):
                if DOSCREEN == 2:
                    if GameWorld.rswitch and not MoveLock and not (pathlock or MoveLock):
                        GameWorld.PCDamage = max(GameWorld.PCDamage - 10,0)
                        GameWorld.PCManaDrain = max(GameWorld.PCManaDrain - 10,0)
                        GameWorld.updateStatus()
                    elif not GameWorld.setupdone:
                        ButtonList = []
                        libtcod.console_clear(0)
                        doScreenSetup()
                        DrawTerritory(wpwindow,doClouds = True)
                        libtcod.console_clear(wiwindow)
                        libtcod.console_set_default_background(wpfxwindow,libtcod.magenta)
                        libtcod.console_clear(wpfxwindow)
                        GameWorld.displayCity()
                        nborderbutton = ButtonBox(wswindow, 5, 44, '- Borders', '-')

            elif key.c == ord(','):
                if DOSCREEN == 2 and GameWorld.rswitch:
                    if not MoveLock and not KeyLock:
                        GameWorld.getItem()

            elif key.c == ord('@'):
                if DOSCREEN == 2 and GameWorld.setupdone:
                    if GameWorld.showclock:
                        GameWorld.showclock = False
                    else:
                        GameWorld.showclock = True

            elif key.c == ord('b') or (key.vk == libtcod.KEY_ESCAPE and GameWorld.cmopen):
                if DOSCREEN == 2:
                    if GameWorld.rswitch:
                        if GameWorld.setupdone:
                            if GameWorld.invopen:
                                GameWorld.doInventory()
                            elif GameWorld.optopen:
                                GameWorld.doOptions()
                            GameWorld.doConstruction()
                    else:
                        for Button in ButtonList:
                            if Button.text == 'Begin Adventuring Here':
                                pygame.mixer.music.fadeout(4000)
                                MouseLock = True
                                ButtonList = []
                                MenuList = []
                                GameWorld.windowswitch = True
                                DoMessageLog = True
                                libtcod.console_set_default_background(wrwindow, libtcod.black)
                                doScreenSetup()
                                PX,PY = 0,0
                                libtcod.console_set_default_background(wpfxwindow,libtcod.magenta)
                                libtcod.console_clear(wpfxwindow)
                                GameWorld.displayCity()
                                DrawTerrain(wpwindow)
                                gthread = threading.Thread(target=GameWorld.setupStart)
                                gthread.start()

            elif key.c == ord('c'):
                if DOSCREEN == 1:
                    if WorldGoing == False:
                        if NamingDone == True and CreatureDone == False:
                            libtcod.console_set_default_background(wswindow, bgcolor)
                            ButtonList = []
                            libtcod.console_clear(wgwindow)
                            doScreenSetup()
                            NewWorldCreatures = WorldCreatures()
                            NewWorldCreatures.start()

            elif key.c == ord('g'):
                if DOSCREEN == 1:
                    if WorldGoing == False:
                        CreatureDone = False
                        NamingDone = False
                        DoScaleLayer = False
                        playMusic('music\\wav\\Cult-worldbuilder.wav')
                        libtcod.console_set_default_background(wgwindow, libtcod.black)
                        libtcod.console_clear(wgwindow)
                        doScreenSetup()
                        NewWorld = World()
                        NewWorld.start()
                elif DOSCREEN == 2 and GameWorld.rswitch:
                    for Button in MGButtonList:
                        if Button[3] == 'Ground View':
                            GameWorld.groundView()
                            break

            elif key.c == ord('h'):
                if DOSCREEN == 1:
                    if WorldGoing == False:
                        if WorldDone == True:
                            if CreatureDone == True:
                                libtcod.console_set_default_background(wswindow, bgcolor)
                                ButtonList = []
                                libtcod.console_clear(wgwindow)
                                doScreenSetup()
                                NewWorldHistory = WorldHistory()
                                NewWorldHistory.start()
                                
            elif key.c == ord('i') or (key.vk == libtcod.KEY_ESCAPE and GameWorld.invopen):
                if DOSCREEN == 2 and GameWorld.setupdone:
                    if GameWorld.optopen:
                        GameWorld.doOptions()
                    elif GameWorld.cmopen:
                        GameWorld.doConstruction()
                    GameWorld.doInventory()

            elif key.c == ord('m'):
                if DOSCREEN == 4 and relswitch:
                    ButtonList = []
                    Atlas.loadRelationsMap()

            elif key.c == ord('n'):
                if DOSCREEN == 1:
                    if WorldGoing == False:
                        if WorldDone == True and NamingDone == False:
                            scaleswitch = False
                            DoScaleLayer = False
                            doScreenSetup()
                            NewWorldNames = WorldNaming()
                            NewWorldNames.start()

            elif key.c == ord('o') or (key.vk == libtcod.KEY_ESCAPE and GameWorld.optopen):
                if DOSCREEN == 2 and GameWorld.setupdone:
                    if GameWorld.invopen:
                        GameWorld.doInventory()
                    elif GameWorld.cmopen:
                        GameWorld.doConstruction()
                    GameWorld.doOptions()

            elif key.c == ord('s'):
                if DOSCREEN == 1:
                    if WorldGoing == False:
                        if WorldDone == True and NamingDone == False:
                            if scaleswitch == False:
                                playerx,playery = 0,0
                                scalepic = libtcod.image_from_console(wgwindow)
                                libtcod.image_scale(scalepic, VIEW_WIDTH * 2, VIEW_HEIGHT * 2)

                                DoScaleLayer = True
                                libtcod.image_blit_2x(scalepic, toplayer, 0, 0)

                                ButtonList = []
                                doScreenSetup()

                                libtcod.console_set_default_foreground(wswindow, hcolor)
                                libtcod.console_print_ex(wswindow, 9, ((SCREEN_HEIGHT - 2) / 2) - 11, libtcod.BKGND_NONE, libtcod.CENTER, 'Terrain gen\nfinished!')

                                libtcod.console_set_default_foreground(wswindow, libtcod.white)
                                libtcod.console_print_ex(wswindow, 9, ((SCREEN_HEIGHT - 2) / 2) - 8, libtcod.BKGND_NONE, libtcod.CENTER, 'To move on to\nfeature naming,\ntype \'n\'.\n\nOtherwise,\npress \'g\' to\ngenerate a\nnew map.')

                                libtcod.console_print_ex(wswindow, 9, ((SCREEN_HEIGHT - 2) / 2) - 4, libtcod.BKGND_NONE, libtcod.CENTER, 'To view a scaled\ndown version of\nthe world,\npress \'s\'.')

                                genbutton = ButtonBox(wswindow, 6, ((SCREEN_HEIGHT - 2) / 2) + 2, 'New Map', 'g')
                                namebutton = ButtonBox(wswindow, 5, ((SCREEN_HEIGHT - 2) / 2) + 6, 'Name Gen.', 'n')
                                scalebutton = ButtonBox(wswindow, 4, ((SCREEN_HEIGHT - 2) / 2) + 10, 'Unscale Map', 's')
                                scaleswitch = True
                            else:
                                DoScaleLayer = False
                                libtcod.console_clear(toplayer)
                                ButtonList = []
                                doScreenSetup()

                                libtcod.console_set_default_foreground(wswindow, hcolor)
                                libtcod.console_print_ex(wswindow, 9, ((SCREEN_HEIGHT - 2) / 2) - 11, libtcod.BKGND_NONE, libtcod.CENTER, 'Terrain gen\nfinished!')

                                libtcod.console_set_default_foreground(wswindow, libtcod.white)
                                libtcod.console_print_ex(wswindow, 9, ((SCREEN_HEIGHT - 2) / 2) - 8, libtcod.BKGND_NONE, libtcod.CENTER, 'To move on to\nfeature naming,\ntype \'n\'.\n\nOtherwise,\npress \'g\' to\ngenerate a\nnew map.')

                                libtcod.console_print_ex(wswindow, 9, ((SCREEN_HEIGHT - 2) / 2) - 4, libtcod.BKGND_NONE, libtcod.CENTER, 'To view a scaled\nup version of\nthe world,\npress \'s\'.')

                                genbutton = ButtonBox(wswindow, 6, ((SCREEN_HEIGHT - 2) / 2) + 2, 'New Map', 'g')
                                namebutton = ButtonBox(wswindow, 5, ((SCREEN_HEIGHT - 2) / 2) + 6, 'Name Gen.', 'n')
                                scalebutton = ButtonBox(wswindow, 5, ((SCREEN_HEIGHT - 2) / 2) + 10, 'Scale Map', 's')
                                scaleswitch = False
                    
        if DOSCREEN == 2:
            if GameWorld.rswitch == True:
                limitx,limity = RMAP_WIDTH,RMAP_HEIGHT
            else:
                limitx,limity = MAP_WIDTH,MAP_HEIGHT
            PY = min(max(PY,0),limity - (VIEW_HEIGHT / 2))
            PX = min(max(PX,0),limitx - (VIEW_WIDTH / 2))
            PCY = min(max(PCY,0),limity)
            PCX = min(max(PCX,0),limitx)

def adjustScreen():
    global PX, PY, PCX, PCY, GameWorld
    if GameWorld.rswitch == True:
        limitx,limity = RMAP_WIDTH,RMAP_HEIGHT
    else:
        limitx,limity = MAP_WIDTH,MAP_HEIGHT
    if (PCX,PCY) != (PX - (VIEW_WIDTH / 2) - 1,PY - (VIEW_HEIGHT / 2)):
        PY = min(max(PCY - (VIEW_HEIGHT / 2),0),limity - VIEW_HEIGHT)
        PX = min(max(PCX - (VIEW_WIDTH / 2) + 1,0),limitx - VIEW_WIDTH)

####################################
# V. Screen Change Functions       #
####################################

# These prevent the game from having to loop through needless cycles.

def doScreenSetup():
    global NoRefresh,NoButtons,freeze,ButtonList

    NoRefresh,NoButtons,NoMenus,freeze = True,True,True,True
    lock.acquire()
    libtcod.console_set_default_background(0, libtcod.black)                                   
    libtcod.console_set_default_background(wiwindow, bgcolor2)
    libtcod.console_set_default_background(wswindow, bgcolor)
    libtcod.console_clear(wswindow)
    libtcod.console_clear(wiwindow)
    for x in range(SCREEN_WIDTH):
        for y in range(SCREEN_HEIGHT):
            libtcod.console_print_ex(0,x,y,libtcod.BKGND_SET,libtcod.LEFT,' ')

    for Button in ButtonList:
        Button.drawn = False
        Button.redrawbox = True

    libtcod.console_set_default_foreground(0, libtcod.white)
    libtcod.console_print_ex(0, 46 + ((SCREEN_WIDTH - 102) / 2), 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercape)))
    libtcod.console_set_default_foreground(0, libtcod.white)

    libtcod.console_set_default_foreground(0, libtcod.white)
    libtcod.console_print_ex(0, 73 + ((SCREEN_WIDTH - 102) / 2), 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercapw)))
    libtcod.console_set_default_foreground(0, libtcod.white)

    for x in range(24):
        for y in range(2):
            char = [x,44 + y,255]
            libtcod.console_print_ex(0,48 + ((SCREEN_WIDTH - 102) / 2) + x,y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
    
    libtcod.console_print_ex(0, 19, 0, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercapn)))
    libtcod.console_print_ex(0, 19, 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercorner)))
    libtcod.console_print_ex(0, 19, VIEW_HEIGHT + 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(border3waye)))
    libtcod.console_print_ex(0, SCREEN_WIDTH - 2, 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercorner)))
    libtcod.console_print_ex(0, SCREEN_WIDTH - 1, 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercape)))
    libtcod.console_print_ex(0, SCREEN_WIDTH - 2, 0, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercapn)))
    libtcod.console_print_ex(0, SCREEN_WIDTH - 2, VIEW_HEIGHT + 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercorner)))
    libtcod.console_print_ex(0, SCREEN_WIDTH - 1, VIEW_HEIGHT + 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercape)))
    for y in range(VIEW_HEIGHT + 2)[1:-1] + range(SCREEN_HEIGHT)[VIEW_HEIGHT + 2:-1]:
        libtcod.console_set_default_foreground(0, libtcod.white)
        borderv = bordervchars[y % 3]
        libtcod.console_print_ex(0, (SCREEN_WIDTH - VIEW_WIDTH) - 3, y + 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(borderv)))
    for y in range(VIEW_HEIGHT + 2)[1:-1] + range(SCREEN_HEIGHT)[VIEW_HEIGHT + 2:-1]:
        libtcod.console_set_default_foreground(0, libtcod.white)
        borderv = bordervchars[y % 3]
        libtcod.console_print_ex(0, SCREEN_WIDTH - 2, y + 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(borderv)))
    for x in range(SCREEN_WIDTH - VIEW_WIDTH)[:-3]:
        libtcod.console_set_default_foreground(0, libtcod.white)
        borderh = borderhchars[x % 3]
        libtcod.console_print_ex(0, x, 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(borderh)))
    for x in range(VIEW_WIDTH + 1)[1:27 + ((SCREEN_WIDTH - 102) / 2)] + range(VIEW_WIDTH + 1)[55 + ((SCREEN_WIDTH - 102) / 2):]:
        libtcod.console_set_default_foreground(0, libtcod.white)
        borderh = borderhchars[x % 3]
        libtcod.console_print_ex(0, x + (SCREEN_WIDTH - VIEW_WIDTH) - 3, 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(borderh)))
    for x in range(VIEW_WIDTH + 2)[1:-1]:
        libtcod.console_set_default_foreground(0, libtcod.white)
        borderh = borderhchars[x % 3]
        libtcod.console_print_ex(0, x + (SCREEN_WIDTH - VIEW_WIDTH) - 3, VIEW_HEIGHT + 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(borderh)))
    if DoMessageLog:
        libtcod.console_print_ex(0, (SCREEN_WIDTH - (VIEW_WIDTH / 2)) - 9, VIEW_HEIGHT + 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercape)))
        libtcod.console_print_ex(0, (SCREEN_WIDTH - (VIEW_WIDTH / 2)) - 8, VIEW_HEIGHT + 2, libtcod.BKGND_NONE, libtcod.LEFT, ' Message Log ')
        libtcod.console_print_ex(0, (SCREEN_WIDTH - (VIEW_WIDTH / 2)) + 5, VIEW_HEIGHT + 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercapw)))
    NoRefresh,NoButtons,NoMenus,freeze = False,False,False,False
    lock.release()

def doIntroSetup():
    global SCREEN_WIDTH, SCREEN_HEIGHT, TextList, LightList, titlepic, MenuList, playery, DOSCREEN, Clouds, \
           introwindow, IntroBG, wgwindow, MouseLock, IntroHover

    IntroHover = False
    MouseLock = False

    try:
        Clouds.killswitch = True
        GameWorld.killswitch = True
    except:
        pass

    for y in range(SCREEN_HEIGHT):
        for x in range(SCREEN_WIDTH):
            libtcod.map_set_properties(intromap, x, y, True, True)

    introwindow = libtcod.console_new(28,38)

    DOSCREEN = 0
    libtcod.console_set_default_background(0,libtcod.Color(2,0,0))
    libtcod.console_clear(0)
    playery = 1
    MenuList = []

    try:
        libtcod.console_delete(wgwindow)
    except:
        pass
    playMusic('music\\wav\\Cult-title.wav',-1)

    title = []
    for line in range(1927,1941):
        for charpos in range(24):
            char = [charpos,line,255]
            title.append(char)
        for charpos in range(24):
            char = [charpos,line + 14,255]
            title.append(char)
        title.append('break')

    wgbutton = []
    for line in range(28,32):
        for charpos in range(18):
            char = [charpos,line,255]
            wgbutton.append(char)
        wgbutton.append('break')

    webutton = []
    for line in range(32,36):
        for charpos in range(18):
            char = [charpos,line,255]
            webutton.append(char)
        webutton.append('break')

    wabutton = []
    for line in range(36,40):
        for charpos in range(18):
            char = [charpos,line,255]
            wabutton.append(char)
        wabutton.append('break')

    wobutton = []
    for line in range(40,44):
        for charpos in range(18):
            char = [charpos,line,255]
            wobutton.append(char)
        wobutton.append('break')

    if SCREEN_WIDTH != 100:
        modx = float(SCREEN_WIDTH) / float(100)
    else:
        modx = 1.0
    if SCREEN_HEIGHT != 70:
        mody = float(SCREEN_HEIGHT) / float(70)
    else:
        mody = 1.0

    mod = (modx + mody) / 2.0
    
    CurText = FadeText(title, (SCREEN_WIDTH / 2), 2, align='center', fadefrom=libtcod.black, fadeto=libtcod.white, \
                       con=GraphicsLayer).start()

    CurText = FadeText(wgbutton, 14, (SCREEN_HEIGHT / 2) - 4, align='center', fadefrom=libtcod.white, fadeto=libtcod.darkest_grey, \
                       hookmethod=introWorldGen, hoverhook = WGHover, unhoverhook = IntroHoverWipe, con=GraphicsLayer, domouse=True).start()

    CurText = FadeText(webutton, 14, (SCREEN_HEIGHT / 2) + 8, align='center', fadefrom=libtcod.white, fadeto=libtcod.darkest_grey, \
                       hookmethod=introWorldStart, hoverhook = WEHover, unhoverhook = IntroHoverWipe, con=GraphicsLayer, domouse=True).start()

    CurText = FadeText(wabutton, SCREEN_WIDTH - 14, (SCREEN_HEIGHT / 2) - 4, align='center', fadefrom=libtcod.white, fadeto=libtcod.darkest_grey, \
                       hookmethod=introWorldAtlas, hoverhook = WAHover, unhoverhook = IntroHoverWipe, con=GraphicsLayer, domouse=True).start()

    CurText = FadeText(wobutton, SCREEN_WIDTH - 14, (SCREEN_HEIGHT / 2) + 8, align='center', fadefrom=libtcod.white, fadeto=libtcod.darkest_grey, \
                       hookmethod=introSettings, hoverhook = WOHover, unhoverhook = IntroHoverWipe, con=GraphicsLayer, domouse=True).start()

    lightwindow = libtcod.console_new(int(42 * mod) * 2,int(42*mod) * 2)
    IntroBG = IntroGraphics((SCREEN_WIDTH / 2),(SCREEN_HEIGHT / 2),14,30,60,color=candlecolor,con = introwindow,lightcon = lightwindow, \
                            xmod = 6, ymod = 4)
    IntroBG.start()
##    libtcod.console_set_default_foreground(introwindow, libtcod.white)
##    libtcod.console_print_ex(introwindow, 0, 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercapw)))
##    libtcod.console_print_ex(introwindow, 1, 0, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercapn)))
##    libtcod.console_print_ex(introwindow, 1, 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercorner)))
##    libtcod.console_print_ex(introwindow, 0, SCREEN_HEIGHT - 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercapw)))
##    libtcod.console_print_ex(introwindow, 1, SCREEN_HEIGHT - 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercaps)))
##    libtcod.console_print_ex(introwindow, 1, SCREEN_HEIGHT - 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercorner)))
##    libtcod.console_print_ex(introwindow, SCREEN_WIDTH - 1, 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercape)))
##    libtcod.console_print_ex(introwindow, SCREEN_WIDTH - 2, 0, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercapn)))
##    libtcod.console_print_ex(introwindow, SCREEN_WIDTH - 2, 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercorner)))
##    libtcod.console_print_ex(introwindow, SCREEN_WIDTH - 1, SCREEN_HEIGHT - 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercape)))
##    libtcod.console_print_ex(introwindow, SCREEN_WIDTH - 2, SCREEN_HEIGHT - 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercaps)))
##    libtcod.console_print_ex(introwindow, SCREEN_WIDTH - 2, SCREEN_HEIGHT - 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercorner)))
##    libtcod.console_set_default_foreground(introwindow, libtcod.white)
##    for y in range(SCREEN_HEIGHT)[2:-2]:
##        libtcod.console_set_default_foreground(introwindow, libtcod.white)
##        borderv = bordervchars[y % 3]
##        libtcod.console_print_ex(introwindow, 1, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(borderv)))
##    for y in range(SCREEN_HEIGHT)[2:-2]:
##        libtcod.console_set_default_foreground(introwindow, libtcod.white)
##        borderv = bordervchars[y % 3]
##        libtcod.console_print_ex(introwindow, SCREEN_WIDTH - 2, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(borderv)))
##    for x in range(SCREEN_WIDTH)[2:-2]:
##        libtcod.console_set_default_foreground(introwindow, libtcod.white)
##        borderh = borderhchars[x % 3]
##        libtcod.console_print_ex(introwindow, x, 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(borderh)))
##    for x in range(SCREEN_WIDTH)[2:-2]:
##        libtcod.console_set_default_foreground(introwindow, libtcod.white)
##        borderh = borderhchars[x % 3]
##        libtcod.console_print_ex(introwindow, x, SCREEN_HEIGHT - 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(borderh)))

def IntroHoverWipe():
    global IntroHover,IntroBG
    IntroHover = False
    IntroBG.paused = False

def WGHover():
    global IntroBG,IntroHover
    IntroBG.paused = True
    IntroHover = 6

def WEHover():
    global IntroBG,IntroHover
    IntroBG.paused = True
    IntroHover = 7

def WAHover():
    global IntroBG,IntroHover
    IntroBG.paused = True
    IntroHover = 8

def WOHover():
    global IntroBG,IntroHover
    IntroBG.paused = True
    IntroHover = 9

def doWorldGenSetup():
    global SCREEN_HEIGHT, VIEW_HEIGHT, SCREEN_WIDTH, VIEW_WIDTH, wgwindow, wiwindow, wswindow

    wgwindow = libtcod.console_new(MAP_WIDTH, MAP_HEIGHT)
    wiwindow = libtcod.console_new(VIEW_WIDTH, SCREEN_HEIGHT - VIEW_HEIGHT - 3)
    wswindow = libtcod.console_new(SCREEN_WIDTH - VIEW_WIDTH - 3,SCREEN_HEIGHT - 2)

    libtcod.console_set_default_foreground(wswindow, libtcod.white)
    libtcod.console_print_ex(wswindow, 9, 3, libtcod.BKGND_NONE, libtcod.CENTER, \
                                    "Press \'G\' or\n" \
                                    "click the button\n" \
                                    "below to generate\n" \
                                    "a new map.\n\n" \
                                    "Press the\n" \
                                    "escape key to\n"
                                    "return to the\n" \
                                    "main menu.\n\n" \
                                    "You can use the\n" \
                                    "directional keys\n" \
                                    "and numeric pad\n" \
                                    "to navigate the\n" \
                                    "map.\n\n" \
                                    "You can also\n" \
                                    "click and drag\n" \
                                    "the map with\n" \
                                    "the mouse.")

    genbutton = ButtonBox(wswindow, 3, 25, 'Generate Map', 'g')
    doScreenSetup()
    libtcod.console_set_default_background(wiwindow, bgcolor2)

def doWorldAtlasSetup():
    global SCREEN_HEIGHT, VIEW_HEIGHT, SCREEN_WIDTH, VIEW_WIDTH, \
           wawindow, wiwindow, wswindow, wgwindow, wlist, playery, MenuList

    playery,MenuList = 1,[]

    wgwindow = libtcod.console_new(MAP_WIDTH, MAP_HEIGHT)
    wawindow = libtcod.console_new(MAP_WIDTH, MAP_HEIGHT)
    wiwindow = libtcod.console_new(VIEW_WIDTH, SCREEN_HEIGHT - VIEW_HEIGHT - 3)
    wswindow = libtcod.console_new(SCREEN_WIDTH - VIEW_WIDTH - 3,SCREEN_HEIGHT - 2)

    libtcod.console_set_default_background(wswindow, bgcolor)
    libtcod.console_rect(wswindow,0,0,SCREEN_WIDTH - VIEW_WIDTH - 3,SCREEN_HEIGHT - 2,False,libtcod.BKGND_SET)
    libtcod.console_set_default_foreground(wswindow, libtcod.white)
    
    libtcod.console_set_default_foreground(0, libtcod.white)
    libtcod.console_print_ex(0, 56 + ((SCREEN_WIDTH - 102) / 2), 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercape)))
    libtcod.console_set_default_foreground(0, libtcod.white)   
    
    libtcod.console_set_default_foreground(0, libtcod.white)
    libtcod.console_print_ex(0, 63 + ((SCREEN_WIDTH - 102) / 2), 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercapw)))
    libtcod.console_set_default_foreground(0, libtcod.white)
    borderh = borderhchars[0 % 3]
    libtcod.console_print_ex(0, 19, 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercorner)))
    libtcod.console_print_ex(0, 19, 0, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercapn)))
    libtcod.console_print_ex(0, SCREEN_WIDTH - 2, 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercorner)))
    libtcod.console_print_ex(0, SCREEN_WIDTH - 2, 0, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercapn)))
    libtcod.console_print_ex(0, SCREEN_WIDTH - 1, 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercape)))
    libtcod.console_print_ex(0, SCREEN_WIDTH - 2, VIEW_HEIGHT + 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercorner)))
    libtcod.console_print_ex(0, SCREEN_WIDTH - 1, VIEW_HEIGHT + 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercape)))
    for y in range(SCREEN_HEIGHT)[1:-1]:
        libtcod.console_set_default_foreground(0, libtcod.white)
        borderv = bordervchars[y % 3]
        libtcod.console_print_ex(0, (SCREEN_WIDTH - VIEW_WIDTH) - 3, y + 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(borderv)))
    for y in range(SCREEN_HEIGHT)[1:-1]:
        libtcod.console_set_default_foreground(0, libtcod.white)
        borderv = bordervchars[y % 3]
        libtcod.console_print_ex(0, SCREEN_WIDTH - 2, y + 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(borderv)))
    for x in range(SCREEN_WIDTH - VIEW_WIDTH)[:-3]:
        libtcod.console_set_default_foreground(0, libtcod.white)
        borderh = borderhchars[x % 3]
        libtcod.console_print_ex(0, x, 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(borderh)))
    for x in range(VIEW_WIDTH + 1)[1:37 + ((SCREEN_WIDTH - 102) / 2)] + range(VIEW_WIDTH + 1)[45 + ((SCREEN_WIDTH - 102) / 2):]:
        libtcod.console_set_default_foreground(0, libtcod.white)
        borderh = borderhchars[x % 3]
        libtcod.console_print_ex(0, x + (SCREEN_WIDTH - VIEW_WIDTH) - 3, 1, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(borderh)))

    wlist = os.listdir('.\\data\\world')
    wlist = filter(lambda x: x[-4:] == '.sav', wlist)
    printline = 0
    if len(wlist) > 0:
        for save in wlist:
            wlist[printline] = save[0:-4]
            printline += 1
    else:
        libtcod.console_print_ex(wswindow, 2, 4, libtcod.BKGND_NONE, libtcod.LEFT, 'No worlds are\nsaved.')

def doWorldStartSetup():
    global SCREEN_HEIGHT, SCREEN_WIDTH, MenuSetting, DOSCREEN, wpwindow, wiwindow, wswindow, wrwindow, toplayer, \
           PCRlayer, PCWlayer

    killMenus()
    libtcod.console_set_default_foreground(0, libtcod.white)

    starchars = []
    for x in range(3):
        for y in range(7):
            starchar = [29 + x,66 + y,255]
            starchars.append(starchar)
    for x in range(SCREEN_WIDTH):
        for y in range(SCREEN_HEIGHT):
            if randrange(5) == 1:
                char = choice(starchars)
                libtcod.console_print_ex(0,x,y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))

    wlist = os.listdir('.\\data\\world')
    wlist = filter(lambda x: x[-4:] == '.sav', wlist)
    printline = 0
    for x in range(6):
        for y in range(6):
            ox = (SCREEN_WIDTH / 2) - 19 + x
            oy = (SCREEN_HEIGHT / 2) - 3 + y
            char = [17 + x,66 + y,255]
            libtcod.console_print_ex(0,ox,oy,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
    for x in range(6):
        for y in range(6):
            ox = (SCREEN_WIDTH / 2) + 14 + x
            oy = (SCREEN_HEIGHT / 2) - 3 + y
            char = [23 + x,66 + y,255]
            libtcod.console_print_ex(0,ox,oy,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
    for x in range(12):
        for y in range(12):
            ox = (SCREEN_WIDTH / 2) - 6  + x
            oy = (SCREEN_HEIGHT / 2) - (((len(wlist) + 1) / 2) + 16) + y
            char = [17 + x,72 + y,255]
            libtcod.console_print_ex(0,ox,oy,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
    for x in range(12):
        for y in range(12):
            ox = (SCREEN_WIDTH / 2) - 6  + x
            oy = (SCREEN_HEIGHT / 2) + (((len(wlist) + 1) / 2) + 6) + y
            char = [17 + x,84 + y,255]
            libtcod.console_print_ex(0,ox,oy,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))

    if len(wlist) > 0:
        for save in wlist:
            wlist[printline] = save[0:-4]
            printline += 1
        playery,oplayery = 1,1
        MenuSetting = 'WStart'
        startmenu = Menu(0, (SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2) - len(wlist) + 2, wlist, align = 'center', doback = 0, title = 'Choose A World:', \
                         tcolor = libtcod.black, talign = 'center', linespace = 2, offy = -2, tback = True, fhcolor = libtcod.crimson, bannertitle = True, \
                         drawbox = True, MethodList = [(True,doStartGame)], BMethodList = [doIntroSetup]).start()
    else:
        libtcod.console_set_default_foreground(0, libtcod.white)
        libtcod.console_print_ex(0, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, libtcod.BKGND_NONE, libtcod.CENTER, 'No saved worlds.')
        MenuSetting = 'NoWorlds'

def doStartGame():
    global GameWorld, Atlas, MenuList, music
    try:
        GameWorld.killswitch = True
        time.sleep(0.5)
        del GameWorld
    except NameError:
        pass
    doScreenSetup()
    libtcod.console_set_default_background(wpwindow,libtcod.black)
    libtcod.console_clear(wpwindow)
    GameWorld = PlayWorld()
    GameWorld.world = MenuList[0].moptionlist[mplayery - 1]
    GameWorld.start()


####################################
# VI. Intro Functions              #
####################################

def doIntro():
    global titlepicnum, tpcount, introwindow, IntroBG, oldtime, IntroHover

    try:
        oldtime
    except NameError:
        oldtime = time.time()
    curtime = time.time() - oldtime
    if curtime > 0.1:
        oldtime = time.time()
        libtcod.console_set_default_foreground(introwindow,libtcod.white)
        tpnumber = tpcount % 6
        if IntroHover:
            tpnumber = IntroHover
        for x in range(28):
            for y in range(38):
                try:
                    libtcod.console_set_default_foreground(introwindow,IntroBG.candlecoldict['%s,%s' % (x + 2,y)])
                except KeyError:
                    libtcod.console_set_default_foreground(introwindow,libtcod.white)
                if IntroHover:
                    libtcod.console_set_default_foreground(introwindow,libtcod.white)
                char = [2 + x,1547 + y + (tpnumber * 38),255]
                libtcod.console_print_ex(introwindow,x,y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
        libtcod.console_blit(introwindow,0,0,28,38,0,(SCREEN_WIDTH / 2) - 14,SCREEN_HEIGHT - 38 - (SCREEN_HEIGHT / 10))
        tpcount += 1

def introWorldGen():
    global sound, IntroBG, DOSCREEN, playery, playerx, MenuList, TextList
    for text in TextList:
        del text
    TextList = []
    libtcod.sys_set_fps(LIMIT_FPS)
    libtcod.console_clear(GraphicsLayer)
    MenuList = []
    playery = 0
    playerx = 0
    DOSCREEN = 1
    wipeIntro()
    IntroBG.killswitch = True
    pygame.mixer.music.fadeout(2000)
    doWorldGenSetup()


def introWorldStart():
    global IntroBG, DOSCREEN, playery, playerx, MenuList, TextList
    for text in TextList:
        del text
    TextList = []
    libtcod.console_clear(GraphicsLayer)
    MenuList = []
    wipeIntro()
    playery = 0
    playerx = 0
    DOSCREEN = 6
    IntroBG.killswitch = True
    doWorldStartSetup()
    pygame.mixer.music.fadeout(2000)
        
def introWorldAtlas():
    global IntroBG, DOSCREEN, playery, playerx, oplayery, MenuList, Atlas, TextList
    for text in TextList:
        del text
    TextList = []
    libtcod.console_clear(GraphicsLayer)
    MenuList = []
    wipeIntro()
    doWorldAtlasSetup()
    playery = 1
    oplayery = playery
    DOSCREEN = 4
    pygame.mixer.music.fadeout(2000)
    IntroBG.killswitch = True
    Atlas = WorldAtlas()
    Atlas.start()
        
def introSettings():
    global IntroBG, DOSCREEN, playery, playerx, MenuList, TextList
    for text in TextList:
        del text
    TextList = []
    libtcod.console_clear(GraphicsLayer)
    MenuList = []
    DOSCREEN = 4
    IntroBG.killswitch = True
    wipeIntro()
    
####################################
# VII. Intro Transition            #
####################################

def wipeIntro():
    global LightList, TextList
    libtcod.console_clear(toplayer)
    for light in LightList:
        del light
    LightList = []
    libtcod.console_set_default_background(0, libtcod.Color(2,0,0))
    libtcod.console_clear(0)

####################################
# VIII. World-Drawing Functions    #
####################################

flist = ['cf', 'df', 'bf', 'ef', 'mf', 'tf']
fpdict = {'cf': [6,5,255], 'bf': [0,5,255], 'ef': [13,5,255], 'mf': [5,5,255], 'df': [4,5,255], 'tf': [8,5,255]}
fcoldict = {'cf': libtcod.Color(0,43,0), 'df': libtcod.Color(0,102,31), 'bf': libtcod.Color(51,0,0), \
            'ef': libtcod.Color(0,53,10), 'mf': libtcod.Color(43,128,30), 'tf': libtcod.Color(0,77,40)}
sllist = ['sl', 'hl', 'ml', 'dl']
slcoldict = {'sl': libtcod.Color(84,131,68), 'hl': libtcod.Color(77,22,0), 'ml': libtcod.Color(82,166,56), \
            'dl': libtcod.Color(55,77,0)}
slpdict = {'sl': [14,5,255], 'hl': [3,5,255], 'ml': [1,5,255], 'dl': [2,5,255]}
    
rivbg = libtcod.BKGND_NONE

def LoadWorld(wdict):
    global PLang, PName, worldname, wtmapdict, wfeaturedict, wheightdict, \
           wriverdict, wcavedict, wpeakdict, wforestdict, wdesertdict, \
           wtundradict, wlakedict, wisledict, woceandict, wcivdict, \
           wcitydict, wvillagedict, wcastledict, rivchardict, rivcoldict, \
           rivbgdict, tribdict, ivar, wbattledict, wterritorydict, wcreaturedict, \
           wglacierdict, wtexturedict, wbiomedict, wtempdict, wgcoldict, \
           wmountaindict, wrivdirdict, MAP_WIDTH, MAP_HEIGHT, RMAP_WIDTH, RMAP_HEIGHT

    globals()['wdict'] = wdict
    PLang = wdict['PLang']
    PName = wdict['PName']
    worldname = wdict['worldname']

    wtmapdict = wdict['wtmapdict']
    wfeaturedict = wdict['wfeaturedict']
    wheightdict = wdict['wheightdict']
    wtexturedict = wdict['wtexturedict']
    wmountaindict = wdict['wmountaindict']
    wriverdict = wdict['wriverdict']
    wcavedict = wdict['wcavedict']
    wpeakdict = wdict['wpeakdict']
    wforestdict = wdict['wforestdict']
    wdesertdict = wdict['wdesertdict']
    wtundradict = wdict['wtundradict']
    wplainsdict = wdict['wplainsdict']
    wswampdict = wdict['wswampdict']
    wglacierdict = wdict['wglacierdict']
    wgcoldict = wdict['wgcoldict']
    wlakedict = wdict['wlakedict']
    wisledict = wdict['wisledict']
    woceandict = wdict['woceandict']
    wtempdict = wdict['wtempdict']
    wcivdict = wdict['wcivdict']
    wcitydict = wdict['wcitydict']
    wvillagedict = wdict['wvillagedict']
    wcastledict = wdict['wcastledict']
    wbattledict = wdict['wbattledict']
    wterritorydict = wdict['wterritorydict']
    wcreaturedict = wdict['wcreaturedict']
    wbiomedict = wdict['wbiomedict']

    ivar = wdict['ivar']
    rivchardict = wdict['rivchardict']
    rivcoldict = wdict['rivcoldict']
    rivbgdict = wdict['rivbgdict']
    tribdict = wdict['tribdict']
    wrivdirdict = wdict['wrivdirdict']

    MAP_WIDTH = wdict['MAP_WIDTH']
    MAP_HEIGHT = wdict['MAP_HEIGHT']
    RMAP_WIDTH = wdict['RMAP_WIDTH']
    RMAP_HEIGHT = wdict['RMAP_HEIGHT']

def DrawTerrain(window,width = MAP_WIDTH, height = MAP_HEIGHT, xoffset = 0, yoffset = 0, xloc = 0, yloc = 0, doClouds = False, poslist = None):
    global Clouds

    if not poslist:
        poslist = []
        for x in range(width):
            for y in range(height):
                poslist.append((x,y))
    for pos in poslist:
        x,y = pos[0],pos[1]
        libtcod.console_set_char_background(window, x + xloc, y + yloc, wtmapdict['%s,%s' % (x + xoffset,y + yoffset)][0], libtcod.BKGND_SET)
        if doClouds:
            try:
                Clouds.ocolordict['%s,%s' % (x + xoffset,y + yoffset)] = wtmapdict['%s,%s' % (x + xoffset,y + yoffset)][0]
            except KeyError:
                pass

def DrawTexture(window,width = MAP_WIDTH,height = MAP_HEIGHT, xoffset = 0, yoffset = 0, xloc = 0, yloc = 0, poslist = None):

    if not poslist:
        poslist = []
        for x in range(width):
            for y in range(height):
                poslist.append((x,y))
    for pos in poslist:
        x,y = pos[0],pos[1]
        try:
            char = wmountaindict['%s,%s' % (x + xoffset,y + yoffset)][0]
            mcol = wmountaindict['%s,%s' % (x + xoffset,y + yoffset)][1]
            libtcod.console_set_default_foreground(window, mcol)
            libtcod.console_print_ex(window, x + xloc, y + yloc, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
        except KeyError:
            if len(wtexturedict['%s,%s' % (x + xoffset,y + yoffset)][0]) > 1:
                libtcod.console_set_default_foreground(window, wtexturedict['%s,%s' % (x + xoffset,y + yoffset)][1])
                libtcod.console_print_ex(window, x + xloc, y + yloc, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(wtexturedict['%s,%s' % (x + xoffset,y + yoffset)][0])))
            else:
                libtcod.console_set_default_foreground(window, wtexturedict['%s,%s' % (x + xoffset,y + yoffset)][1])
                libtcod.console_print_ex(window, x + xloc, y + yloc, libtcod.BKGND_NONE, libtcod.LEFT, wtexturedict['%s,%s' % (x + xoffset,y + yoffset)][0])

def DrawForests(window,width = MAP_WIDTH,height = MAP_HEIGHT, xoffset = 0, yoffset = 0, xloc = 0, yloc = 0, poslist = None):

    if not poslist:
        poslist = []
        for x in range(width):
            for y in range(height):
                poslist.append((x,y))
    for pos in poslist:
        x,y = pos[0],pos[1]
        ftype = False
        for feature in wfeaturedict['%s,%s' % (x + xoffset,y + yoffset)]:
            if feature in flist:
                ftype = feature
        if 'b' in wfeaturedict['%s,%s' % (x + xoffset,y + yoffset)]:
            ftype = False
        if ftype:
            fcol = libtcod.white
            if (float(y + yoffset) / MAP_HEIGHT * 102) < ivar[x + xoffset]:
                fcol = libtcod.white
            libtcod.console_print_ex(window, x + xloc, y + yloc, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(fpdict[ftype])))
            libtcod.console_set_char_foreground(window, x + xloc, y + yloc, fcol)

def DrawScrub(window,width = MAP_WIDTH,height = MAP_HEIGHT, xoffset = 0, yoffset = 0, xloc = 0, yloc = 0, poslist = None):

    if not poslist:
        poslist = []
        for x in range(width):
            for y in range(height):
                poslist.append((x,y))
    for pos in poslist:
        x,y = pos[0],pos[1]
        shrubtype = False
        for feature in wfeaturedict['%s,%s' % (x + xoffset,y + yoffset)]:
            if feature in sllist:
                shrubtype = feature
        if shrubtype:
            slcol = libtcod.white
            libtcod.console_print_ex(window, x + xloc, y + yloc, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(slpdict[shrubtype])))
            libtcod.console_set_char_foreground(window, x + xloc, y + yloc, slcol)

def DrawSwamp(window,width = MAP_WIDTH,height = MAP_HEIGHT, xoffset = 0, yoffset = 0, xloc = 0, yloc = 0, poslist = None):

    swkeyidx = [0, 500]
    swkeycols = [libtcod.Color(48,63,28), libtcod.Color(114,118,52)]
    swcolmap = libtcod.color_gen_map(swkeycols, swkeyidx)
    if not poslist:
        poslist = []
        for x in range(width):
            for y in range(height):
                poslist.append((x,y))
    for pos in poslist:
        x,y = pos[0],pos[1]
        for feature in wfeaturedict['%s,%s' % (x + xoffset,y + yoffset)]:
            if feature == 'sw':
                swcol = swcolmap[-(randrange(1,500))]
                swampchar = choice(swampchars)
                libtcod.console_print_ex(window, x + xloc, y + yloc, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(swampchar)))
                libtcod.console_set_char_foreground(window, x + xloc, y + yloc, libtcod.white)
                libtcod.console_set_char_background(window, x + xloc, y + yloc, swcol, libtcod.BKGND_ALPHA(0.4))

def DrawGlaciers(window,width = MAP_WIDTH,height = MAP_HEIGHT, xoffset = 0, yoffset = 0, xloc = 0, yloc = 0, poslist = None):

    gkeyidx = [0,320,420,475,477,500]
    gkeycols = [libtcod.Color(255,255,255), libtcod.Color(230,240,242), libtcod.Color(215,224,238), \
                libtcod.Color(129,155,166), libtcod.Color(230,240,242), libtcod.Color(255,255,255)]
    gcolmap = libtcod.color_gen_map(gkeycols, gkeyidx)
    if not poslist:
        poslist = []
        for x in range(width):
            for y in range(height):
                poslist.append((x,y))
    for pos in poslist:
        x,y = pos[0],pos[1]
        if wfeaturedict.get('%s,%s' % (x + xoffset,y + yoffset)):
            if 'g' in wfeaturedict['%s,%s' % (x + xoffset,y + yoffset)]:
                coef = 1.0
                for num in range(-3,4):
                    for num2 in range(-3,4):
                        if wfeaturedict.get('%s,%s' % (x + xoffset - num,y + yoffset - num2)):
                            if 'g' in wfeaturedict['%s,%s' % (x + xoffset - num,y + yoffset - num2)]:
                                pass
                            else:
                                coef = max(coef - .05,0)
                        elif ((x + xoffset - num) in range(0,MAP_WIDTH)) and ((y + yoffset - num2) in range(0,MAP_HEIGHT)):
                            coef = max(coef - .05,0)
                gcol = gcolmap[wgcoldict['%s,%s' % (x,y)]]
                gchar = wtexturedict['%s,%s' % (x,y)][0]
                libtcod.console_set_default_background(window, gcol)
                libtcod.console_print_ex(window, x + xloc, y + yloc, libtcod.BKGND_ALPHA(coef), libtcod.LEFT, chr(DoChar(gchar)))
                libtcod.console_set_char_foreground(window, x + xloc, y + yloc, libtcod.color_lerp(gcol,libtcod.Color(135,167,174),0.5))
                    



def DrawCaves(window,width = MAP_WIDTH,height = MAP_HEIGHT, xoffset = 0, yoffset = 0, xloc = 0, yloc = 0, poslist = None):

    if not poslist:
        poslist = []
        for x in range(width):
            for y in range(height):
                poslist.append((x,y))
    for pos in poslist:
        x,y = pos[0],pos[1]
        for feature in wfeaturedict['%s,%s' % (x + xoffset,y + yoffset)]:
            if feature == 'c':
                libtcod.console_print_ex(window, x + xloc, y + yloc, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(cavechar)))
                libtcod.console_set_char_foreground(window, x + xloc, y + yloc, libtcod.white)

def DrawRivers(window,width = MAP_WIDTH,height = MAP_HEIGHT, xoffset = 0, yoffset = 0, xloc = 0, yloc = 0, poslist = None):

    if not poslist:
        poslist = []
        for x in range(width):
            for y in range(height):
                poslist.append((x,y))
    for pos in poslist:
        x,y = pos[0],pos[1]
        for feature in wfeaturedict['%s,%s' % (x + xoffset,y + yoffset)]:
            if feature == 'r':
                try:
                    rivcol = rivcoldict['%s,%s' % (x + xoffset,y + yoffset)]
                    rivbg = rivbgdict['%s,%s' % (x + xoffset,y + yoffset)]
                    rivchar = rivchardict['%s,%s' % (x + xoffset,y + yoffset)]
                    if (float(y + yoffset) / MAP_HEIGHT * 102) < ivar[x + xoffset]:
                        rivcol = libtcod.color_lerp(libtcod.Color(51,255,204), libtcod.console_get_char_background(window, x + xloc, y + yloc), 0.75)
                        rivbg = libtcod.BKGND_NONE
                    libtcod.console_set_default_background(window, libtcod.Color(20,20,20))
                    libtcod.console_set_default_foreground(window, rivcol)
                    libtcod.console_print_ex(window, x + xloc, y + yloc, rivbg, libtcod.LEFT, chr(DoChar(rivchar)))
                except KeyError:
                    continue

def DrawCities(window,width = MAP_WIDTH,height = MAP_HEIGHT, xoffset = 0, yoffset = 0, xloc = 0, yloc = 0, poslist = None, drawcolors = False):

    for city in wcitydict.keys():
        cx = wcitydict[city][0][0]
        cy = wcitydict[city][0][1]
        if cx >= xoffset and cx < xoffset + width:
            if cy >= yoffset and cy < yoffset + height:
                x = cx - xoffset
                y = cy - yoffset
                if drawcolors:
                    col = wcivdict[wcitydict[city][1] + '-civcol']
                else:
                    col = libtcod.white
                libtcod.console_set_default_foreground(window, col)
                libtcod.console_print_ex(window, x + xloc, y + yloc, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(citychar)))

    for village in wvillagedict.keys():
        vx = wvillagedict[village][0][0]
        vy = wvillagedict[village][0][1]
        if vx >= xoffset and vx < xoffset + width:
            if vy >= yoffset and vy < yoffset + height:
                x = vx - xoffset
                y = vy - yoffset
                if drawcolors:
                    col = wcivdict[wvillagedict[village][1] + '-civcol']
                else:
                    col = libtcod.white
                libtcod.console_set_default_foreground(window, col)
                libtcod.console_print_ex(window, x + xloc, y + yloc, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(villagechar)))

    for castle in wcastledict.keys():
        cx = wcastledict[castle][0][0]
        cy = wcastledict[castle][0][1]
        if cx >= xoffset and cx < xoffset + width:
            if cy >= yoffset and cy < yoffset + height:
                x = cx - xoffset
                y = cy - yoffset
                if drawcolors:
                    col = wcivdict[wcastledict[castle][1] + '-civcol']
                else:
                    col = libtcod.white
                libtcod.console_set_default_foreground(window, col)
                libtcod.console_print_ex(window, x + xloc, y + yloc, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(castlechar)))

def DrawTerritory(window,width = MAP_WIDTH,height = MAP_HEIGHT, xoffset = 0, yoffset = 0, xloc = 0, yloc = 0, doClouds = False, poslist = None):
    global Clouds

    for x in range(width):
        for y in range(height):
            try:
                libtcod.console_set_char_background(window, x + xloc, y + yloc, wcivdict[wcivdict[wterritorydict['%s,%s' % (x + xoffset,y + yoffset)]] + '-civcol2'], libtcod.BKGND_ALPHA(0.8))
            except KeyError:
                pass
            if doClouds:
                try:
                    Clouds.ocolordict['%s,%s' % (x + xoffset,y + yoffset)] = wcivdict[wcivdict[wterritorydict['%s,%s' % (x + xoffset,y + yoffset)]] + '-civcol2']
                except KeyError:
                    pass

def DrawWorld(window, width = MAP_WIDTH, height = MAP_HEIGHT, xoffset = 0, yoffset = 0, \
              xloc = 0, yloc = 0, terrain = True, texture = True, forests = True, scrub = True, caves = True, \
              rivers = True, swamp = True, glaciers = True, cities = True, territory = False, drawcolors = True, \
              poslist = None):
    global NoButtons

    NoButtons,NoMenus = True,True

    if width < MAP_WIDTH:
        xoffset = xoffset - (width / 2)
        if xoffset + width > MAP_WIDTH:
            xoffset = MAP_WIDTH - width
    if height < MAP_HEIGHT:
        yoffset = yoffset - (height / 2)
        if yoffset + height > MAP_HEIGHT:
            yoffset = MAP_HEIGHT - height

    if xoffset < 0:
        xoffset = 0
    if yoffset < 0:
        yoffset = 0

    if terrain:
        DrawTerrain(window, width, height, \
                    xoffset, yoffset, xloc, yloc, \
                    poslist)

    if texture:
        DrawTexture(window, width, height, \
                    xoffset, yoffset, xloc, yloc, \
                    poslist)
        
    if forests:
        DrawForests(window, width, height, \
                    xoffset, yoffset, xloc, yloc, \
                    poslist)
    if scrub:
        DrawScrub(window, width, height, \
                  xoffset, yoffset, xloc, yloc, \
                  poslist)
    if swamp:
        DrawSwamp(window, width, height, \
                  xoffset, yoffset, xloc, yloc, \
                  poslist)
    if glaciers:
        DrawGlaciers(window, width, height, \
                     xoffset, yoffset, xloc, yloc, \
                     poslist)
    if caves:
        DrawCaves(window, width, height, \
                  xoffset, yoffset, xloc, yloc, \
                  poslist)
    if rivers:
        DrawRivers(window, width, height, \
                   xoffset, yoffset, xloc, yloc, \
                   poslist)
    if cities:
        DrawCities(window, width, height, \
                   xoffset, yoffset, xloc, yloc, drawcolors = drawcolors, \
                   poslist = None)
    if territory:
        DrawTerritory(window, width, height, \
                      xoffset, yoffset, xloc, yloc, \
                      poslist)

    NoButtons,NoMenus = False,False

####################################
# IX. Land Generation              #
####################################

class World(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        
    def run(self):
        global SCREEN_HEIGHT, VIEW_HEIGHT, SCREEN_WIDTH, VIEW_WIDTH, wiwindow, \
               wgwindow, wswindow, worldmap, wheightdict, wfeaturedict, wgpic, \
               NoKeys, WorldGoing, WorldDone, woceandict, wlakedict, wlakedict, \
               wtundradict, wcavedict, wriverdict, wlangdict, PLang, \
               rivcoldict, rivchardict, rivbgdict, ivar, worldname, PName, \
               tribdict, wtmapdict, ButtonList, scaleswitch, tivar, wtexturedict, \
               moveclouds, wtempdict, wgcoldict, wmountaindict, wrivdirdict

        # Create a precursor language using the included language module.

        WorldGoing = True
        ButtonList = []
        PLang = MakeLang()
        PName = MakeName(PLang)
        worldname = MakeName(PLang)
        scaleswitch = False

        wfeaturedict = {}
        wheightdict = {}
        rainfall = 4

        libtcod.console_set_default_foreground(wswindow, libtcod.white)
        libtcod.console_print_ex(wswindow, 9, 1, libtcod.BKGND_NONE, libtcod.CENTER, 'Map Creation')

        libtcod.console_set_default_foreground(wswindow, hcolor)
        libtcod.console_print_ex(wswindow, 9, 3, libtcod.BKGND_NONE, libtcod.CENTER, '~*~*~*~')

        wgtext = 'Generating\nterrain...'
        CurText = FadeText(wgtext, 1, 5, con=wswindow, speed=25).start()

        # Initialize the world feature dictionary.
        for x in range(MAP_WIDTH):
            for y in range(MAP_HEIGHT):
                wfeaturedict['%s,%s' % (x,y)] = []

        # Generate the terrain/altitude.
        worldmap = libtcod.heightmap_new(MAP_WIDTH,MAP_HEIGHT)
        libtcod.heightmap_add_voronoi(worldmap, randrange(2000,3000), 4, [0.6,0.7,0.8,0.9])
        libtcod.heightmap_add_voronoi(worldmap, randrange(10000,20000), 4, [1.5,1.5,1.5,1.5])
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(worldmap, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        worldmap2 = libtcod.heightmap_new(MAP_WIDTH,MAP_HEIGHT)
        libtcod.heightmap_add_voronoi(worldmap2, randrange(25,50), 4, [0.7,0.8,0.9,0.6])
        mapnoise = libtcod.noise_new(3)
        libtcod.heightmap_add_fbm(worldmap2, mapnoise, 1.5, 1.5, 1.2, 1.2, 35, 0.5, 1.5)
        libtcod.heightmap_lerp_hm(worldmap, worldmap2, worldmap, 0.03)
        worldmap3 = libtcod.heightmap_new(MAP_WIDTH,MAP_HEIGHT)
        libtcod.heightmap_add_voronoi(worldmap3, randrange(200,300), 4, [0.7,0.8,0.9,0.6])
        mapnoise = libtcod.noise_new(3)
        libtcod.heightmap_add_fbm(worldmap3, mapnoise, 1.5, 1.5, 1.2, 1.2, 35, 0.5, 1.5)
        libtcod.heightmap_lerp_hm(worldmap, worldmap3, worldmap, 0.1)
        libtcod.heightmap_scale(worldmap, 1.3)
        minmax = list(libtcod.heightmap_get_minmax(worldmap))

        # Make sure the edges of the world are water.
        xvar = {}
        sxvar = float(randrange(int(MAP_HEIGHT * 0.06),int(MAP_HEIGHT * 0.07)))
        deeplev = minmax[1] / 2
        for x in range(MAP_WIDTH):
            sxvar += randrange(-1,2) * (choice([0,1,2,3]) + choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,0.0]))
            sxvar = max(sxvar,8.0)
            xvar[x] = int(sxvar)
        for x in range(MAP_WIDTH):
            for y in range(0,xvar[x]):
                oheight = libtcod.heightmap_get_value(worldmap, x, xvar[x])
                if y > (xvar[x] * 0.7):
                    height = deeplev + (((oheight - deeplev) / (xvar[x] - int(xvar[x] * 0.7))) * (y - int(xvar[x] * 0.7)))
                else:
                    height = deeplev * randrange(98,101) * .01
                libtcod.heightmap_set_value(worldmap, x, y, height)
        xvar = {}
        sxvar = float(randrange(int(MAP_HEIGHT * 0.06),int(MAP_HEIGHT * 0.07)))
        for x in range(MAP_WIDTH):
            sxvar += randrange(-1,2) * (choice([0,1,2,3]) + choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,0.0]))
            sxvar = max(sxvar,8.0)
            xvar[x] = int(sxvar)
        for x in range(MAP_WIDTH):
            for y in range((MAP_HEIGHT - xvar[x] - 1),MAP_HEIGHT):
                oheight = libtcod.heightmap_get_value(worldmap, x, (MAP_HEIGHT - xvar[x]))
                if (MAP_HEIGHT - y - 1) > (xvar[x] * 0.7):
                    height = deeplev + (((oheight - deeplev) / (xvar[x] - int(xvar[x] * 0.7))) * ((MAP_HEIGHT - y - 1) - int(xvar[x] * 0.7)))
                else:
                    height = deeplev * randrange(98,101) * .01
                libtcod.heightmap_set_value(worldmap, x, y, height)
        yvar = {}
        syvar = float(randrange(int(MAP_HEIGHT * 0.06),int(MAP_HEIGHT * 0.07)))
        for y in range(MAP_HEIGHT):
            syvar += randrange(-1,2) * (choice([0,1,2,3]) + choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,0.0]))
            syvar = max(syvar,12.0)
            yvar[y] = int(syvar)
        for y in range(MAP_HEIGHT):
            for x in range(0,yvar[y]):
                oheight = libtcod.heightmap_get_value(worldmap, yvar[y], y)
                if x > (yvar[y] * 0.7):
                    height = deeplev + (((oheight - deeplev) / (yvar[y] - int(yvar[y] * 0.7))) * (x - int(yvar[y] * 0.7)))
                else:
                    height = deeplev * randrange(98,101) * .01
                libtcod.heightmap_set_value(worldmap, x, y, height)
        yvar = {}
        syvar = float(randrange(int(MAP_HEIGHT * 0.06),int(MAP_HEIGHT * 0.07)))
        for y in range(MAP_HEIGHT):
            syvar += randrange(-1,2) * (choice([0,1,2,3]) + choice([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,0.0]))
            syvar = max(syvar,12.0)
            yvar[y] = int(syvar)
        for y in range(MAP_HEIGHT):
            for x in range((MAP_WIDTH - yvar[y] - 1),MAP_WIDTH):
                oheight = libtcod.heightmap_get_value(worldmap, (MAP_WIDTH - yvar[y]), y)
                if (MAP_WIDTH - x - 1) > (yvar[y] * 0.7):
                    height = deeplev + (((oheight - deeplev) / (yvar[y] - int(yvar[y] * 0.7))) * ((MAP_WIDTH - x  - 1) - int(yvar[y] * 0.7)))
                else:
                    height = deeplev * randrange(98,101) * .01
                libtcod.heightmap_set_value(worldmap, x, y, height)

        # Smooth the world.
        libtcod.heightmap_kernel_transform(worldmap, 8, [0,-1,-1,-1,0,1,1,1], [1,1,0,-1,-1,-1,0,1], [0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5], int(minmax[0]), int(minmax[1])) 
        libtcod.heightmap_kernel_transform(worldmap, 8, [0,-1,-1,-1,0,1,1,1], [1,1,0,-1,-1,-1,0,1], [0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5], int(minmax[0]), int(minmax[1])) 
      
        keyidx = [0, 13, 17, 24, 28, 34, 49, 50, 59, 95, 200]
        keycols = [libtcod.Color(28,16,5), libtcod.Color(44,33,14), libtcod.Color(72,69,42), \
                   libtcod.Color(126,134,61), libtcod.Color(92,121,54), libtcod.Color(27,92,18), \
                   libtcod.Color(3,57,6), libtcod.Color(143,201,255), libtcod.Color(0,82,120), \
                   libtcod.Color(0,20,60), libtcod.Color(0,8,30)]
        colmap = libtcod.color_gen_map(keycols, keyidx)
        libtcod.console_set_default_foreground(0, libtcod.white)
        libtcod.console_print_ex(wiwindow, VIEW_WIDTH / 2, 2, libtcod.BKGND_NONE, libtcod.CENTER, 'The Land of ' + worldname)
        wgtext = choice(['Once, the %s people ruled over the known world.', \
                                'In the past, the empire of the %s stretched from sea to sea.', \
                                'Long ago, the world was populated by the ancient %s.', \
                                'According to legend, the %s people once ruled the entire world.', \
                                'Myth states that the %s had a domain that knew no bounds.']) % (PName)
        CurText = FadeText(textWrap(wgtext)[0], VIEW_WIDTH / 2, 4, con=wiwindow, speed=50, align='center').start()
        PFName = MakeName(PLang)
        wgtext = choice(['But the mysterious catastrophe now known as the \'%s\' ended the reign of the %s forever.' % (PFName, PName), \
                                'However, the %s empire fell during the great cataclysm now referred to only as the \'%s\'.' % (PName, PFName)])          
        CurText = FadeText(textWrap(wgtext)[0], VIEW_WIDTH / 2, 6, con=wiwindow, speed=50, align='center').start()

        # Generate forests.

        forestmap = libtcod.heightmap_new(MAP_WIDTH,MAP_HEIGHT)
        libtcod.heightmap_add_voronoi(forestmap, randrange(100,300), 4, [0.2,0.4,0.5,0.6])
        libtcod.heightmap_rain_erosion(forestmap, MAP_WIDTH * 142 * rainfall, 0.05, 0.5)   
        fminmax = list(libtcod.heightmap_get_minmax(forestmap))

        glaciermap = libtcod.heightmap_new(MAP_WIDTH,MAP_HEIGHT)
        libtcod.heightmap_add_voronoi(glaciermap, randrange(100,300), 4, [0.2,0.4,0.5,0.6])
        libtcod.heightmap_lerp_hm(glaciermap, worldmap, glaciermap, 0.4)
        libtcod.heightmap_rain_erosion(glaciermap, MAP_WIDTH * 142 * rainfall, 0.05, 0.5)
        gminmax = list(libtcod.heightmap_get_minmax(glaciermap))

        # Generate glaciers.

        gkeyidx = [0,320,420,475,477,500]
        gkeycols = [libtcod.Color(255,255,255), libtcod.Color(230,240,242), libtcod.Color(215,224,238), \
                    libtcod.Color(129,155,166), libtcod.Color(230,240,242), libtcod.Color(255,255,255)]
        gcolmap = libtcod.color_gen_map(gkeycols, gkeyidx)

        # Generate deserts.

        dkeyidx = [0, 12, 28, 500]
        dkeycols = [libtcod.Color(245,249,192), libtcod.Color(253,209,159), libtcod.Color(196,177,98), libtcod.Color(241,199,149)]

        desertmap = libtcod.heightmap_new(MAP_WIDTH,MAP_HEIGHT)
        dnoise = libtcod.noise_new(3)
        libtcod.heightmap_add_voronoi(desertmap, randrange(100,300), 4, [0.2,0.4,0.5,0.6])
        libtcod.heightmap_add_voronoi(desertmap, randrange(100,300), 4, [0.2,0.4,0.5,0.6])
        libtcod.heightmap_add_fbm(desertmap, dnoise, 1.0, 1.0, 0.5, 0.5, 22, 0.4, 0.8)
        libtcod.heightmap_lerp_hm(desertmap, worldmap, desertmap, 0.1)
        #libtcod.heightmap_rain_erosion(desertmap, MAP_WIDTH * 142 * rainfall, 0.0, 0.02)   
        dminmax = list(libtcod.heightmap_get_minmax(desertmap))
        dcolmap = libtcod.color_gen_map(dkeycols, dkeyidx)

        # Generate swamps.

        swkeyidx = [0, 500]
        swkeycols = [libtcod.Color(48,63,28), libtcod.Color(114,118,52)]
        
        swampmap = libtcod.heightmap_new(MAP_WIDTH,MAP_HEIGHT)
        swnoise = libtcod.noise_new(3)
        libtcod.heightmap_add_voronoi(swampmap, randrange(100,300), 4, [0.2,0.4,0.5,0.6])
        libtcod.heightmap_add_voronoi(swampmap, randrange(100,300), 4, [0.2,0.4,0.5,0.6])
        libtcod.heightmap_add_fbm(swampmap, swnoise, 1.0, 1.0, 0.5, 0.5, 22, 0.4, 0.8)
        libtcod.heightmap_lerp_hm(swampmap, worldmap, swampmap, 0.1)
        libtcod.heightmap_rain_erosion(swampmap, MAP_WIDTH * 142 * rainfall, 0.02, 0.08)   
        swminmax = list(libtcod.heightmap_get_minmax(swampmap))
        swcolmap = libtcod.color_gen_map(swkeycols, swkeyidx)

        # Generate snow.

        skeyidx = [0, 100]
        skeycols = [libtcod.Color(234,234,255), libtcod.white]

        snowmap = libtcod.heightmap_new(MAP_WIDTH,MAP_HEIGHT)
        snownoise = libtcod.noise_new(1)
        libtcod.heightmap_add_voronoi(snowmap, randrange(200,300), 4, [0.2,0.4,0.5,0.6])
        libtcod.heightmap_add_fbm(snowmap, snownoise, 1.0, 1.0, 0.5, 0.5, 22, 0.4, 0.8)
        sminmax = list(libtcod.heightmap_get_minmax(snowmap))
        scolmap = libtcod.color_gen_map(skeycols, skeyidx)

        # Establish altitude ranges for the various generation maps.

        altrange = minmax[1] - minmax[0]
        faltrange = fminmax[1] - fminmax[0]
        daltrange = dminmax[1] - dminmax[0]
        galtrange = gminmax[1] - gminmax[0]
        swaltrange = swminmax[1] - swminmax[0]
        saltrange = sminmax[1] - sminmax[0]

        wgtext = 'Adding terrain...'
        CurText = FadeText(wgtext, 1, 8, con=wswindow, speed=25).start()
        wheightlist = []
        landcount = 0

        for x in range(MAP_WIDTH):
            for y in range(MAP_HEIGHT):
                # Draw terrain height.
                altitude = libtcod.heightmap_get_value(worldmap, x, y)
                altperc = int(((minmax[1] - altitude) / altrange) * 200 - 1)
                wheightlist.append(altperc)
                if altperc > 150:
                    landcount += 1

        loopcount = 0

        while float(landcount) / float(MAP_WIDTH * MAP_HEIGHT) > 0.35:
                count = 0
                landcount = 0
                for pos in wheightlist:
                    if pos > 50 and pos < 151 + loopcount:
                        wheightlist[count] -= 1
                    if wheightlist[count] > 150:
                        landcount += 1
                    count += 1
                loopcount += 1

        count = 0
        for pos in wheightlist:
            x = count / MAP_HEIGHT
            y = count % MAP_HEIGHT 
            wheightdict['%s,%s' % (x,y)] = pos
            col = colmap[-(pos)]
            col = col + libtcod.Color(randrange(0,5),randrange(0,5),randrange(0,5))
            libtcod.console_set_char_background(wgwindow, x, y, col, libtcod.BKGND_SET)
            count += 1

        wtexturedict = {}
        wmountaindict = {}

        # Add slightly varying arctic cutoff line.
        ivar = {}
        syvar = float(randrange(int(MAP_HEIGHT * .08),int(MAP_HEIGHT * .115)))
        for x in range(MAP_WIDTH):
            syvar += randrange(-1,2) * 0.6
            ivar[x] = int(syvar)

        # Add slightly varying tropical cutoff line.
        tivar = {}
        tsyvar = float(randrange(int(MAP_HEIGHT * .08),int(MAP_HEIGHT * .115)))
        for x in range(MAP_WIDTH):
            tsyvar += randrange(-1,2) * 0.6
            tivar[x] = int(tsyvar)

        # Add beaches.        

        for y in range(MAP_HEIGHT):
            for x in range(MAP_WIDTH):
                isbeach = False
                alphperc = 0.0
                for num in range(-1,2):
                    for num2 in range(-1,2):
                        posx = min(max(x - num,0),MAP_WIDTH - 1)
                        posy = min(max(y - num2,0),MAP_HEIGHT - 1)
                        if wheightdict['%s,%s' % (x,y)] > 151 and wheightdict['%s,%s' % (posx,posy)] < 152:
                            isbeach = True
                            alphperc += 0.3
                            alphperc = min(alphperc,1.0)
                if isbeach:
                    if wfeaturedict.get('%s,%s' % (x,y)):
                        if not 'b' in wfeaturedict['%s,%s' % (x,y)]:
                            wfeaturedict['%s,%s' % (x,y)] = wfeaturedict['%s,%s' % (x,y)] + ['b']
                    else:
                        wfeaturedict['%s,%s' % (x,y)] = ['b']
                    col = libtcod.Color(253,209,159) + libtcod.Color(randrange(0,5),randrange(0,5),randrange(0,5))
                    libtcod.console_set_char_background(wgwindow, x, y, col, libtcod.BKGND_ALPHA(alphperc))
                    char = choice(beachchars)
                    libtcod.console_set_char_foreground(wgwindow, x, y, libtcod.color_lerp(libtcod.white,col,0.5))
                    libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                    wtexturedict['%s,%s' % (x,y)] = [char, libtcod.color_lerp(libtcod.white,col,0.2)]
                    if wheightdict['%s,%s' % (x,y)] > 155:
                        wheightdict['%s,%s' % (x,y)] = 152

        # Draw mountains.

        for y in range(MAP_HEIGHT):
            for x in range(MAP_WIDTH):
                if wheightdict['%s,%s' % (x,y)] >= wmlev:
                    if wheightdict['%s,%s' % (x,y)] < wmlev - 7:
                        wmountaindict['%s,%s' % (x,y)] = choice(mountaincharslow)
                    else:
                        wmountaindict['%s,%s' % (x,y)] = choice(mountaincharshigh)

        for y in range(MAP_HEIGHT):
            for x in range(MAP_WIDTH):
                if wheightdict['%s,%s' % (x,y)] >= wmlev:
                    mperc = randrange(0,101)
                    mperc = mperc * 0.01
                    c1 = libtcod.Color(112,95,61)
                    c2 = libtcod.Color(134,125,66)
                    mcol = libtcod.color_lerp(c1,c2,mperc)
                    mcol = libtcod.color_lerp(mcol,libtcod.white,0.5)
                    char = wmountaindict['%s,%s' % (x,y)]
                    wmountaindict['%s,%s' % (x,y)] = [char,mcol]
                    wtexturedict['%s,%s' % (x,y)] = [char,mcol]
                    libtcod.console_set_default_foreground(wgwindow, mcol)
                    libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))



        # Texturize water.

        for y in range(MAP_HEIGHT):
            for x in range(MAP_WIDTH):
                if wheightdict['%s,%s' % (x,y)] < 152 and \
                   'b' not in wfeaturedict['%s,%s' % (x,y)]:
                    char = choice(waterchars)
                    wcol = libtcod.color_lerp(libtcod.console_get_char_background(wgwindow, x, y),libtcod.white,0.5)
                    libtcod.console_set_default_foreground(wgwindow, wcol)
                    libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                    wtexturedict['%s,%s' % (x,y)] = [char, wcol]

        # Texturize grass.

        for y in range(MAP_HEIGHT):
            for x in range(MAP_WIDTH):
                if wheightdict['%s,%s' % (x,y)] in range(152,wmlev) and not \
                   'b' in wfeaturedict.get('%s,%s' % (x,y)) and not \
                   'd' in wfeaturedict.get('%s,%s' % (x,y)):
                    gadjust = libtcod.Color(10,20,20)
                    char = choice(grasschars)
                    libtcod.console_set_default_foreground(wgwindow, libtcod.white)
                    libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                    wtexturedict['%s,%s' % (x,y)] = [char,libtcod.white]

        wgtext = 'Adding deserts...'
        CurText = FadeText(wgtext, 1, 10, con=wswindow, speed=25).start()

        for y in range(MAP_HEIGHT):
            for x in range(MAP_WIDTH):
                # Draw deserts.
                altperc = wheightdict['%s,%s' % (x,y)]
                ddensity = libtcod.heightmap_get_value(desertmap, x, y)
                dperc = int(((dminmax[1] - ddensity) / daltrange) * 500) - 1
                if dperc > 472:
                    if wmlev > altperc > 150:
                        dcol = dcolmap[-(dperc)]
                        alphperc = 1.0 - (randrange(1,3) * 0.03)
                        for num in range(-2,3):
                            for num2 in range(-2,3):
                                oaltperc = wheightdict['%s,%s' % (x - num, y - num2)]
                                oddensity = libtcod.heightmap_get_value(desertmap, max(min(x - num,MAP_WIDTH - 1),0), max(min(y - num2,MAP_HEIGHT - 1), 0))
                                odperc = int(((dminmax[1] - oddensity) / daltrange) * 500) - 1
                                if odperc < 473 or (oaltperc > 186 or oaltperc < 147):
                                    alphperc = max(alphperc - 0.1,0.0)
                                if wheightdict['%s,%s' % (x - num, y - num2)] > wmlev - 1:
                                    libtcod.console_set_char_background(wgwindow, x - num, y - num2, libtcod.color_lerp(libtcod.console_get_char_background(wgwindow, x- num, y - num2), dcol, 0.05), \
                                                             libtcod.BKGND_SET)
                        if alphperc > 0.5:
                            if wfeaturedict.get('%s,%s' % (x,y)):
                                if not 'd' in wfeaturedict['%s,%s' % (x,y)]:
                                    wfeaturedict['%s,%s' % (x,y)] = wfeaturedict['%s,%s' % (x,y)] + ['d']
                            else:
                                wfeaturedict['%s,%s' % (x,y)] = ['d']
                            char = choice(desertchars)
                            libtcod.console_set_char_background(wgwindow, x, y, dcol, libtcod.BKGND_ALPHA(alphperc))
                            libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                            dadjust = libtcod.color_lerp(dcol,libtcod.white,0.5)
                            libtcod.console_set_char_foreground(wgwindow, x, y, dadjust)
                            wtexturedict['%s,%s' % (x,y)] = [char,dadjust]
                        

        wgtext = 'Adding swamps...'
        CurText = FadeText(wgtext, 1, 12, con=wswindow, speed=25).start()

        # Record temperature zones to the world dictionary.

        wtempdict = {}
        templist = []
        for x in range(MAP_WIDTH):
            for y in range(MAP_HEIGHT):
                templist.append([x,y])

        tropical = filter(lambda pos: pos[1] > (((MAP_HEIGHT / 4) * 3) + tivar[pos[0]]),templist)
        arctic = filter(lambda pos: (float(pos[1]) / MAP_HEIGHT * 102) < ivar[pos[0]],templist)
        temperate = filter(lambda pos: ((float(pos[1]) / MAP_HEIGHT * 102) > ivar[pos[0]]) and \
                           (pos[1] < (((MAP_HEIGHT / 4) * 3) + tivar[pos[0]])),templist)

        for tile in tropical:
            wtempdict['%s,%s' % (tile[0],tile[1])] = 'Tropical'
        for tile in arctic:
            wtempdict['%s,%s' % (tile[0],tile[1])] = 'Arctic'
        for tile in temperate:
            wtempdict['%s,%s' % (tile[0],tile[1])] = 'Temperate'

        for y in range(MAP_HEIGHT):
            for x in range(MAP_WIDTH):
                # Draw swamps.
                altperc = wheightdict['%s,%s' % (x,y)]
                swdensity = libtcod.heightmap_get_value(swampmap, x, y)
                swperc = int(((swminmax[1] - swdensity) / swaltrange) * 500) - 1
                if swperc > 480 and (float(y) / MAP_HEIGHT * 100) > ivar[x]:
                    if wmlev - 2 > altperc > 153:
                        swamp = True
                        if randrange(1,21) == 1:
                            swamp = False
                        for num in range(-1,2):
                            for num2 in range(-1,2):
                                if wfeaturedict.get('%s,%s' % (x - num, y - num2)):
                                    if 'd' in wfeaturedict['%s,%s' % (x - num, y - num2)] or 'b' in wfeaturedict['%s,%s' % (x - num,y - num2)]:
                                        swamp = False
                        if swamp:
                            swcol = swcolmap[-(randrange(1,500))]
                            if wfeaturedict.get('%s,%s' % (x,y)):
                                if not 'sw' in wfeaturedict['%s,%s' % (x,y)]:
                                    wfeaturedict['%s,%s' % (x,y)] = wfeaturedict['%s,%s' % (x,y)] + ['sw']
                            else:
                                wfeaturedict['%s,%s' % (x,y)] = ['sw']
                            libtcod.console_set_default_foreground(wgwindow, libtcod.white)
                            swampchar = choice(swampchars)
                            wtexturedict['%s,%s' % (x,y)] = [swampchar,libtcod.white]
                            libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(swampchar)))
                            libtcod.console_set_char_background(wgwindow, x, y, swcol, libtcod.BKGND_ALPHA(0.4))

        wgtext = 'Adding forests...'
        CurText = FadeText(wgtext, 1, 14, con=wswindow, speed=25).start()


        fcoldict = {'cf': libtcod.Color(0,43,0), 'df': libtcod.Color(0,102,31), 'bf': libtcod.Color(51,0,0), \
            'ef': libtcod.Color(0,53,10), 'mf': libtcod.Color(43,128,30)}
        fseed = randrange(39,43)
        fdict = {0:'cf', 1:'df', 2:'bf', 3:'ef', 4:'mf', 5:'cf', 6:'mf', 7:'cf'}  
        fpdict = {'cf': [6,5,255], 'bf': [0,5,255], 'ef': [13,5,255], 'mf': [5,5,255], 'df': [4,5,255], 'tf': [8,5,255]}
        for y in range(MAP_HEIGHT):
            for x in range(MAP_WIDTH):
                # Draw forests.
                if abs((float(y) / MAP_HEIGHT * 102) - ivar[x]) < randrange(3,6):
                    continue
                fdensity = libtcod.heightmap_get_value(forestmap, x, y)
                fperc = int(((fminmax[1] - fdensity) / faltrange) * 50) - 1
                if fperc > fseed:
                    if wmlev > wheightdict['%s,%s' % (x,y)] > wwlev:
                        forest = True
                        for num in range(-1,2):
                            for num2 in range(-1,2):
                                if wfeaturedict.get('%s,%s' % (x - num, y - num2)):
                                    if 'd' in wfeaturedict['%s,%s' % (x - num, y - num2)]:
                                        forest = False
                        if wfeaturedict.get('%s,%s' % (x,y)):
                            if 'sw' in wfeaturedict['%s,%s' % (x,y)]:
                                forest = False
                        if randrange(1,10) > 1:
                            if forest:
                                ftype = fdict[(max(min(48 - fperc,7),0))]
                                fcol = libtcod.white
                                if y > (((MAP_HEIGHT / 4) * 3) + tivar[x]):
                                    if ftype == 'cf' or ftype == 'ef' or ftype == 'mf':
                                        ftype = 'tf'
                                        fcol = libtcod.white
                                if 'b' not in wfeaturedict['%s,%s' % (x,y)]:
                                    libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(fpdict[ftype])))
                                    libtcod.console_set_char_foreground(wgwindow, x, y, fcol)
                                    libtcod.console_set_char_background(wgwindow, x, y, libtcod.color_lerp(libtcod.black,libtcod.console_get_char_background(wgwindow, x, y),0.9))
                                if wfeaturedict.get('%s,%s' % (x,y)):
                                    if not ftype in  wfeaturedict['%s,%s' % (x,y)]:
                                        wfeaturedict['%s,%s' % (x,y)] = wfeaturedict['%s,%s' % (x,y)] + [ftype]
                                else:
                                    wfeaturedict['%s,%s' % (x,y)] = [ftype]

        wgtext = 'Adding snow...'
        CurText = FadeText(wgtext, 1, 16, con=wswindow, speed=25).start()

        # Draw snow.
        for x in range(MAP_WIDTH):
            for y in range(MAP_HEIGHT):
                altperc = wheightdict['%s,%s' % (x,y)]
                sdensity = libtcod.heightmap_get_value(snowmap, x, y)
                sperc = int(((sminmax[1] - sdensity) / saltrange) * 50) - 1
                if wmlev > altperc > 151:
                    scol = scolmap[-(sperc)]
                    alphperc = 0.95 - (randrange(0,3) * 0.05)
                    for num in range(-2,3):
                        for num2 in range(-2,3):
                            oaltperc = wheightdict['%s,%s' % (x - num, y - num2)]
                            ssdensity = libtcod.heightmap_get_value(snowmap, max(min(x - num,MAP_WIDTH - 1),0), max(min(y - num2,MAP_HEIGHT - 1), 0))
                            ssperc = int(((sminmax[1] - ssdensity) / saltrange) * 50) - 1
                            if ((float(y) - num2) / MAP_HEIGHT * 100) > ivar[max(min(x - num,MAP_WIDTH - 1),0)]:
                                alphperc = max(alphperc - 0.1,0.0)
                    if wfeaturedict.get('%s,%s' % (x,y)):
                        if 'd' in wfeaturedict['%s,%s' % (x,y)]:
                            libtcod.console_set_char_background(wgwindow, x, y, libtcod.Color(51,0,102), libtcod.BKGND_ALPHA(alphperc))
                    libtcod.console_set_char_background(wgwindow, x, y, scol, libtcod.BKGND_ALPHA(alphperc))
                    if alphperc > 0.1:
                        if wfeaturedict.get('%s,%s' % (x,y)):
                            if not 's' in  wfeaturedict['%s,%s' % (x,y)]:
                                wfeaturedict['%s,%s' % (x,y)] = wfeaturedict['%s,%s' % (x,y)] + ['s']
                        else:
                            wfeaturedict['%s,%s' % (x,y)] = ['s']
                    if alphperc > 0.3:
                        if 'b' not in wfeaturedict['%s,%s' % (x,y)]:
                            char = choice(snowchars)
                            col = libtcod.color_lerp(scol,libtcod.white,0.5)
                            libtcod.console_set_default_foreground(wgwindow, col)
                            libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                            wtexturedict['%s,%s' % (x,y)] = [char,col]

        wgtext = 'Adding forest\ndetails...'
        CurText = FadeText(wgtext, 1, 18, con=wswindow, speed=25).start()

        # Add 'winterized' forests.
        for x in range(MAP_WIDTH):
            for y in range(MAP_HEIGHT):
                if (float(y) / MAP_HEIGHT * 102) < ivar[x]:
                    if wfeaturedict.get('%s,%s' % (x,y)):
                        ftype = None
                        if 'cf' in wfeaturedict['%s,%s' % (x,y)]:
                            ftype = 'cf'
                        elif 'bf' in wfeaturedict['%s,%s' % (x,y)]:
                            ftype = choice(['ef','cf'])
                            wfeaturedict['%s,%s' % (x,y)].remove('bf')
                            wfeaturedict['%s,%s' % (x,y)].append(ftype)
                        elif 'ef' in wfeaturedict['%s,%s' % (x,y)]:
                            ftype = 'ef'
                        elif 'mf' in wfeaturedict['%s,%s' % (x,y)]:
                            ftype = choice(['ef','cf'])
                            wfeaturedict['%s,%s' % (x,y)].remove('mf')
                            wfeaturedict['%s,%s' % (x,y)].append(ftype)
                        elif 'df' in wfeaturedict['%s,%s' % (x,y)]:
                            ftype = choice(['ef','cf'])
                            wfeaturedict['%s,%s' % (x,y)].remove('df')
                            wfeaturedict['%s,%s' % (x,y)].append(ftype)
                        if ftype:
                            libtcod.console_set_default_foreground(wgwindow, libtcod.white)
                            libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(fpdict[ftype])))
                            
        
        for y in range(MAP_HEIGHT):
            for x in range(MAP_WIDTH):
                # Draw snowcaps.
                scdensity = libtcod.heightmap_get_value(snowmap, x, y)
                scperc = int(((sminmax[1] - scdensity) / saltrange) * 100) - 1
                if scperc > 50:
                    if wheightdict['%s,%s' % (x,y)] > wmlev + 12:
                        sccol = scolmap[-(scperc)]
                        alphperc = 1.0 - (randrange(1,3) * 0.03)
                        for num in range(-2,3):
                            for num2 in range(-2,3):
                                oaltitude = libtcod.heightmap_get_value(worldmap, max(min(x - num,MAP_WIDTH - 1),0), max(min(y - num2,MAP_HEIGHT - 1),0))
                                oaltperc = int(((minmax[1] - oaltitude) / altrange) * 200) - 1
                                osdensity = libtcod.heightmap_get_value(snowmap, max(min(x - num,MAP_WIDTH - 1),0), max(min(y - num2,MAP_HEIGHT - 1), 0))
                                osperc = int(((dminmax[1] - osdensity) / daltrange) * 500) - 1
                                if osperc < 49 or wheightdict['%s,%s' % (max(min(x - num,MAP_WIDTH - 1),0),max(min(y - num2,MAP_HEIGHT - 1),0))] < wmlev + 12:
                                    alphperc = max(alphperc - 0.1,0.0)
                        libtcod.console_set_char_background(wgwindow, x, y, sccol, libtcod.BKGND_ALPHA(alphperc))

        wgtext = 'Adding glaciers...'
        CurText = FadeText(wgtext, 1, 21, con=wswindow, speed=25).start()

        gvar = {}
        gyvar = float(randrange(int(MAP_HEIGHT * .02),int(MAP_HEIGHT * .045)))
        for x in range(MAP_WIDTH):
            try:
                if int(gvar[max(x - 1,0)]) == 12 and int(gvar[max(x - 2,0)]) == 12:
                    gyvar = 11
                else:
                    gyvar += randrange(-1,2) * 0.6
                    gyvar = min(gyvar,12)
            except KeyError:
                gyvar += randrange(-2,3) * 0.6
                gyvar = min(gyvar,12)
                
            gvar[x] = int(gyvar)

        wgcoldict = {}

        for y in range(MAP_HEIGHT):
            for x in range(MAP_WIDTH):
                # Draw glaciers.
                altperc = wheightdict['%s,%s' % (x,y)]
                gdensity = libtcod.heightmap_get_value(glaciermap, x, y)
                gperc = int(((gminmax[1] - gdensity) / galtrange) * 500) - 1
                if ((gperc > 475 and (float(y) / MAP_HEIGHT * 102) < (ivar[x] + randrange(-1,2))) or \
                   (gperc > 320 and (float(y) / MAP_HEIGHT * 102) < (gvar[x] + randrange(-1,2)))) and \
                   altperc < wmlev + 1:
                    if wfeaturedict.get('%s,%s' % (x,y)):
                        if not 'g' in wfeaturedict['%s,%  s' % (x,y)]:
                            wfeaturedict['%s,%s' % (x,y)] = wfeaturedict['%s,%s' % (x,y)] + ['g']
                    else:
                        wfeaturedict['%s,%s' % (x,y)] = ['g']
                    wgcoldict['%s,%s' % (x,y)] = gperc

        for y in range(MAP_HEIGHT):
            for x in range(MAP_WIDTH):
                # Draw glaciers.
                if wfeaturedict.get('%s,%s' % (x,y)):
                    if 'g' in wfeaturedict['%s,%s' % (x,y)]:
                        coef = 1.0
                        for num in range(-3,4):
                            for num2 in range(-3,4):
                                if wfeaturedict.get('%s,%s' % (x - num,y - num2)):
                                    if 'g' in wfeaturedict['%s,%s' % (x - num,y - num2)]:
                                        pass
                                    else:
                                        coef = max(coef - .05,0)
                                elif ((x - num) in range(0,MAP_WIDTH)) and ((y - num2) in range(0,MAP_HEIGHT)):
                                    coef = max(coef - .05,0)
                        gperc = wgcoldict['%s,%s' % (x,y)]
                        gcol = gcolmap[gperc]
                        char = choice(glacierchars)
                        col = libtcod.color_lerp(gcol,libtcod.white,0.5)
                        libtcod.console_set_default_foreground(wgwindow, col)
                        libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_ALPHA(coef), libtcod.LEFT, chr(DoChar(char)))
                        wtexturedict['%s,%s' % (x,y)] = [char,col]
                        libtcod.console_set_default_background(wgwindow, gcol)
                        
        wgtext = 'Adding scrub...'
        CurText = FadeText(wgtext, 1, 23, con=wswindow, speed=25).start()

        # Add scrubland and plains.
        slcoldict = {'sl': libtcod.Color(134,179,0), 'hl': libtcod.Color(77,22,0), 'ml': libtcod.Color(77,102,0), \
            'dl': libtcod.Color(55,77,0)}
        slpdict = {'sl': [14,5,255], 'hl': [3,5,255], 'ml': [1,5,255], 'dl': [2,5,255]}       
        for y in range(MAP_HEIGHT):
            for x in range(MAP_WIDTH):
                altperc = wheightdict['%s,%s' % (x,y)]
                if wmlev > altperc > 156:
                    addshrub = True
                    shrubtype = choice(['sl','hl'])
                    if wfeaturedict.get('%s,%s' % (x,y)):
                        if ('cf' in wfeaturedict['%s,%s' % (x,y)]) or \
                           ('bf' in wfeaturedict['%s,%s' % (x,y)]) or \
                           ('ef' in wfeaturedict['%s,%s' % (x,y)]) or \
                           ('mf' in wfeaturedict['%s,%s' % (x,y)]) or \
                           ('df' in wfeaturedict['%s,%s' % (x,y)]) or \
                           ('sw' in wfeaturedict['%s,%s' % (x,y)]):
                            addshrub = False
                        if wfeaturedict.get('%s,%s' % (x,y)):
                            if 's' in wfeaturedict['%s,%s' % (x,y)]:
                                addshrub = False
                        if ('d' in wfeaturedict['%s,%s' % (x,y)]):
                            shrubtype = 'dl'
                        else:
                            shrubtype = choice(['sl', 'hl'])
                            for num in range(-2,3):
                                for num2 in range(-2,3):
                                    try:
                                        if wheightdict['%s,%s' % (x + num,y + num2)] < wwlev and random.randrange(2) == 1:
                                            shrubtype = 'ml'
                                    except KeyError:
                                        pass
                    if randrange(1,10) == 1:
                        if addshrub:
                            slcol = libtcod.white
                            libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(slpdict[shrubtype])))
                            libtcod.console_set_char_foreground(wgwindow, x, y, slcol)
                            if wfeaturedict.get('%s,%s' % (x,y)):
                                wfeaturedict['%s,%s' % (x,y)] = wfeaturedict['%s,%s' % (x,y)] + [shrubtype]
                            else:
                                wfeaturedict['%s,%s' % (x,y)] = [shrubtype]
                # Add plains.
                if (not wfeaturedict.get('%s,%s' % (x,y)) and 152 < wheightdict['%s,%s' % (x,y)] < 168 and \
                   y < ((MAP_HEIGHT / 4) * 3) + tivar[x]) and (float(y) / MAP_HEIGHT * 102) > ivar[x]:
                    if wfeaturedict.get('%s,%s' % (x,y)):
                        wfeaturedict['%s,%s' % (x,y)] = wfeaturedict['%s,%s' % (x,y)] + ['pl']
                    else:
                        wfeaturedict['%s,%s' % (x,y)] = ['pl']
                    plcol = libtcod.white
                    plchar = choice(tallgrasschars)
                    libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(plchar)))
                    wtexturedict['%s,%s' % (x,y)] = [plchar,libtcod.white]

        wgtext = 'Running rivers...\n(This may take\na few moments.)'
        CurText = FadeText(wgtext, 1, 25, con=wswindow, speed=25).start()

        # Generate rivers.

        time.sleep(2)
        rivernum = 300

        if MAP_WIDTH != 500:
            modx = float(MAP_WIDTH) / float(500)
        else:
            modx = 1.0
        if MAP_HEIGHT != 300:
            mody = float(MAP_HEIGHT) / float(300)
        else:
            mody = 1.0

        mod = (modx + mody) / 2.0

        rivernum = int(rivernum * mod)
        
        startnum = rivernum
        libtcod.console_print_ex(wswindow, 9, 29, libtcod.BKGND_NONE, libtcod.CENTER, '(%s/%s)' % (startnum - rivernum,startnum))
        sourcelist = []
        courselist = []
        for x in range(MAP_WIDTH):
            for y in range(MAP_HEIGHT):
                if wheightdict['%s,%s' % (x,y)] in range(wmlev - 10,wmlev):
                    sourcelist.append([x,y])
                if wheightdict['%s,%s' % (x,y)] in range(151,wmlev - 10):
                    courselist.append([x,y])
        wriverdict = {}
        wrivdirdict = {}
        tribdict = {}
        rivchardict = {}
        rivcoldict = {}
        rivbgdict = {}
        riverlist = []
        curtime = time.time()
        oldtime = curtime
        while rivernum > 0:
            if curtime - oldtime > 5:
                break
            curriv = []
            try:
                source = choice(sourcelist)
            except IndexError:
                rivernum = 0
                break
            difsource = False
            if wfeaturedict.get('%s,%s' % (source[0],source[1])):
                if 'd' in wfeaturedict['%s,%s' % (source[0],source[1])]:
                    difsource = True
            for num in range(-3,4):
                for num2 in range(-3,4):
                    searchpos = [source[0] - num,source[1] - num2]
                    for river in riverlist:
                        if searchpos in river:
                            difsource = True
            sourcelist.remove(source)
            if difsource:
                continue
            direction = choice(['n','e','s','w'])
            curpos = source
            curriv.append(curpos)
            while wheightdict['%s,%s' % (curpos[0],curpos[1])] > 151:
                choicedict = {}
                if curpos[0] == 0 or curpos[0] == MAP_WIDTH - 1 \
                   or curpos[1] == 0 or curpos[1] == MAP_HEIGHT -1:
                    break
                else:
                    choicedict['e'] = ((wheightdict['%s,%s' % (curpos[0] + 1,curpos[1])] - wheightdict['%s,%s' % (curpos[0],curpos[1])] + 1) * 5)
                    choicedict['w'] = ((wheightdict['%s,%s' % (curpos[0] - 1,curpos[1])] - wheightdict['%s,%s' % (curpos[0],curpos[1])] + 1) * 5)
                    choicedict['n'] = ((wheightdict['%s,%s' % (curpos[0],curpos[1] - 1)] - wheightdict['%s,%s' % (curpos[0],curpos[1])] + 1) * 5)
                    choicedict['s'] = ((wheightdict['%s,%s' % (curpos[0],curpos[1] + 1)] - wheightdict['%s,%s' % (curpos[0],curpos[1])] + 1) * 5)
                    if direction == 'n':
                        backup = [curpos[0],curpos[1] - 1]
                    elif direction == 's':
                        backup = [curpos[0],curpos[1] + 1]
                    elif direction == 'e':
                        backup = [curpos[0] + 1,curpos[1]]
                    else:
                        backup = [curpos[0] - 1,curpos[1]]
                lastpos = curpos
                choicelist = []
                for item in choicedict.items():
                    choicelist.append([list(item)[0],list(item)[1]])
                choicelist.sort(ListCmp2)
                rchoice = choicelist[-1][0]
                if rchoice == 'n':
                    curpos = [curpos[0],curpos[1] - 1]
                elif rchoice == 's':
                    curpos = [curpos[0],curpos[1] + 1]
                elif rchoice == 'e':
                    curpos = [curpos[0] + 1,curpos[1]]
                else:
                    curpos = [curpos[0] - 1,curpos[1]]

                matchx, matchy = 0,0
                for pos in curriv[-4:]:
                    if pos[0] == curpos[0]:
                        matchx += 1
                    if pos[1] == curpos[1]:
                        matchy += 1
                if matchx == 4:
                    curpos = [curriv[-1][0] + choice([1,-1]),curriv[-1][1]]
                elif matchy == 4:
                    curpos = [curriv[-1][0],curriv[-1][1] + choice([1,-1])]

                adjacent = 2
                trychoice = 0
                killriv = False
                while adjacent > 1:
                    adjacent = 0
                    if [curpos[0] - 1,curpos[1]] in curriv:
                        adjacent += 1
                    if [curpos[0] + 1,curpos[1]] in curriv:
                        adjacent += 1
                    if [curpos[0],curpos[1] - 1] in curriv:
                        adjacent += 1
                    if [curpos[0],curpos[1] + 1] in curriv:
                        adjacent += 1
                    if curpos in curriv:
                        adjacent += 1
                    if adjacent > 1:
                        trychoice += 1
                        try:
                            curpos = lastpos
                            rchoice = choicelist[-(trychoice)]
                            if rchoice == 'n':
                                curpos = [curpos[0],curpos[1] - 1]
                            elif rchoice == 's':
                                curpos = [curpos[0],curpos[1] + 1]
                            elif rchoice == 'e':
                                curpos = [curpos[0] + 1,curpos[1]]
                            else:
                                curpos = [curpos[0] - 1,curpos[1]]
                            if wheightdict['%s,%s' % (curpos[0],curpos[1])] > wmlev:
                                killriv = True
                        except IndexError:
                            killriv = True
                            break

                if killriv:
                    break
                            

                breakloop = False
                for river in riverlist:
                    if [curpos[0],curpos[1]] in river or killriv == True:
                        breakloop = True

                curriv.append(curpos)
                if breakloop == True:
                    break

            if not len(curriv) > 2 or killriv:
                continue

            if not breakloop and not wheightdict['%s,%s' % (curriv[-1][0],curriv[-1][1])] < 152:
                continue
            
            rivname = MakeName(PLang)     
            riverlist.append(curriv)
            oldtime = curtime
            curtime = time.time()
            wriverdict[rivname] = curriv
            for pos in curriv:
                if wfeaturedict.get('%s,%s' % (pos[0],pos[1])):
                    if not 'r' in wfeaturedict['%s,%s' % (pos[0],pos[1])]:
                        wfeaturedict['%s,%s' % (pos[0],pos[1])] = wfeaturedict['%s,%s' % (pos[0],pos[1])] + ['r']
                else:
                    wfeaturedict['%s,%s' % (pos[0],pos[1])] = ['r']
            libtcod.console_print_ex(wswindow, 9, 29, libtcod.BKGND_NONE, libtcod.CENTER, '(%s/%s)' % (startnum - rivernum,startnum))
            rivernum -= 1

        rdictlist = []
        for river in wriverdict.items():
            rdictlist.append([list(river)[0],list(river)[1]])

        for river in rdictlist:
            for river2 in rdictlist:
                if river[0] == river2[0]:
                    pass
                else:
                    if river[1][-1] in river2[1]:
                        tribdict[river[0]] = river2[0]

        rdictlist = []
        for river in wriverdict.items():
            rdictlist.append([list(river)[0],list(river)[1]])  

        for river in rdictlist:
            tribendlist = []
            tribcount = 0
            triblist = map(lambda x: list(x),filter(lambda x: list(x)[1] == river[0],tribdict.items()))
            for trib in triblist:
                tribcount += tribdict.values().count(trib[0])
            for item in rdictlist:
                if item[0] in map(lambda x: x[0],triblist):
                    tribendlist.append([item[1][-1],item[1][-2]])
            tributes = tribdict.values().count(river[0]) + tribcount
            if tribdict.has_key(river[0]):
                istrib = True
            else:
                istrib = False
            for pos in river[1]:
                if wheightdict['%s,%s' % (pos[0],pos[1])] < 152:
                    continue
                if istrib:
                    if river[1][-1] == pos:
                        continue
                adjdirs = []
                if [pos[0] - 1,pos[1]] in river[1] or ([pos[0],pos[1]] in map(lambda x: x[0],tribendlist) and [pos[0] - 1,pos[1]] in map(lambda x: x[1],tribendlist)):
                    adjdirs.append('w')
                if [pos[0] + 1,pos[1]] in river[1] or ([pos[0],pos[1]] in map(lambda x: x[0],tribendlist) and [pos[0] + 1,pos[1]] in map(lambda x: x[1],tribendlist)):
                    adjdirs.append('e')
                if [pos[0],pos[1] - 1] in river[1] or ([pos[0],pos[1]] in map(lambda x: x[0],tribendlist) and [pos[0],pos[1] - 1] in map(lambda x: x[1],tribendlist)):
                    adjdirs.append('n')
                if [pos[0],pos[1] + 1] in river[1] or ([pos[0],pos[1]] in map(lambda x: x[0],tribendlist) and [pos[0],pos[1] + 1] in map(lambda x: x[1],tribendlist)):
                    adjdirs.append('s')
                wrivdirdict['%s,%s' % (pos[0],pos[1])] = [adjdirs,tributes]
                rivchar = getRivChar(adjdirs, tributes)
                rivkeyidx = [0, (len(river[1]) / 10) * 3, len(river[1])]
                if wheightdict['%s,%s' % (river[1][-1][0],river[1][-1][1])] < 152:
                    rivkeycols = [libtcod.Color(143,201,255), libtcod.Color(0,82,120), libtcod.Color(0,40,77)]
                else:
                    rivkeycols = [libtcod.Color(0,40,77), libtcod.Color(0,82,120), libtcod.Color(0,40,77)]

                lrivcol = None
                if istrib:
                    tribpos = wriverdict[tribdict[river[0]]].index(river[1][-1])
                    lriv = wriverdict[tribdict[river[0]]]
                    lrivkeyidx = [0, (len(lriv) / 10) * 3, len(lriv)]
                    if wheightdict['%s,%s' % (lriv[-1][0],lriv[-1][1])] < 152:
                        lrivkeycols = [libtcod.Color(143,201,255), libtcod.Color(0,82,120), libtcod.Color(0, 40, 77)]
                    else:
                        lrivkeycols = [libtcod.Color(0,40,77), libtcod.Color(0,82,120), libtcod.Color(0,40,77)]
                    lrivcolmap = libtcod.color_gen_map(lrivkeycols, lrivkeyidx)
                    lrivcol = lrivcolmap[-(tribpos) - 1]

                if lrivcol:
                    rivkeycols[0] = lrivcol

                rivcolmap = libtcod.color_gen_map(rivkeycols, rivkeyidx)
                rivcol = rivcolmap[-(river[1].index(pos)) - 1]
                rivcol = rivcol + libtcod.Color(randrange(0,10),randrange(0,10),randrange(0,10))
                rivbg = libtcod.BKGND_ALPHA(0.05)
                if (float(pos[1]) / MAP_HEIGHT * 102) < ivar[pos[0]]:
                    rivcol = libtcod.color_lerp(libtcod.Color(51,255,204), libtcod.console_get_char_background(wgwindow, pos[0], pos[1]), 0.75)
                    rivbg = libtcod.BKGND_NONE
                libtcod.console_set_default_background(wgwindow, libtcod.Color(20,20,20))
                libtcod.console_set_default_foreground(wgwindow, rivcol)
                libtcod.console_print_ex(wgwindow, pos[0], pos[1], rivbg, libtcod.LEFT, chr(DoChar(rivchar)))
                wtexturedict['%s,%s' % (pos[0],pos[1])] = [rivchar,rivcol]
                rivchardict['%s,%s' % (pos[0],pos[1])] = rivchar
                rivcoldict['%s,%s' % (pos[0],pos[1])] = rivcol
                rivbgdict['%s,%s' % (pos[0],pos[1])] = rivbg

        for y in range(MAP_HEIGHT):
            for x in range(MAP_WIDTH):
                if 'sl' in wfeaturedict['%s,%s' % (x,y)] or 'hl' in wfeaturedict['%s,%s' % (x,y)]:
                    for num in range(-1,2):
                        for num2 in range(-1,2):
                            try:
                                if 'r' in wfeaturedict['%s,%s' % (x + num,y + num2)]:
                                    flist = wfeaturedict['%s,%s' % (x,y)]
                                    if random.randrange(2) == 1:
                                        try:
                                            flist.remove('sl')
                                        except ValueError:
                                            pass
                                        try:
                                            flist.remove('hl')
                                        except ValueError:
                                            pass
                                        flist.append('ml')
                                        wfeaturedict['%s,%s' % (x,y)] = flist
                                        if 'r' not in flist:
                                            slcol = libtcod.white
                                            libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(slpdict['ml'])))
                                            libtcod.console_set_char_foreground(wgwindow, x, y, slcol)
                            except KeyError:
                                pass

        wgtext = 'Adding mountain\ndetails...'
        CurText = FadeText(wgtext, 1, 29, con=wswindow, speed=25).start()

        for y in range(MAP_HEIGHT):
            for x in range(MAP_WIDTH):
                # Draw winterized mountains.
                if wheightdict['%s,%s' % (x,y)] > wmlev - 1 and (float(y) / MAP_HEIGHT * 100) < ivar[x]:              
                    mcol = libtcod.Color(187,229,241)
                    mfcol = libtcod.Color(47,124,148)
                    malpha = choice([0.9,0.8,0.85])
                    for num in range(3):
                        if ivar[x] < (float(y + num + 1) / MAP_HEIGHT * 100):
                            malpha = max(malpha - 0.2,0.0)
                        if ivar[x - 1] < (float(y + num + 1) / MAP_HEIGHT * 99):
                            malpha = max(malpha - 0.1,0.0)
                        if ivar[x + 1] < (float(y + num + 1) / MAP_HEIGHT * 99):
                            malpha = max(malpha - 0.1,0.0)
                    if malpha > 0.1:
                        if wfeaturedict.get('%s,%s' % (x,y)):
                            if not 's' in  wfeaturedict['%s,%s' % (x,y)]:
                                wfeaturedict['%s,%s' % (x,y)] = wfeaturedict['%s,%s' % (x,y)] + ['s']
                    libtcod.console_set_char_background(wgwindow, x, y, mcol, libtcod.BKGND_ALPHA(malpha))
                    libtcod.console_set_char_foreground(wgwindow, x, y, mfcol)
                # Now for shading (all mountains).
                if wheightdict['%s,%s' % (x,y)] > wwlev:
                    sperc = 0.0
                    for num in range(1,4):
                        for num2 in range(-3,0):
                            try:
                                if wheightdict['%s,%s' % (x + num,y + num2)] >= wheightdict['%s,%s' % (x,y)]:
                                    na = 200 - wwlev
                                    nb = na - (200 - wheightdict['%s,%s' % (x + num,y + num2)])
                                    nc = (nb * 1.0) / (na * 1.0)
                                    if nc < 0.2 or 'd' in wfeaturedict.get('%s,%s' % (x,y)):
                                        nc = nc * .1
                                    sperc += 0.075 * nc
                            except KeyError:
                                pass
                    col = libtcod.color_lerp(libtcod.console_get_char_background(wgwindow, x, y),libtcod.black,sperc)
                    col2 = libtcod.color_lerp(libtcod.console_get_char_foreground(wgwindow, x, y),libtcod.black,sperc)
                    libtcod.console_set_char_background(wgwindow, x, y, col, libtcod.BKGND_SET)
                    libtcod.console_set_char_foreground(wgwindow, x, y, col2)
        # Remove pesky shading from frozen mountain rivers.
        for y in range(MAP_HEIGHT):
            for x in range(MAP_WIDTH):
                if wfeaturedict.get('%s,%s' % (x,y)):
                    if 'r' in wfeaturedict['%s,%s' % (x,y)] and (float(y) / MAP_HEIGHT * 100) < ivar[x] and wheightdict['%s,%s' % (x,y)] > wmlev - 1:
                        libtcod.console_set_char_foreground(wgwindow, x, y, libtcod.console_get_char_foreground(wgwindow, x, y) + libtcod.Color(80,150,150))

        libtcod.console_set_default_background(wgwindow, libtcod.black)
        wgtext = 'Adding caves...'
        CurText = FadeText(wgtext, 1, 32, con=wswindow, speed=25).start()

        # Add caves.

        caveok = []
        for x in range(MAP_WIDTH):
            for y in range(MAP_HEIGHT):
                if wmlev + 8 > wheightdict['%s,%s' % (x,y)] > wmlev - 20:
                    if wfeaturedict.get('%s,%s' % (x,y)):
                        if 'r' in wfeaturedict['%s,%s' % (x,y)]:
                            continue
                    caveok.append([x,y])

        
        cavenum = 150
        
        if MAP_WIDTH != 500:
            modx = float(MAP_WIDTH) / float(500)
        else:
            modx = 1.0
        if MAP_HEIGHT != 300:
            mody = float(MAP_HEIGHT) / float(300)
        else:
            mody = 1.0

        mod = (modx + mody) / 2.0

        cavenum = int(cavenum * mod)
        
        wcavedict = {}
        cavelist = []
        while cavenum > 0 and len(caveok) > 0:
            addcave = True
            cavepos = choice(caveok)
            x = cavepos[0]
            y = cavepos[1]
            for num in range(-1,2):
                for num2 in range(-1,2):
                    if wfeaturedict.get('%s,%s' % (x - num,y - num2)):
                        if 'c' in wfeaturedict['%s,%s' % (x - num,y - num2)]:
                            addcave = False
            caveok.remove(cavepos)
            if addcave:
                libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(cavechar)))
                libtcod.console_set_char_foreground(wgwindow, x, y, libtcod.white)
                cavename = MakeName(PLang)
                cavenum -= 1
                wcavedict[cavename] = [x,y]
                cavelist.append([x,y])
                if wfeaturedict.get('%s,%s' % (x,y)):
                    if not 'c' in wfeaturedict['%s,%s' % (x,y)]:
                        wfeaturedict['%s,%s' % (x,y)] = wfeaturedict['%s,%s' % (x,y)] + ['c']
                else:
                    wfeaturedict['%s,%s' % (x,y)] = ['c']
        libtcod.console_set_default_background(wgwindow, libtcod.black)

        time.sleep(1.0)
                            
        # Save the world to an image.
        wtmapdict = {}
        for x in range(MAP_WIDTH):
            for y in range(MAP_HEIGHT):
                wtmapdict['%s,%s' % (x,y)] = [libtcod.console_get_char_background(wgwindow, x, y),libtcod.console_get_char_foreground(wgwindow, x, y)]

        NoKeys = True

        while True:
            try:
                if init['WORLDGEN PICS'] == 'YES':
                    wgpic = libtcod.image_from_console(wgwindow)
                    libtcod.image_save(wgpic,'.\\image\\gfx\\worldgen.png')
                break
            except WindowsError:
                pass
        

        libtcod.console_set_custom_font('fonts\\heightmap.bmp', libtcod.FONT_LAYOUT_TCOD | libtcod.FONT_TYPE_GREYSCALE, fontx, fonty)

        testconsole = libtcod.console_new(MAP_WIDTH,MAP_HEIGHT)
        for x in range(MAP_WIDTH):
            for y in range(MAP_HEIGHT):
                if wheightdict['%s,%s' % (x,y)] > wwlev:
                    colperc = ((wheightdict['%s,%s' % (x,y)] * 1.0) - 151) / 48.00
                    heightcol = libtcod.color_lerp(libtcod.black, libtcod.white, colperc)
                else:
                    heightcol = libtcod.black
                libtcod.console_set_char_background(testconsole, x, y, heightcol, libtcod.BKGND_SET)

        while True:
            try:        
                heightpic = libtcod.image_from_console(testconsole)
                libtcod.image_save(heightpic,'.\\image\\gfx\\hmap.png')
                break
            except WindowsError:
                pass

        NoKeys = False

        libtcod.console_clear(wswindow)

        libtcod.console_set_default_foreground(wswindow, hcolor)
        libtcod.console_print_ex(wswindow, 9, ((SCREEN_HEIGHT - 2) / 2) - 11, libtcod.BKGND_NONE, libtcod.CENTER, 'Terrain gen\nfinished!')

        libtcod.console_set_default_foreground(wswindow, libtcod.white)
        libtcod.console_print_ex(wswindow, 9, ((SCREEN_HEIGHT - 2) / 2) - 8, libtcod.BKGND_NONE, libtcod.CENTER, 'To move on to\nfeature naming,\ntype \'n\'.\n\nOtherwise,\npress \'g\' to\ngenerate a\nnew map.')

        libtcod.console_print_ex(wswindow, 9, ((SCREEN_HEIGHT - 2) / 2) - 4, libtcod.BKGND_NONE, libtcod.CENTER, 'To view a scaled\ndown view of\nthe world,\npress \'s\'.')

        WorldGoing = False
        WorldDone = True
        NamingDone = False
        genbutton = ButtonBox(wswindow, 6, ((SCREEN_HEIGHT - 2) / 2) + 2, 'New Map', 'g')
        namebutton = ButtonBox(wswindow, 5, ((SCREEN_HEIGHT - 2) / 2) + 6, 'Name Gen.', 'n')
        scalebutton = ButtonBox(wswindow, 5, ((SCREEN_HEIGHT - 2) / 2) + 10, 'Scale Map', 's')
        del self
        
####################################
# X. Terrain Feature Naming        #
####################################

class WorldNaming(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)

    def run(self):
        global SCREEN_HEIGHT, VIEW_HEIGHT, SCREEN_WIDTH, VIEW_WIDTH, wiwindow, \
               wgwindow, wswindow, worldmap, wheightdict, wfeaturedict, wgpic, \
               NoKeys, WorldGoing, NamingDone, wisledict, wlangdict, PLang, \
               wisledict, wpeakdict, wforestdict, wdesertdict, wtundradict, \
               wlakedict, wisledict, woceandict, wtmapdict, wplainsdict, ButtonList, \
               wswampdict, wglacierdict, wtexturedict

        WorldGoing = True
        ButtonList = []

        libtcod.console_set_default_foreground(wswindow, libtcod.white)
        libtcod.console_print_ex(wswindow, 9, 1, libtcod.BKGND_NONE, libtcod.CENTER, 'Named Features')

        libtcod.console_set_default_foreground(wswindow, hcolor)
        libtcod.console_print_ex(wswindow, 9, 3, libtcod.BKGND_NONE, libtcod.CENTER, '~*~*~*~')

        wgtext = 'Naming\nmountains...'
        CurText = FadeText(wgtext, 1, 5, con=wswindow, speed=25).start()

        # Generate mountain names.

        wheightlist = []
        wpeakdict = {}
        
        for pos in wheightdict.items():
            wheightlist.append(list(pos))

        wheightlist.sort(DictCmp)
        peaknum = randrange(40,50)
        peaklist = []
        while peaknum >= 1:
            try:
                curpos = list(wheightlist.pop(0)[0])
            except IndexError:
                break
            compos = curpos.index(',')
            curpos.remove(',')
            curpos = [curpos[0:compos],curpos[compos:]]
            curpos[0] = int(''.join(map(lambda x: str(x),curpos[0])))
            curpos[1] = int(''.join(map(lambda x: str(x),curpos[1])))
            addpeak = True
            for pos in peaklist:
                d = sqrt(pow((curpos[1] - pos[1]),2) + pow((curpos[0] - pos[0]),2))
                if d < 18.0:
                    addpeak = False
            if addpeak:
                peaklist.append(curpos)
                peaknum -= 1

        for pos in peaklist:
            libtcod.console_set_default_background(wgwindow, libtcod.black)
            libtcod.console_set_default_foreground(wgwindow, libtcod.white)
            mountname = MakeName(PLang)
            if wheightdict['%s,%s' % (pos[0],pos[1])] > wmlev + 6:
                mountname = wchoice([(choice(['Mount %s','%s Mountain','%s Peak']),.9), \
                                     (choice(['The Horn of %s','%s\'s Horns','The Fangs of %s','%s\'s Fangs','%s\'s Claws', \
                                                     'The Spine of %s','%s\'s Spine','%s Spire','The Spire of %s','The Paw of %s', \
                                                     '%s\'s Paw','%s\'s Finger','The Finger of %s','%s\'s Thumb','The Thumb of %s', \
                                                     '%s\'s Sword','The Sword of %s','%s\'s Knife','The Knife of %s']),.1)]) % mountname
            else:
                mountname = wchoice([(choice(['The Hills of %s','%s Bluffs','%s Ridge','The %s Highlands','The Highlands of %s']),.9), \
                                     (choice(['%s Ridge','The Ridge of %s','The %s Uplands','The %s Hummocks','The Hummocks of %s', \
                                                     'The Slopes of %s','%s Promontory']),.1)]) % mountname
            libtcod.console_print_ex(wgwindow, max(min(pos[0],MAP_WIDTH - 13),13), pos[1], libtcod.BKGND_ALPHA(0.6), libtcod.CENTER, mountname)
            wpeakdict[mountname] = [pos[0],pos[1]]

        wgtext = 'Naming forests...'
        CurText = FadeText(wgtext, 1, 8, con=wswindow, speed=25).start()

        # Generate forest names.
        
        grid = 0
        xgrid = 10
        ygrid = 10
        fdendict = {}
        junglist = []
        fdenlist = []
        fposdict = {}
        fposlist = {}
        fgridlist = []
        wforestdict = {}

        # Get a count of forest density in each 10x10 section of the world.

        while grid < ((MAP_WIDTH / 10) * (MAP_HEIGHT / 10)):
            fposlist[grid] = []
            fcount = 0
            jcount = 0
            for x in range(xgrid - 10, xgrid):
                for y in range(ygrid - 10, ygrid):
                    if wfeaturedict.get('%s,%s' % (x,y)):
                        if ('cf' in wfeaturedict['%s,%s' % (x,y)]) or \
                           ('bf' in wfeaturedict['%s,%s' % (x,y)]) or \
                           ('ef' in wfeaturedict['%s,%s' % (x,y)]) or \
                           ('mf' in wfeaturedict['%s,%s' % (x,y)]) or \
                           ('df' in wfeaturedict['%s,%s' % (x,y)]):
                            fcount += 1
                            fposlist[grid] += [(x,y)]
                        elif 'tf' in wfeaturedict['%s,%s' % (x,y)]:
                            fcount += 1
                            fposlist[grid] += [(x,y)]
                            jcount += 1
            fdendict[grid] = fcount
            if jcount > (fcount / 2):
                junglist.append('%s,%s' % (xgrid - 5, ygrid - 5))
            fposdict[grid] = [xgrid - 5, ygrid - 5]
            if xgrid % MAP_WIDTH == 0:
                xgrid = 10
                ygrid += 10
            else:
                xgrid += 10
            grid += 1

        for segment in fdendict.items():
            fdenlist.append(list(segment))
        fdenlist.sort(DictCmp)

        fnum = 0
        fseglist = []
        while fnum < 30:
            addforest = True
            try:
                cursegcount = fdenlist[0][1]
            except IndexError:
                break
            curseg = fdenlist.pop(0)[0]
            curpos = fposdict[curseg]
            for pos in fgridlist:
                d = sqrt(pow((curpos[1] - pos[1]),2) + pow((curpos[0] - pos[0]),2))
                if d < 30.0:
                    addforest = False
            if addforest:
                if cursegcount > 60:
                    fgridlist.append(curpos)
                    fseglist.append(curseg)
                    fnum += 1
                else:
                    fnum += 1

        for grid in fseglist:
            x = 0
            y = 0
            for pos in fposlist[grid]:
                x += pos[0]
                y += pos[1]
            try:
                x = x / len(fposlist[grid])
                y = y / len(fposlist[grid])
            except ZeroDivisionError:
                continue
            libtcod.console_set_default_background(wgwindow, libtcod.dark_sea)
            libtcod.console_set_default_foreground(wgwindow, libtcod.white)
            forestname = MakeName(PLang)
            for pos in fposlist[grid]:
                for jpos in junglist:
                    if pos == jpos:
                        forestname = 'The ' + forestname + ' Jungle'
                        libtcod.console_set_default_background(wgwindow, libtcod.dark_green)
            else:
                if randrange(1,15) == 1:
                    forestname = forestname + '\'s Grove'
                else:
                    forestname = forestname + ' Forest'
            libtcod.console_print_ex(wgwindow, max(min(x,MAP_WIDTH - 13),13), y, libtcod.BKGND_ALPHA(0.6), libtcod.CENTER, forestname)
            wforestdict[forestname] = [fposlist[grid],[x,y]]

        wgtext = 'Naming deserts...'
        CurText = FadeText(wgtext, 1, 10, con=wswindow, speed=25).start()

        # Generate desert names.
        
        grid = 0
        xgrid = 10
        ygrid = 10
        ddendict = {}
        ddenlist = []
        dposdict = {}
        dposlist = {}
        dgridlist = []
        wdesertdict = {}

        # Get a count of desert density in each 10x10 section of the world.

        while grid < ((MAP_WIDTH / 10) * (MAP_HEIGHT / 10)):
            dposlist[grid] = []
            dcount = 0
            for x in range(xgrid - 10, xgrid):
                for y in range(ygrid - 10, ygrid):
                    if wfeaturedict.get('%s,%s' % (x,y)):
                        if ('d' in wfeaturedict['%s,%s' % (x,y)] and not 's' in wfeaturedict['%s,%s' % (x,y)]):
                            dcount += 1
                            dposlist[grid] += [(x,y)]
            ddendict[grid] = dcount
            dposdict[grid] = [xgrid - 5, ygrid - 5]
            if xgrid % MAP_WIDTH == 0:
                xgrid = 10
                ygrid += 10
            else:
                xgrid += 10
            grid += 1

        for segment in ddendict.items():
            ddenlist.append(list(segment))
        ddenlist.sort(DictCmp)

        dseglist = []
        dnum = 0
        while dnum < 40:
            adddesert = True
            cursegcount = ddenlist[0][1]
            curseg = ddenlist.pop(0)[0]
            curpos = dposdict[curseg]
            for pos in dgridlist:
                d = sqrt(pow((curpos[1] - pos[1]),2) + pow((curpos[0] - pos[0]),2))
                if d < 30.0:
                    adddesert = False
            if adddesert:
                if cursegcount > 20:
                    dgridlist.append(curpos)
                    dseglist.append(curseg)
                    dnum += 1
                else:
                    dnum += 1

        for grid in dseglist:
            x = 0
            y = 0
            for pos in dposlist[grid]:
                x += pos[0]
                y += pos[1]
            try:
                x = x / len(dposlist[grid])
                y = y / len(dposlist[grid])
            except ZeroDivisionError:
                continue
            killdesert = False
            for desert in wdesertdict.values():
                dist = int(sqrt(pow(desert[1][0] - x,2) + pow(desert[1][1] - y,2)))
                if dist < 50:
                    killdesert = True
            if killdesert:
                continue
            libtcod.console_set_default_background(wgwindow, libtcod.darker_yellow)
            libtcod.console_set_default_foreground(wgwindow, libtcod.white)
            desertname = MakeName(PLang)
            if randrange(1,10) in [1,2]:
                desertname = 'The Wastes of ' + desertname
            elif randrange(1,10) in [1,2]:
                desertname = 'The ' + desertname + ' Barrens'
            else:
                desertname = 'The ' + desertname + ' Desert'
            libtcod.console_print_ex(wgwindow, max(min(x,MAP_WIDTH - 13),13), y, libtcod.BKGND_ALPHA(0.6), libtcod.CENTER, desertname)
            wdesertdict[desertname] = [dposlist[grid],[x,y]]

        wgtext = 'Naming tundras...'
        CurText = FadeText(wgtext, 1, 12, con=wswindow, speed=25).start()

        # Generate arctic desert names.
        
        grid = 0
        xgrid = 10
        ygrid = 10
        tdendict = {}
        tdenlist = []
        tposdict = {}
        tposlist = {}
        tgridlist = []
        wtundradict = {}

        # Get a count of tundra density in each 10x10 section of the world.

        while grid < ((MAP_WIDTH / 10) * (MAP_HEIGHT / 10)):
            tposlist[grid] = []
            tcount = 0
            for x in range(xgrid - 10, xgrid):
                for y in range(ygrid - 10, ygrid):
                    if wfeaturedict.get('%s,%s' % (x,y)):
                        if wfeaturedict['%s,%s' % (x,y)] == ['s'] and wheightdict['%s,%s' % (x,y)] in range(154,166):
                            tcount += 1
                            tposlist[grid] += [(x,y)]
            tdendict[grid] = tcount
            tposdict[grid] = [xgrid - 5, ygrid - 5]
            if xgrid % MAP_WIDTH == 0:
                xgrid = 10
                ygrid += 10
            else:
                xgrid += 10
            grid += 1

        for segment in tdendict.items():
            tdenlist.append(list(segment))
        tdenlist.sort(DictCmp)

        tseglist = []
        tnum = 0
        while tnum < 40:
            addtundra = True
            cursegcount = tdenlist[0][1]
            curseg = tdenlist.pop(0)[0]
            curpos = tposdict[curseg]
            for pos in tgridlist:
                t = sqrt(pow((curpos[1] - pos[1]),2) + pow((curpos[0] - pos[0]),2))
                if t < 30.0:
                    addtundra = False
            if addtundra:
                if cursegcount > 20:
                    tgridlist.append(curpos)
                    tseglist.append(curseg)
                    tnum += 1
                else:
                    tnum += 1

        for grid in tseglist:
            x = 0
            y = 0
            for pos in tposlist[grid]:
                x += pos[0]
                y += pos[1]
            try:
                x = x / len(tposlist[grid])
                y = y / len(tposlist[grid])
            except ZeroDivisionError:
                continue
            libtcod.console_set_default_background(wgwindow, libtcod.light_blue)
            libtcod.console_set_default_foreground(wgwindow, libtcod.darker_blue)
            tundraname = MakeName(PLang)
            mtundraname = wchoice([(choice(['The %s Tundra','%s Tundra']),.95), \
                                   (choice(['The Frozen Plains of %s','The Icy Flats of %s','The Frozen Wilds of %s']),.05)]) % tundraname
            libtcod.console_print_ex(wgwindow, max(min(x,MAP_WIDTH - 13),13), y, libtcod.BKGND_ALPHA(0.6), libtcod.CENTER, mtundraname)
            wtundradict[mtundraname] = [tposlist[grid],[x,y]]

        wgtext = 'Naming swamps...'
        CurText = FadeText(wgtext, 1, 14, con=wswindow, speed=25).start()

        # Generate swamp names.
        
        grid = 0
        xgrid = 10
        ygrid = 10
        sdendict = {}
        sdenlist = []
        sposdict = {}
        sposlist = {}
        sgridlist = []
        wswampdict = {}

        # Get a count of tundra density in each 10x10 section of the world.

        while grid < ((MAP_WIDTH / 10) * (MAP_HEIGHT / 10)):
            scount = 0
            sposlist[grid] = []
            for x in range(xgrid - 10, xgrid):
                for y in range(ygrid - 10, ygrid):
                    if wfeaturedict.get('%s,%s' % (x,y)):
                        if ('sw' in wfeaturedict['%s,%s' % (x,y)]):
                            scount += 1
                            sposlist[grid] += [(x,y)]
            sdendict[grid] = scount
            sposdict[grid] = [xgrid - 5, ygrid - 5]
            if xgrid % MAP_WIDTH == 0:
                xgrid = 10
                ygrid += 10
            else:
                xgrid += 10
            grid += 1

        for segment in sdendict.items():
            sdenlist.append(list(segment))
        sdenlist.sort(DictCmp)

        sseglist = []
        snum = 0
        while snum < 30:
            addswamp = True
            cursegcount = sdenlist[0][1]
            curseg = sdenlist.pop(0)[0]
            curpos = sposdict[curseg]
            for pos in sgridlist:
                s = sqrt(pow((curpos[1] - pos[1]),2) + pow((curpos[0] - pos[0]),2))
                if s < 30.0:
                    addswamp = False
            if addswamp:
                if cursegcount > 20:
                    sgridlist.append(curpos)
                    sseglist.append(curseg)
                    snum += 1
                else:
                    snum += 1

        for grid in sseglist:
            x = 0
            y = 0
            for pos in sposlist[grid]:
                x += pos[0]
                y += pos[1]
            try:
                x = x / len(sposlist[grid])
                y = y / len(sposlist[grid])
            except ZeroDivisionError:
                continue
            libtcod.console_set_default_background(wgwindow, libtcod.desaturated_chartreuse)
            libtcod.console_set_default_foreground(wgwindow, libtcod.darker_sea)
            swampname = MakeName(PLang)
            nswampname = choice(['The Swamps of %s' % swampname, 'The Swamplands of %s' % swampname, '%s Bogs' % swampname, \
                                        '%s Quagmire' % swampname, 'The Quagmire of %s' % swampname, '%s Mire' % swampname])
            libtcod.console_print_ex(wgwindow, max(min(x,MAP_WIDTH - 13),13), y, libtcod.BKGND_ALPHA(0.6), libtcod.CENTER, nswampname)
            wswampdict[nswampname] = [sposlist[grid],[x,y]]

        libtcod.console_set_default_foreground(wgwindow, libtcod.white)

        wgtext = 'Naming plains...'
        CurText = FadeText(wgtext, 1, 16, con=wswindow, speed=25).start()

        # Generate plains & names.
        
        grid = 0
        xgrid = 10
        ygrid = 10
        pdendict = {}
        pdenlist = []
        pposdict = {}
        pposlist = {}
        pgridlist = []
        wplainsdict = {}

        # Get a count of plains density in each 10x10 section of the world.

        while grid < ((MAP_WIDTH / 10) * (MAP_HEIGHT / 10)):
            pcount = 0
            pposlist[grid] = []
            for x in range(xgrid - 10, xgrid):
                for y in range(ygrid - 10, ygrid):
                    if 'pl' in wfeaturedict['%s,%s' % (x,y)] and wheightdict['%s,%s' % (x,y)] in range(154,166):
                        pcount += 1
                        pposlist[grid] += [(x,y)]
            pdendict[grid] = pcount
            pposdict[grid] = [xgrid - 5, ygrid - 5]
            if xgrid % MAP_WIDTH == 0:
                xgrid = 10
                ygrid += 10
            else:
                xgrid += 10
            grid += 1

        for segment in pdendict.items():
            pdenlist.append(list(segment))
        pdenlist.sort(DictCmp)

        pseglist = []
        pnum = 0
        while pnum < 40:
            addplains = True
            cursegcount = pdenlist[0][1]
            curseg = pdenlist.pop(0)[0]
            curpos = pposdict[curseg]
            for pos in pgridlist:
                p = sqrt(pow((curpos[1] - pos[1]),2) + pow((curpos[0] - pos[0]),2))
                if p < 30.0:
                    addplains = False
            if addplains:
                if cursegcount > 20:
                    pgridlist.append(curpos)
                    pseglist.append(curseg)
                    pnum += 1
                else:
                    pnum += 1

        for grid in pseglist:
            x = 0
            y = 0
            for pos in pposlist[grid]:
                x += pos[0]
                y += pos[1]
            try:
                x = x / len(pposlist[grid])
                y = y / len(pposlist[grid])
            except ZeroDivisionError:
                continue
            libtcod.console_set_default_background(wgwindow, libtcod.light_green)
            libtcod.console_set_default_foreground(wgwindow, libtcod.white)
            plainsname = MakeName(PLang)
            if y > (((MAP_HEIGHT / 4) * 3) + randrange(0,8)):
                nplainsname = choice(['The %s Savannah','%s Savannah','The %s Veldt','%s Veldt','%s Pampas','The %s Pampas']) % plainsname
            else:
                nplainsname = choice(['The Plains of %s','%s Flats','%s Meadow','The Meadows of %s','%s Plateau','%s Prairie', \
                                             'The Prairie of %s','%s Moor','The Moorland of %s','%s Downs','%s Veldt','The Veldt of %s', \
                                             'The Wilds of %s','%s Wilds']) % plainsname
            libtcod.console_print_ex(wgwindow, max(min(x,MAP_WIDTH - 13),13), y, libtcod.BKGND_ALPHA(0.6), libtcod.CENTER, nplainsname)
            wplainsdict[nplainsname] = [pposlist[grid],[x,y]]

        libtcod.console_set_default_foreground(wgwindow, libtcod.white)

        wgtext = 'Naming glaciers...'
        CurText = FadeText(wgtext, 1, 18, con=wswindow, speed=25).start()

        # Name glaciers.
        
        grid = 0
        xgrid = 10
        ygrid = 10
        gdendict = {}
        gdenlist = []
        gposdict = {}
        gposlist = {}
        ggridlist = []
        wglacierdict = {}

        # Get a count of glacier density in each 20x20 section of the world.

        while grid < ((MAP_WIDTH / 10) * (MAP_HEIGHT / 10)):
            gcount = 0
            gposlist[grid] = []
            for x in range(xgrid - 10, xgrid):
                for y in range(ygrid - 10, ygrid):
                    if wfeaturedict.get('%s,%s' % (x,y)):
                        if 'g' in wfeaturedict['%s,%s' % (x,y)]:
                            gcount += 1
                            gposlist[grid] += [(x,y)]
            gdendict[grid] = gcount
            gposdict[grid] = [xgrid - 5, ygrid - 5]
            if xgrid % MAP_WIDTH == 0:
                xgrid = 10
                ygrid += 10
            else:
                xgrid += 10
            grid += 1

        for segment in gdendict.items():
            gdenlist.append(list(segment))
        gdenlist.sort(DictCmp)

        gseglist = []
        gnum = 0
        while gnum < 20:
            addglacier = True
            cursegcount = gdenlist[0][1]
            curseg = gdenlist.pop(0)[0]
            curpos = gposdict[curseg]
            for pos in ggridlist:
                g = sqrt(pow((curpos[1] - pos[1]),2) + pow((curpos[0] - pos[0]),2))
                if g < 30.0:
                    addglacier = False
            if addglacier:
                if cursegcount > 20:
                    ggridlist.append(curpos)
                    gseglist.append(curseg)
                    gnum += 1
                else:
                    gnum += 1

        for grid in gseglist:
            x = 0
            y = 0
            for pos in gposlist[grid]:
                x += pos[0]
                y += pos[1]
            try:
                x = x / len(gposlist[grid])
                y = y / len(gposlist[grid])
            except ZeroDivisionError:
                continue
            killglacier = False
            for glacier in wglacierdict.values():
                dist = int(sqrt(pow(glacier[1][0] - x,2) + pow(glacier[1][1] - y,2)))
                if dist < 50:
                    killglacier = True
            if killglacier:
                continue
            libtcod.console_set_default_background(wgwindow, libtcod.dark_azure)
            libtcod.console_set_default_foreground(wgwindow, libtcod.white)
            glaciername = MakeName(PLang)
            nglaciername = choice(['The Bergs of %s','The Icecaps of %s','%s Glacier','The Glacier of %s', \
                                          'The %s Ice Fields','%s\'s Ice Fields','The %s Ice Sheets']) % glaciername
            libtcod.console_print_ex(wgwindow, max(min(x,MAP_WIDTH - 13),13), y, libtcod.BKGND_ALPHA(0.6), libtcod.CENTER, nglaciername)
            wglacierdict[nglaciername] = [gposlist[grid],[x,y]]

        libtcod.console_set_default_foreground(wgwindow, libtcod.white)

        wgtext = 'Naming lakes\nand seas,\nthis may take\nsome time...'
        CurText = FadeText(wgtext, 1, 20, con=wswindow, speed=25).start()

        # Locate lakes.

        wlakedict = {}
        shoredict = {}
        for x in range(MAP_WIDTH):
            for y in range(MAP_HEIGHT):
                if 'b' in wfeaturedict['%s,%s' % (x,y)]:
                    shoredict['%s,%s' % (x,y)] = [x,y]

        lakelist = []

        checkeddict = {}
        poslist = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
        unchecked = []
        while len(shoredict) > 0:
            curbody = []
            curpos = shoredict.items()[0][1]
            unchecked.append(curpos)
            while len(unchecked) > 0:
                checkpos = unchecked[0]
                for newpos in map(lambda x: [checkpos[0] - x[0], checkpos[1] - x[1]],poslist):
                    try:
                        checkeddict['%s,%s' % (newpos[0],newpos[1])]
                        pass
                    except KeyError:
                        if not (-1 < newpos[0] < MAP_WIDTH and -1 < newpos[1] < MAP_HEIGHT):
                            continue
                        checkeddict['%s,%s' % (newpos[0],newpos[1])] = 1
                        try:
                            if shoredict['%s,%s' % (newpos[0],newpos[1])]:
                                unchecked.append(newpos)
                        except KeyError:
                            if wheightdict['%s,%s' % (newpos[0],newpos[1])] < 152:
                                unchecked.append(newpos)
                curbody.append(checkpos)
                unchecked.remove(checkpos)
            for pos in curbody:
                try:
                    shoredict.pop('%s,%s' % (pos[0],pos[1]))
                except KeyError:
                    pass
                
            lakelist.append(curbody)

        # Name lakes.

        wlakedict = {}
        libtcod.console_set_default_background(wgwindow, libtcod.dark_azure)
        libtcod.console_set_default_foreground(wgwindow, libtcod.white)
        lakelist.sort(LenCmp)
        
        oceantiles = lakelist.pop(0)
        for tile in oceantiles:
            if wheightdict['%s,%s' % (tile[0],tile[1])] < wwlev:
                wfeaturedict['%s,%s' % (tile[0],tile[1])] += ['o']

        for lake in lakelist:
            
            for tile in lake:
                if wheightdict['%s,%s' % (tile[0],tile[1])] < 152:
                    wfeaturedict['%s,%s' % (tile[0],tile[1])] += ['l']
                if wheightdict['%s,%s' % (tile[0],tile[1])] == 152:
                    wfeaturedict['%s,%s' % (tile[0],tile[1])] += ['ls']
                    
            islake = True
            lake.sort(ListCmp)
            xmax = lake[0][0]
            xmin = lake[-1][0]
            xquarter = (xmax - xmin) / 4
            westcheck = [lake[-1][0] - 1,lake[-1][1]]
            eastcheck = [lake[0][0] + 1,lake[0][1]]
            lake.sort(ListCmp2)
            ymax = lake[0][1]
            ymin = lake[-1][1]
            yquarter = (ymax - ymin) / 4
            y = int((ymax + ymin) / 2)
            northcheck = [lake[-1][0],lake[-1][1] - 1]
            southcheck = [lake[0][0],lake[0][1] + 1]

            coords = filter(lambda x: x[1] == y, lake)
            coords.sort(ListCmp)
            x = (coords[0][0] + coords[-1][0]) / 2

            checklist = [eastcheck,westcheck,northcheck,southcheck]
            checkwrong = 0

            for check in checklist:
                try:
                    if wheightdict['%s,%s' % (check[0],check[1])] < 151:
                        checkwrong += 1
                except KeyError:
                    pass
            if checkwrong > 0:
                islake = False

            if len(lake) < 5:
                islake = False
            
            if islake:
                lakename = MakeName(PLang)
                if len(lake) > 1800:
                    lakename = choice(['The Sea of %s','The %s Sea']) % lakename
                else:
                    if randrange(1,20) == 1:
                        lakename = lakename + ' Basin'
                    elif randrange(1,20) == 1:
                        lakename = lakename + ' Mere'
                    else:
                        lakename = choice([lakename + ' Lake','Lake ' + lakename])
                libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_ALPHA(0.6), libtcod.CENTER, lakename)
                wlakedict[lakename] = lake

        wgtext = 'Finished!'
        CurText = FadeText(wgtext, 1, 25, con=wswindow, speed=25).start()

        wgtext = 'Naming islands,\nthis may take\nsome time...'
        CurText = FadeText(wgtext, 1, 27, con=wswindow, speed=25).start()

        # Locate islands.

        wisledict = {}
        islandlist = []
        shoredict = {}
        for x in range(MAP_WIDTH):
            for y in range(MAP_HEIGHT):
                if 'b' in wfeaturedict['%s,%s' % (x,y)]:
                    shoredict['%s,%s' % (x,y)] = [x,y]

        checkeddict = {}
        poslist = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
        while len(shoredict) > 0:
            curbody = []
            curpos = shoredict.items()[0][1]
            unchecked = []
            unchecked.append(curpos)
            while len(unchecked) > 0:
                checkpos = unchecked[0]
                for newpos in map(lambda x: [checkpos[0] - x[0], checkpos[1] - x[1]],poslist):
                    try:
                        checkeddict['%s,%s' % (newpos[0],newpos[1])]
                        pass
                    except KeyError:
                        checkeddict['%s,%s' % (newpos[0],newpos[1])] = 1
                        if not (-1 < newpos[0] < MAP_WIDTH and -1 < newpos[1] < MAP_HEIGHT):
                            continue
                        try:
                            if shoredict['%s,%s' % (newpos[0],newpos[1])]:
                                unchecked.append(newpos)
                        except KeyError:
                            if wheightdict['%s,%s' % (newpos[0],newpos[1])] > 151:
                                unchecked.append(newpos)
                curbody.append(checkpos)
                unchecked.remove(checkpos)
            for pos in curbody:
                try:
                    shoredict.pop('%s,%s' % (pos[0],pos[1]))
                except KeyError:
                    pass
            islandlist.append(curbody)

        # Generate island names.

        wisledict = {}
        libtcod.console_set_default_background(wgwindow, libtcod.desaturated_orange)
        libtcod.console_set_default_foreground(wgwindow, libtcod.white)
        islandlist.sort(LenCmp)
        for island in islandlist:
            isisle = True
            island.sort(ListCmp)
            xmax = island[0][0]
            xmin = island[-1][0]
            xquarter = (xmax - xmin) / 4
            westcheck = [island[-1][0] - 1,island[-1][1]]
            eastcheck = [island[0][0] + 1,island[0][1]]
            island.sort(ListCmp2)
            ymax = island[0][1]
            ymin = island[-1][1]
            yquarter = (ymax - ymin) / 4
            y = int((ymax + ymin) / 2)
            northcheck = [island[-1][0],island[-1][1] - 1]
            southcheck = [island[0][0],island[0][1] + 1]

            coords = filter(lambda x: x[1] == y, island)
            coords.sort(ListCmp)
            x = (coords[0][0] + coords[-1][0]) / 2

            checklist = [eastcheck,westcheck,northcheck,southcheck]
            checkwrong = 0

            for check in checklist:
                try:
                    if wheightdict['%s,%s' % (check[0],check[1])] > 151:
                        checkwrong += 1
                except KeyError:
                    pass
            if checkwrong > 0:
                isisle = False

            if len(island) < 5:
                isisle = False
            
            if isisle:
                islename = MakeName(PLang)
                if len(island) > 20000:
                    islename = 'The Continent of %s' % islename
                else:
                    islename = choice([islename + ' Isle', islename + ' Island', 'The Isle of ' + islename])
                libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_ALPHA(0.6), libtcod.CENTER, islename)
                wisledict[islename] = island

        wgtext = 'Finished!'
        CurText = FadeText(wgtext, 1, 31, con=wswindow, speed=25).start()

        wgtext = 'Naming oceans...'
        CurText = FadeText(wgtext, 1, 33, con=wswindow, speed=25).start()
               
        # Name oceans/seas.

        woceandict = {}
        libtcod.console_set_default_background(wgwindow, libtcod.dark_blue)
        libtcod.console_set_default_foreground(wgwindow, libtcod.white)
        
        nocean = []
        socean = []
        eocean = []
        wocean = []

        xmid = MAP_WIDTH / 2
        ymid = MAP_HEIGHT / 2

        npoint = [xmid,0]
        spoint = [xmid,MAP_HEIGHT - 1]
        wpoint = [0,ymid]
        epoint = [MAP_WIDTH - 1,ymid]

        for tile in oceantiles:
            ndist = int(sqrt(pow(tile[0] - npoint[0],2) + pow(tile[1] - npoint[1],2)))
            sdist = int(sqrt(pow(tile[0] - spoint[0],2) + pow(tile[1] - spoint[1],2)))
            wdist = int(sqrt(pow(tile[0] - wpoint[0],2) + pow(tile[1] - wpoint[1],2)))
            edist = int(sqrt(pow(tile[0] - epoint[0],2) + pow(tile[1] - epoint[1],2)))

            dlist = [('nocean',ndist),('socean',sdist),('wocean',wdist),('eocean',edist)]
            dlist.sort(ListCmp2)
            vars()[dlist[-1][0]] += [tile]

        oceanname = MakeName(PLang)
        oceanname = choice(['%s Ocean', 'The %s Ocean']) % oceanname
        libtcod.console_print_ex(wgwindow, MAP_WIDTH / 2, 1, libtcod.BKGND_ALPHA(0.6), libtcod.CENTER, oceanname)
        woceandict[oceanname] = nocean

        oceanname = MakeName(PLang)
        oceanname = choice(['%s Ocean', 'The %s Ocean']) % oceanname
        libtcod.console_print_ex(wgwindow, MAP_WIDTH / 2, MAP_HEIGHT - 2, libtcod.BKGND_ALPHA(0.6), libtcod.CENTER, oceanname)
        woceandict[oceanname] = socean

        oceanname = MakeName(PLang)
        oceanname = choice(['%s Ocean', 'The %s Ocean']) % oceanname
        libtcod.console_print_ex(wgwindow, 1, MAP_HEIGHT / 2, libtcod.BKGND_ALPHA(0.6), libtcod.LEFT, oceanname)
        woceandict[oceanname] = wocean

        oceanname = MakeName(PLang)
        oceanname = choice(['%s Ocean', 'The %s Ocean']) % oceanname
        libtcod.console_print_ex(wgwindow, MAP_WIDTH - 2, MAP_HEIGHT / 2, libtcod.BKGND_ALPHA(0.6), libtcod.RIGHT, oceanname)
        woceandict[oceanname] = eocean

        NoKeys = True

        time.sleep(1.0)

        while True:
            try:
                if init['WORLDGEN PICS'] == 'YES':
                    wgnpic = libtcod.image_from_console(wgwindow)
                    libtcod.image_save(wgnpic,'.\\image\\gfx\\worldgenpn.png')
                break
            except WindowsError:
                pass

        NoKeys = False

        libtcod.console_clear(wswindow)

        libtcod.console_set_default_foreground(wswindow, hcolor)
        libtcod.console_print_ex(wswindow, 9, ((SCREEN_HEIGHT - 2) / 2) - 9, libtcod.BKGND_NONE, libtcod.CENTER, 'Naming complete!')

        libtcod.console_set_default_foreground(wswindow, libtcod.white)
        libtcod.console_print_ex(wswindow, 9, ((SCREEN_HEIGHT - 2) / 2) - 7, libtcod.BKGND_NONE, libtcod.CENTER, 'To move on to\ncreature gen,\ntype \'c\'.\n\nOtherwise,\npress \'g\' or\nclick the button\nto generate a\nnew map.')        

        libtcod.console_set_default_background(wgwindow, libtcod.black)
        genbutton = ButtonBox(wswindow, 6, ((SCREEN_HEIGHT - 2) / 2) + 4, 'New Map', 'g')
        cgenbutton = ButtonBox(wswindow, 3, ((SCREEN_HEIGHT - 2) / 2) + 8, 'Creature Gen.', 'c')

        WorldGoing = False
        NamingDone = True
        del self

####################################
# XI. Entity Generation            #
####################################

class WorldCreatures(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)

    def ptraits(self,creature,part):
        # Note: Trait structure is [Predations,Spheres,Exceptions,Stat Mods,Word List,Weight Mod]
        global bodydict, idict
        dimwords = ['long','short','wide','thin','large','small','narrow','thick']
        bigwords = ['long','wide','large','thick','stocky']
        smallwords = ['short','thin','small','narrow','scrawny','bony']
        traitchance = 1
        excludelist = []
        traitlist = []
        traitpairs = []
        modtraitdict = {}
        traitdict = bodydict[part]
        while True:
            if randrange(1,traitchance + 1) == 1:
                trait = choice(traitdict.items())
                traitcontchance = 1
                if 'rare' in trait[1][2]:
                    traitcontchance = 10
                elif 'very_rare' in trait[1][2]:
                    traitcontchance = 25
                elif 'ultra_rare' in trait[1][2]:
                    traitcontchance = 100
                if 1 != randrange(1,traitcontchance + 1):
                    continue
                nulltrait = False
                for etrait in traitlist:
                    if etrait in trait[1][2] or trait[0] in traitdict[etrait][2] or etrait in trait[1][4]:
                        nulltrait = True
                        break
                if not (creature['predation'] in trait[1][0] or trait[1][0] == '*'):
                    nulltrait = True
                if not (creature['sphere'] in trait[1][1] or trait[1][1] == '*'):
                    nulltrait = True
                if nulltrait:
                    pass
                else:
                    traitchance = traitchance * 2
                    inum = wchoice([(0,.7),(1,.1),(2,.05),(3,.05),(4,.05),(5,.05)])

                    traitword = choice(trait[1][4])

                    # Ensure size-trait sensibility

                    dimword = None
                    sizetraitnum = 0
                    for etrait in traitlist:
                        if etrait in dimwords:
                            sizetraitnum += 1
                            dimword = etrait
                    if trait[0] in dimwords:
                        sizetraitnum += 1
                        if sizetraitnum > 2:
                            continue
                        elif dimword in ['small','large','stumpy'] or (trait[0] in ['small','large','stumpy'] and dimword):
                            continue
                    if dimword in excludelist:
                        dimword = None

                    # Add intensity variables

                    if inum > 0 and 'grade_off' not in trait[1][2]:
                        intensity = choice(idict[inum])
                        if dimword and trait[0] in dimwords:
                            if dimword in smallwords and trait[0] in bigwords:
                                modtraitdict[trait[0]] = intensity + ' ' + traitword + ' but ' + modtraitdict.pop(dimword)
                            elif dimword in bigwords and trait[0] in smallwords:
                                modtraitdict[trait[0]] = modtraitdict.pop(dimword) + ' but ' + intensity + ' ' + traitword
                            excludelist.append(dimword)
                        else:
                            modtraitdict[trait[0]] = intensity + ' ' + traitword
                    else:
                        if dimword and trait[0] in dimwords:
                            if dimword in smallwords and trait[0] in bigwords:
                                modtraitdict[trait[0]] = traitword + ' but ' + modtraitdict.pop(dimword)
                            elif dimword in bigwords and trait[0] in smallwords:
                                modtraitdict[trait[0]] = modtraitdict.pop(dimword) + ' but ' + traitword
                            elif dimword in bigwords and trait[0] in bigwords:
                                excludelist.append(dimword)
                        else:
                            modtraitdict[trait[0]] = traitword

                    traitlist.append(trait[0])
                    traitpairs.append([trait[0],inum])
                    if inum > 3 and 'grade_off' not in trait[1][2]:
                        try:
                            creature['nfeatures'] += intensity + ' ' + traitword
                        except KeyError:
                            creature['nfeatures'] = [intensity + ' ' + traitword]
            else:
                modtraitlist = modtraitdict.values()
                creature['traits'][part] = traitpairs
                return modtraitlist
                break

    def run(self):
        global SCREEN_HEIGHT, VIEW_HEIGHT, SCREEN_WIDTH, VIEW_WIDTH, wiwindow, \
               wgwindow, wswindow, worldmap, wheighdict, wfeaturedict, wgpic, \
               NoKeys, WorldGoing, CreatureDone, woceandict, wlakedict, \
               wlakedict, wtundradict, wcavedict, wriverdict, wlangdict, PLang, \
               wcreaturedict, wspiritdict, wgoddict, ButtonList, bodydict, idict, \
               paraswitch, ctitles, curchoice, KeyLock, wtexturedict, wbiomedict

        WorldGoing = True

        DrawWorld(wgwindow, cities = False)

        libtcod.console_set_default_foreground(wswindow, libtcod.white)
        libtcod.console_print_ex(wswindow, 9, 1, libtcod.BKGND_NONE, libtcod.CENTER, 'Gods, Spirits,\n& Creature Gen')

        libtcod.console_set_default_foreground(wswindow, hcolor)
        libtcod.console_print_ex(wswindow, 9, 4, libtcod.BKGND_NONE, libtcod.CENTER, '~*~*~*~')

        # Creature Gen

        wgtext = 'Creating\ncreatures...'
        CurText = FadeText(wgtext, 1, 6, con=wswindow, speed=25).start()

        wcreaturedict = {}

        # Intensity Dictionary Setup

        idict = {}
        idict[5] = ['extremely', 'incredibly', 'amazingly', 'fantastically', 'unbelievably', 'inexplicably', 'phenomenally']
        idict[4] = ['radically', 'excessively', 'abnormally', 'exceptionally', 'extraordinarily']
        idict[3] = ['remarkably', 'surpassingly', 'strikingly']
        idict[2] = ['markedly', 'particularly', 'very', 'especially']
        idict[1] = ['quite', 'somewhat', 'fairly', 'rather']

        # Morphological Characteristics (Shape of Limb/Body Part)

        # [Predations, Biomes, Exclusions, Stat Mods, Desc. Variations, % Weight Mod]
        # Exclusions = Other morph. characteristics which should not be shared with this one. Ex. long & short
        # grade_off = Excludes intensity gradient AND variable stat changes. Changes must be static!
        # rare = Lowered chance of this trait being selected.
        # very_rare = VERY low chance of this trait being selected.
        # ultra_rare = INCREDIBLY low chance of this trait being selected.

        antdict = {}
        antdict['long'] = ['*','*',['short'],[('ATK',5),('AGI',-2)],['long','lengthy','protracted'],2]
        antdict['short'] = ['*','*',['long'],[('ATK',3),('AGI',-1)],['short','stubby'],0]
        antdict['thick'] = ['*','*',['thin'],[('ATK',3),('AGI',-1)],['thick','dense'],2]
        antdict['thin'] = ['*','*',['thick'],[('ATK',2)],['thin','narrow','slender'],0]
        antdict['curved'] = ['*','*',['straight'],[('ATK',3),('AGI',-1)],['curved','bowed','curly','hooked'],0]
        antdict['straight'] = ['*','*',['curved'],[('ATK',2)],['straight','erect'],0]
        antdict['plumed'] = ['*','*',['smooth'],[('AP',3)],['plumed','fuzzy'],0]
        antdict['smooth'] = ['*','*',['plumed'],[('DEF',3)],['smooth','sleek'],0]

        beakdict = {}
        beakdict['long'] = ['*','*',['short'],[('AGI',3),('ATK',3),('DEF',-3),('END',-3)],['long','lengthy','protracted','tubular'],0]
        beakdict['short'] = ['*','*',['long'],[('STR',3),('DEF',3),('AGI',-3),('ATK',-3)],['short','stubby','stunted'],-1]
        beakdict['hooked'] = [['Carnivore','Omnivore'],'*',['pointed','fringed','grade_off','cone-like'],[('STR',8),('ATK',10)],['hooked'],0]
        beakdict['sharp'] = ['*','*',['fringed'],[('ATK',5),('AGI',2),('END',-2),('AP',-5)],['sharp','edged'],0]
        beakdict['narrow'] = ['*','*',['wide'],[('AGI',5),('AP',5),('ATK',-3),('STR',-5)],['narrow','slender'],-2]
        beakdict['thick'] = ['*','*',['narrow'],[('END',3),('DEF',3),('AGI',-3),('AP',-3)],['thick','heavy','dense','solid'],2]
        beakdict['pointed'] = ['*','*',['hooked','fringed'],[('ATK',4),('AGI',4),('AP',2),('END',-4),('STR',-4)],['pointed','chisel-like'],0]
        beakdict['fringed'] = [['Herbivore','Omnivore'],'*',['pointed','hooked'],[('DEF',4),('END',4),('ATK',-4),('STR',-4)],['fringed'],0]
        beakdict['thin'] = ['*','*',['thick'],[('AGI',3),('DEF',-1),('END',-2)],['thin','light','flimsy','reedy'],-1]
        beakdict['wide'] = ['*','*',['narrow'],[('END',4),('ATK',4),('DEF',-4),('AGI',-4)],['wide','broad'],2]
        beakdict['cone-like'] = [['Herbivore','Omnivore'],'*',['grade_off','hooked'],[('STR',8),('AP',-4),('END',-4)],['cone-like','conical'],1]
        beakdict['large'] = ['*','*',['small','short','thin'],[('AP',3),('AGI',-2)],['large','enormous','giant','huge'],1]
        beakdict['small'] = ['*','*',['large','long'],[('AGI',3),('AP',-2)],['small','tiny','miniature','petite'],-1]

        clawdict = {}
        clawdict['long'] = ['*','*',['short'],[('ATK',5),('AGI',-2)],['long','lengthy','protracted'],2]
        clawdict['short'] = ['*','*',['long'],[('ATK',3),('AGI',-1)],['short','stubby'],0]
        clawdict['thick'] = ['*','*',['thin'],[('ATK',3),('AGI',-1)],['thick','dense'],2]
        clawdict['thin'] = ['*','*',['thick'],[('ATK',2)],['thin','narrow','slender'],0]
        clawdict['curved'] = ['*','*',['straight'],[('ATK',3),('AGI',-1)],['curved','bowed','curled','hooked'],0]
        clawdict['straight'] = ['*','*',['curved'],[('ATK',2)],['straight'],0]
        clawdict['retracting'] = ['*','*',['grade_off','rare'],[('AP',10),('AGI',10)],['retracting'],0]
        clawdict['poisonous'] = ['*','*',['grade_off','very_rare','blunt'],[],['poisonous','venomous'],0]
        clawdict['blunt'] = ['*','*',['sharp','poisonous'],[('DEF',3),('ATK',-2)],['blunt','dull'],0]
        clawdict['sharp'] = ['*','*',['blunt'],[('ATK',3),('AP',-1)],['sharp','pointy','blade-like'],0]

        digitdict = {}
        digitdict['long'] = ['*','*',['short'],[('AGI',3),('STR',-1),('DEF',-2)],['long','lengthy','protracted'],0]
        digitdict['short'] = ['*','*',['long'],[('DEF',2),('STR',1),('AGI',-1),('ATK',-2)],['short','stubby','stunted'],-1]
        digitdict['thick'] = ['*','*',['thin','lithe'],[('END',2),('DEF',1),('ATK',-1),('AGI',-2)],['thick','heavy','dense','solid','meaty'],1]
        digitdict['thin'] = ['*','*',['thick','bulky'],[('AGI',3),('DEF',-1),('END',-2)],['thin','light','flimsy','reedy'],-1]
        digitdict['many-jointed'] = ['*','*',['grade_off','stumpy','flexible','rare'],[('AGI',8),('END',-4),('DEF',-4)],['multi-jointed','several-jointed','many-jointed'],0]
        digitdict['muscular'] = ['*','*',['lithe','bony'],[('STR',2),('DEF',1),('AGI',-1),('END',-2)],['brawny','muscular','burly'],1]
        digitdict['lithe'] = ['*','*',['thick','bulky','muscular','bony'],[('AGI',3),('STR',-2),('DEF',-1)],['sinewy','lithe','supple'],-1]
        digitdict['bulky'] = ['*','*',['thin','lithe'],[('STR',3),('END',-2),('AGI',-1)],['bulky','massive','hefty','immense'],2]
        digitdict['stumpy'] = ['*','*',['thin','lithe','many-jointed','grade_off'],[('DEF',10),('STR',6),('AGI',-10),('ATK',-6)],['stumpy','stocky','stout'],1]
        digitdict['clawed'] = ['*',['Terrestrial','Subterranean','Amphibian'],['grade_off'],[('ATK',10),('AGI',-2)],['clawed','spurred'],1]
        digitdict['taloned'] = ['*',['Aerial'],['grade_off'],[('ATK',10),('AGI',-2)],['taloned'],1]
        digitdict['bony'] = ['*','*',['muscular','lithe'],[('END',2),('STR',-2)],['bony','gaunt','skeletal'],-1]
        digitdict['flexible'] = ['*','*',['many-jointed','stumpy'],[('AGI',4),('ATK',2),('DEF',-2),('END',-4)],['flexible','limber','bendable'],0]
        digitdict['large'] = ['*','*',['small','short','thin'],[('AP',3),('AGI',-2)],['large','enormous','giant','huge'],1]
        digitdict['small'] = ['*','*',['large','long'],[('AGI',3),('AP',-2)],['small','tiny','miniature','petite'],-1]

        eardict = {}
        eardict['short'] = ['*','*',['long','large'],[('DEF',3),('AP',-2)],['short','stubby','stunted'],-1]
        eardict['broad'] = ['*','*',['narrow'],[('AP',3),('DEF',-2)],['broad','wide'],1]
        eardict['long'] = ['*','*',['short'],[('AP',4),('SPD',-1),('DEF',-2)],['long','lengthy','protracted'],1]
        eardict['narrow'] = ['*','*',['broad'],[('DEF',3),('AP',-2)],['narrow','slender'],-1]
        eardict['triangular'] = ['*','*',['arched','round'],[('ATK',3),('DEF',-2)],['triangular','pyriform','cuneate'],-1]
        eardict['large'] = ['*','*',['short','small'],[('AP',4),('DEF',-2)],['large','expansive','giant','voluminous'],2]
        eardict['small'] = ['*','*',['large','long'],[('DEF',4),('AP',-2)],['small','tiny','miniature','petite'],-1]
        eardict['arched'] = ['*','*',['triangular'],[('AP',2),('DEF',2),('ATK',-3)],['arched','vaulted','curved','bowed'],0]
        eardict['pointed'] = ['*','*',['round'],[('ATK',3),('DEF',-1)],['pointed','cuspate'],0]
        eardict['floppy'] = ['*','*',['upright'],[('AP',3),('DEF',-1)],['floppy','flopsy'],-1]
        eardict['back-swept'] = ['*','*',['grade_off','rare'],[('SPD',5),('ATK',5),('AP',-5)],['back-swept'],0]
        eardict['tufted'] = ['*','*',['grade_off','very_rare'],[('DEF',6)],['tufted'],0]
        eardict['round'] = ['*','*',['pointed','triangular'],[('DEF',2),('AP',-1)],['round','curved','oval-shaped'],0]
        eardict['upright'] = ['*','*',['floppy','grade_off'],[('ATK',6),('AP',4),('SPD',-2),('DEF',-4)],['upright'],0]

        exodict = {}
        exodict['thick'] = ['*','*',['thin'],[('AC',3),('DEF',2),('AGI',-2),('SPD',-3)],['thick','tough','dense','solid'],5]
        exodict['thin'] = ['*','*',['thick'],[('SPD',3),('AGI',2),('END',-2),('DEF',-3)],['thin','light','flimsy'],-5]
        exodict['translucent'] = ['*','*',['transparent','rare'],[('AP',3),('DEF',-1)],['translucent','diaphanous','membranous'],-5]
        exodict['transparent'] = ['*','*',['translucent','ultra_rare'],[('AP',5),('DEF',-3)],['transparent','see-through','membranous'],-5]
        exodict['smooth'] = ['*','*',['rough','spiked','ridged'],[('AGI',3),('DEF',-1)],['smooth','sleek','unblemished'],0]
        exodict['rough'] = ['*','*',['smooth'],[('AC',3),('AGI',-1)],['rough','bumpy','pitted'],0]
        exodict['hard'] = ['*','*',['soft'],[('AC',5),('AGI',-2)],['hard','tough','inflexible','stiff'],5]
        exodict['soft'] = ['*','*',['hard'],[('AGI',3),('AC',-1)],['soft','flexible','pliable'],0]
        exodict['shiny'] = ['*','*',['dull'],[('AP',3)],['shiny','glossy'],0]
        exodict['dull'] = ['*','*',['shiny'],[('AC',3)],['dull','opaque'],0]
        exodict['spiky'] = ['*','*',['smooth','ridged'],[('ATK',5),('AC',3),('AGI',-3)],['spiny','thorny','spiky'],5]
        exodict['ridged'] = ['*','*',['smooth','spiky'],[('AC',5),('AGI',-2)],['ridged','ribbed'],3]

        eyedict = {}
        eyedict['wide'] = ['*','*',['narrow'],[('DEF',3),('ATK',-1)],['wide','broad'],0]
        eyedict['narrow'] = ['*','*',['wide'],[('ATK',3),('DEF',-1)],['narrow','slender'],0]
        eyedict['oval'] = ['*','*',['circular','slanted','squarish','grade_off'],[],['egg-shaped','oval','oblong','elliptical'],0]
        eyedict['circular'] = ['*','*',['oval','slanted','squarish','grade_off'],[],['circular','round','disklike'],0]
        eyedict['slanted'] = ['*','*',['circular','squarish','oval','grade_off'],[],['slanted','oblique'],0]
        eyedict['squarish'] = ['*','*',['oval','circular','slanted','grade_off'],[],['squarish','boxy','boxlike'],0]
        eyedict['large'] = ['*','*',['small'],[('AP',3),('DEF',-1)],['large','enormous','giant','huge'],0]
        eyedict['small'] = ['*','*',['large'],[('DEF',3),('AP',-1)],['small','tiny','miniature','petite'],0]
        eyedict['stalk-supported'] = ['*','*',['grade_off','ultra_rare','sunken','protuberant'],[('AP',15),('DEF',-5)],['stalk-supported','stem-supported'],1]
        eyedict['vertically slitted'] = ['*','*',['grade_off','rare','horizontally slitted','multi-faceted'],[('ATK',10)],['vertically slitted'],0]
        eyedict['horizontally slitted'] = ['*','*',['grade_off','very_rare','vertically slitted','multi-faceted'],[('DEF',10)],['horizontally slitted'],0]
        eyedict['protuberant'] = ['*','*',['stalk-supported','sunken'],[('AP',3),('DEF',-2)],['protuberant','bulging','raised'],0]
        eyedict['sunken'] = ['*','*',['stalk-supported','protuberant'],[('DEF',3),('AP',-2)],['sunken','depressed','recessed'],0]
        eyedict['reflective'] = ['*','*',['rare'],[('AP',6)],['reflective','glowing'],0]
        eyedict['multi-faceted'] = ['*','*',['rare','grade_off','slanted','vertically slitted','horizontally slitted'],[('AP',10),('DEF',-4)],['multi-faceted'],0]

        feathdict = {}
        feathdict['downy'] = ['*','*',['bristly','smooth'],[('END',3),('SPD',-1)],['downy','soft','fuzzy','plush'],0]
        feathdict['bristly'] = ['*','*',['downy','smooth'],[('AC',3),('AGI',-1)],['bristly','stiff','coarse'],0]
        feathdict['smooth'] = ['*','*',['downy','bristly'],[('SPD',3),('END',-1)],['smooth','sleek','silky'],0]
        feathdict['long'] = ['*','*',['short'],[('END',3),('SPD',2)],['long','lengthy','protracted'],0]
        feathdict['short'] = ['*','*',['long'],[('AGI',3),('AP',2)],['short','stubby'],0]
        feathdict['curved'] = ['*','*',['straight'],[('AGI',3),('AP',2)],['curved','bowed'],0]
        feathdict['straight'] = ['*','*',['curved'],[('END',3),('SPD',2)],['straight','inflexible'],0]
        feathdict['broad'] = ['*','*',['thin'],[('END',3),('AP',2)],['broad','wide'],0]
        feathdict['thin'] = ['*','*',['broad'],[('AGI',3),('SPD',2)],['thin','narrow','slender'],0]
        feathdict['shiny'] = ['*','*',['dull'],[('AP',3)],['shiny','glossy'],0]
        feathdict['dull'] = ['*','*',['shiny'],[('AC',3)],['dull','opaque'],0]

        findict = {}
        findict['long'] = ['*','*',['short'],[('AGI',3),('STR',-1),('DEF',-2)],['long','lengthy','protracted'],1]
        findict['short'] = ['*','*',['long'],[('DEF',2),('STR',1),('AGI',-1),('ATK',-2)],['short','stubby','stunted'],-2]
        findict['thick'] = ['*','*',['thin'],[('END',2),('DEF',1),('ATK',-1),('AGI',-2)],['thick','heavy','dense','solid','meaty'],2]
        findict['thin'] = ['*','*',['thick'],[('AGI',3),('DEF',-1),('END',-2)],['thin','light','flimsy','reedy'],-2]
        findict['curved'] = ['*','*',['straight','rounded'],[('SPD',3),('END',2),('AGI',-3)],['curved','curvilinear','aquiline','crescent-shaped'],0]
        findict['straight-edged'] = ['*','*',['curved','rounded'],[('AGI',3),('ATK',2),('SPD',-2),('END',-1)],['straight-edged','pointed','truncated'],0]
        findict['round'] = ['*','*',['straight','curved','forked','rare'],[('SPD',2),('AGI',2),('ATK',-2),('STR',-2)],['round','discoid','ovular'],0]
        findict['forked'] = ['*','*',['round','grade_off','rare'],[('AGI',6),('DEF',2),('END',-2),('SPD',-6)],['forked','divergent','split','bifurcated'],0]
        findict['ridged'] = ['*','*',['smooth'],[('DEF',4),('SPD',-4)],['ridged','striated','jagged'],2]
        findict['smooth'] = ['*','*',['ridged'],[('SPD',4),('DEF',-4)],['smooth','flush','planar'],0]
        findict['large'] = ['*','*',['small','short','thin'],[('AP',3),('AGI',-2)],['large','enormous','giant','huge'],2]
        findict['small'] = ['*','*',['large','long'],[('AGI',3),('AP',-2)],['small','tiny','miniature','petite'],-2]

        furdict = {}
        furdict['long'] = ['*','*',['short'],[('AC',3),('AGI',-1)],['long','lengthy'],1]
        furdict['short'] = ['*','*',['long'],[('AP',2)],['short','stubby'],0]
        furdict['shaggy'] = ['*','*',['sleek'],[('AC',3),('AP',-1)],['shaggy','rugged','rough'],1]
        furdict['sleek'] = ['*','*',['shaggy'],[('AP',3),('AC',-1)],['sleek','silky','smooth'],0]
        furdict['wiry'] = ['*','*',['soft'],[('AC',3),('AP',-1)],['wiry','bristly','prickly'],0]
        furdict['soft'] = ['*','*',['wiry'],[('AP',3),('AC',-1)],['soft','plush','fleecy'],0]
        furdict['straight'] = ['*','*',['curly','frizzy'],[('AP',2)],['straight'],0]
        furdict['curly'] = ['*','*',['straight'],[('AC',2)],['curly','wavy','krinkly'],0]
        furdict['frizzy'] = ['*','*',['straight'],[('AC',1)],['frizzy','fuzzy'],0]

        gilldict = {}
        gilldict['long'] = ['*','*',['short'],[('AP',3),('DEF',-3)],['long','lengthy','protracted','elongated'],0]
        gilldict['short'] = ['*','*',['long'],[('AP',2),('DEF',-2)],['short','abbreviated','undersized'],0]
        gilldict['broad'] = ['*','*',['narrow'],[('END',2),('DEF',-2)],['broad','wide'],0]
        gilldict['narrow'] = ['*','*',['broad'],[('DEF',2),('END',-2)],['narrow','thin','slender'],0]
        gilldict['multi-slitted'] = ['*','*',['single-slitted'],[('AP',4),('DEF',-2)],['many-slitted','multi-slitted'],0]
        gilldict['single-slitted'] = ['*','*',['multi-slitted','rare'],[('DEF',4),('AP',-2)],['single-slitted'],0]
        gilldict['straight'] = ['*','*',['curved'],[('AP',2),('DEF',-2)],['straight'],0]
        gilldict['curved'] = ['*','*',['straight'],[('DEF',2),('AP',-2)],['curved','curled','bowed','hooked'],0]

        handdict = {}
        handdict['broad'] = ['*','*',['narrow'],[('END',2),('STR',1),('DEF',-1),('AGI',-2)],['broad','wide','splayed-out'],0]
        handdict['narrow'] = ['*','*',['bulky','broad'],[('AGI',2),('DEF',1),('STR',-1),('END',-2)],['narrow','slender'],-5]
        handdict['thick'] = ['*','*',[],[('END',2),('DEF',1),('SPD',-1),('AGI',-2)],['thick','heavy','dense','solid','meaty'],5]
        handdict['muscular'] = ['*','*',[],[('STR',2),('DEF',1),('AGI',-1),('END',-2)],['brawny','muscular','burly'],5]
        handdict['bulky'] = ['*','*',['narrow','flexible'],[('STR',3),('END',-2),('AGI',-1)],['bulky','massive','hefty'],5]
        handdict['stumpy'] = ['*','*',['flexible','grade_off'],[('DEF',10),('STR',6),('AGI',-10),('SPD',-6)],['stumpy','stocky','stout'],5]
        handdict['flexible'] = ['*','*',['bulky','stumpy'],[('AGI',4),('ATK',2),('DEF',-2),('END',-4)],['flexible','limber','bendable'],0]
        handdict['padded'] = ['*','*',[],[('DEF',3),('END',2),('ATK',-2),('AGI',-3)],['padded','calloused','thickly-padded'],2]        
        handdict['large'] = ['*','*',['small'],[('AP',3),('AGI',-2)],['large','enormous','giant','huge'],5]
        handdict['small'] = ['*','*',['large'],[('AGI',3),('AP',-2)],['small','tiny','miniature','petite'],-5]

        hipdict = {}
        hipdict['long'] = ['*','*',['short','small'],[('END',3),('DEF',-3)],['long','lengthy','protracted','elongated'],5]
        hipdict['short'] = ['*','*',['long','large','lithe'],[('DEF',3),('END',-3)],['short','stubby','stunted','stocky'],-5]
        hipdict['thin'] = ['*','*',['thick','bulbous','bulky'],[('AGI',3),('STR',-3)],['thin','narrow','slender'],-5]
        hipdict['thick'] = ['*','*',['thin'],[('STR',3),('AGI',-3)],['thick','broad','wide'],5]
        hipdict['muscular'] = ['*','*',['lithe','scrawny'],[('STR',4),('END',-2)],['muscular','brawny','bulky'],5]
        hipdict['scrawny'] = ['*','*',['lithe','muscular','bulbous','bulky'],[('END',4),('STR',-4)],['scrawny','gaunt','skinny'],-5]
        hipdict['lithe'] = ['*','*',['muscular','scrawny','bulbous','squarish','bulky'],[('AGI',4),('STR',-2)],['lithe','supple','lean'],0]
        hipdict['bulbous'] = ['*','*',['small','very_rare','scrawny','thin','lithe','squarish'],[('STR',3),('DEF',-3)],['bulbous','bulging','bloated'],5]
        hipdict['squarish'] = ['*','*',['bulbous','lithe'],[('END',2)],['squarish','blockish'],0]
        hipdict['large'] = ['*','*',['short','small'],[('STR',4)],['large','enormous','big','huge'],10]
        hipdict['small'] = ['*','*',['bulbous','long','large','bulky'],[('AGI',4)],['small','tiny','miniature','petite'],-10]
        hipdict['bulky'] = ['*','*',['thin','lithe','small','scrawny'],[('STR',3),('END',-2),('AGI',-1)],['bulky','awkward'],5]

        hoofdict = {}
        hoofdict['long'] = ['*','*',['short'],[('AGI',3),('STR',-1),('DEF',-2)],['long','lengthy','protracted'],1]
        hoofdict['short'] = ['*','*',['long'],[('DEF',2),('STR',1),('AGI',-1),('ATK',-2)],['short','stubby','stunted'],-2]
        hoofdict['thick'] = ['*','*',['thin'],[('END',2),('DEF',1),('ATK',-1),('AGI',-2)],['thick','heavy','dense','solid'],2]
        hoofdict['thin'] = ['*','*',['thick'],[('AGI',3),('DEF',-1),('END',-2)],['thin','light','flimsy','reedy'],-2]
        hoofdict['stumpy'] = ['*','*',['thin','grade_off'],[('DEF',10),('STR',6),('AGI',-10),('ATK',-6)],['stumpy','stocky','stout'],2]
        hoofdict['cloven'] = ['*','*',['single-toed','grade_off'],[('SPD',10)],['cloven','two-toed','four-toed'],0]
        hoofdict['single-toed'] = ['*','*',['cloven','grade_off'],[('SPD',6)],['single-toed','three-toed','five-toed'],0]
        hoofdict['sharp'] = ['*','*',['stumpy','blunt'],[('ATK',6),('SPD',-4)],['sharp','pointed','sharpened','jagged'],0]
        hoofdict['large'] = ['*','*',['small','short','thin'],[('AP',3),('AGI',-2)],['large','enormous','giant','huge'],5]
        hoofdict['small'] = ['*','*',['large','long'],[('AGI',3),('AP',-2)],['small','tiny','miniature','petite'],-5]

        horndict = {}
        horndict['long'] = ['*','*',['short'],[('ATK',5),('AGI',-2)],['long','lengthy','protracted'],2]
        horndict['short'] = ['*','*',['long'],[('ATK',3),('AGI',-1)],['short','stubby'],0]
        horndict['thick'] = ['*','*',['thin'],[('ATK',3),('AGI',-1)],['thick','dense'],2]
        horndict['thin'] = ['*','*',['thick'],[('ATK',2)],['thin','narrow','slender'],0]
        horndict['curved'] = ['*','*',['straight'],[('ATK',3),('AGI',-1)],['curved','bowed','curled','hooked'],0]
        horndict['straight'] = ['*','*',['curved'],[('ATK',2)],['straight'],0]
        horndict['blunt'] = ['*','*',['sharp','barbed'],[('DEF',3),('ATK',-2)],['blunt','dull'],0]
        horndict['sharp'] = ['*','*',['blunt'],[('ATK',3),('AP',-1)],['sharp','pointy','blade-like'],0]
        horndict['barbed'] = ['*','*',['blunt','grade_off','rare'],[('ATK',10),('DEF',-5)],['barbed'],0]
        horndict['pronged'] = ['*','*',['grade_off','rare'],[('ATK',5)],['pronged','tined'],2]
        horndict['spiky'] = ['*','*',['smooth'],[('ATK',3),('AP',-1)],['spiky','spiny'],0]
        horndict['rough'] = ['*','*',['smooth'],[('DEF',3),('AP',-1)],['rough','bumpy'],0]
        horndict['smooth'] = ['*','*',['spiky','rough'],[('AP',3)],['smooth','sleek','polished'],0]

        jawdict = {}
        jawdict['long'] = ['*','*',['short','blunt'],[('AP',4),('ATK',4),('DEF',-4),('END',-4)],['long','lengthy','protracted','elongated'],2]
        jawdict['short'] = ['*','*',['long'],[('STR',4),('DEF',4),('ATK',-4),('AP',-4)],['short','stubby','stunted'],0]
        jawdict['muscular'] = ['*','*',[],[('STR',5),('ATK',5),('AP',-5),('DEF',-5)],['muscular','thickly-muscled'],3]
        jawdict['wide'] = ['*','*',['narrow'],[('ATK',5),('DEF',-5)],['wide','broad'],3]
        jawdict['narrow'] = ['*','*',['wide'],[('AGI',4),('AP',4),('STR',-4),('ATK',-4)],['narrow','slender'],-3]
        jawdict['blunt'] = ['*','*',['long','pointed'],[('END',4),('STR',4),('AGI',-4),('ATK',-4)],['blunt','compressed','squashed'],-3]
        jawdict['pointed'] = ['*','*',['blunt','unhinging'],[('AGI',5),('ATK',5),('DEF',-5),('END',-5)],['pointed','cuspate','tapered'],0]
        jawdict['unhinging'] = ['*','*',['pointed','grade_off','very_rare'],[('ATK',15),('AGI',8),('END',-8),('DEF',-15)],['unhinging','disengagable','uncoupleable'],0]
        jawdict['crooked'] = ['*','*',['unhinging','rare'],[('STR',3),('DEF',3),('END',3),('AGI',-3),('ATK',-3),('AP',-3)],['crooked','bent','angular','asymmetric'],0]
        jawdict['viselike'] = [['Carnivore','Omnivore'],'*',['grade_off'],[('STR',10),('ATK',10),('END',-5),('DEF',-5)],['viselike','powerful','clamp-like'],0]
        jawdict['large'] = ['*','*',['small','short'],[('AP',3),('AGI',-2)],['large','enormous','giant','huge'],3]
        jawdict['small'] = ['*','*',['large','long'],[('AGI',3),('AP',-2)],['small','tiny','miniature','petite'],-3]

        limbdict = {}
        limbdict['long'] = ['*','*',['short'],[('SPD',2),('AGI',1),('STR',-1),('DEF',-2)],['long','lengthy','protracted'],0]
        limbdict['short'] = ['*','*',['long'],[('DEF',2),('STR',1),('AGI',-1),('SPD',-2)],['short','stubby','stunted'],-5]
        limbdict['thick'] = ['*','*',['thin','lithe','scrawny'],[('END',2),('DEF',1),('SPD',-1),('AGI',-2)],['thick','heavy','dense','solid','meaty'],5]
        limbdict['thin'] = ['*','*',['thick','bulky','muscular'],[('AGI',2),('SPD',1),('DEF',-1),('END',-2)],['thin','light','flimsy','reedy'],-10]
        limbdict['many-jointed'] = ['*','*',['grade_off','stumpy','crooked','straight','flexible','rare'],[('AGI',8),('END',-4),('SPD',-4)],['multi-jointed','several-jointed','many-jointed'],0]
        limbdict['muscular'] = ['*','*',['lithe','scrawny','thin'],[('STR',2),('DEF',1),('AGI',-1),('END',-2)],['brawny','muscular','burly'],5]
        limbdict['lithe'] = ['*','*',['thick','bulky','scrawny'],[('SPD',3),('STR',-2),('DEF',-1)],['sinewy','lithe','supple'],-5]
        limbdict['bulky'] = ['*','*',['thin','lithe','flexible','scrawny','small'],[('STR',3),('END',-2),('AGI',-1)],['bulky','massive','hefty'],5]
        limbdict['stumpy'] = ['*','*',['thin','lithe','many-jointed','flexible','grade_off','scrawny'],[('DEF',10),('STR',6),('AGI',-10),('SPD',-6)],['stumpy','stocky','stout'],5]
        limbdict['crooked'] = ['*','*',['straight','many-jointed','rare'],[('DEF',3),('END',2),('AGI',-2),('SPD',-3)],['crooked','bent','angular','gnarly','asymmetric'],0]
        limbdict['straight'] = ['*','*',['crooked','many-jointed','flexible'],[('STR',3),('DEF',2),('AGI',-2),('ATK',-3)],['straight','inflexible','rigorous','unbending'],0]
        limbdict['flexible'] = ['*','*',['many-jointed','straight','bulky','stumpy'],[('AGI',4),('ATK',2),('DEF',-2),('END',-4)],['flexible','limber','bendable'],0]
        limbdict['large'] = ['*','*',['small','short','thin'],[('AP',3),('AGI',-2)],['large','enormous','giant','huge'],5]
        limbdict['small'] = ['*','*',['large','long','bulky'],[('AGI',3),('AP',-2)],['small','tiny','miniature','petite'],-5]
        limbdict['scrawny'] = ['*','*',['lithe','muscular','bulky','thick','stumpy'],[('END',4),('STR',-4)],['scrawny','gaunt','skinny'],-5]

        mouthdict = {}
        mouthdict['large'] = ['*','*',['small'],[('AP',3),('DEF',-1)],['large','enormous','giant','huge'],0]
        mouthdict['small'] = ['*','*',['large'],[('DEF',3),('AP',-1)],['small','tiny','miniature','petite'],0]
        mouthdict['wide'] = ['*','*',['narrow'],[('ATK',3),('DEF',-1)],['wide','broad'],0]
        mouthdict['narrow'] = ['*','*',['wide'],[('DEF',3),('ATK',-1)],['narrow','thin'],0]
        mouthdict['protruding'] = ['*','*',['recessed'],[('ATK',3),('DEF',-1)],['protruding','bulging','pouting'],0]
        mouthdict['recessed'] = ['*','*',['protruding'],[('DEF',3),('ATK',-1)],['recessed','concave','sunken'],0]
        mouthdict['grinning'] = ['*','*',['rare','frowning','grade_off'],[('AP',3),('DEF',-1)],['grinning','upturned'],0]
        mouthdict['frowning'] = ['*','*',['rare','grinning','grade_off'],[('DEF',3),('AP',-1)],['frowning'],0]
        mouthdict['cleft'] = ['*','*',['very_rare','grade_off'],[('AP',2)],['cleft'],0]

        nosedict = {}
        nosedict['long'] = ['*','*',['short','blunt'],[('AP',4),('DEF',-2)],['long','lengthy','protracted','tubular'],0]
        nosedict['short'] = ['*','*',['long'],[('DEF',4),('AP',-2)],['short','stubby','stunted'],-1]
        nosedict['narrow'] = ['*','*',['wide','bulky','stumpy','blunt'],[('DEF',2),('AP',-1)],['narrow','slender'],-2]
        nosedict['thick'] = ['*','*',['narrow','lithe'],[('DEF',2),('AP',-1)],['thick','heavy','solid'],2]
        nosedict['thin'] = ['*','*',['thick','bulky','stumpy','wide'],[('AP',2),('DEF',-1)],['thin','flimsy'],-1]
        nosedict['wide'] = ['*','*',['narrow','bulky','thin'],[('AP',2),('DEF',-1)],['wide','broad'],2]
        nosedict['bulky'] = ['*','*',['thin','narrow','lithe','small'],[('DEF',3)],['bulky','massive','hefty'],2]
        nosedict['blunt'] = ['*','*',['pointed','long','narrow'],[('DEF',3),('AP',-1)],['blunt','flat','squashed-looking'],0]
        nosedict['large'] = ['*','*',['small','short','thin'],[('AP',3),('DEF',-2)],['large','enormous','giant','huge'],2]
        nosedict['small'] = ['*','*',['large','long','bulky'],[('DEF',3),('AP',-2)],['small','tiny','miniature','petite'],-2]
        nosedict['pointed'] = ['*','*',['blunt','slitted'],[('AP',3)],['pointed','pointy','sharp-tipped'],0]
        nosedict['slitted'] = ['*','*',['pointed','grade_off'],[('AP',5),('DEF',5)],['slitted'],0]

        pawdict = {}
        pawdict['broad'] = ['*','*',['broad'],[('END',2),('STR',1),('DEF',-1),('AGI',-2)],['broad','wide','splayed-out'],0]
        pawdict['narrow'] = ['*','*',['bulky'],[('AGI',2),('DEF',1),('STR',-1),('END',-2)],['narrow','slender'],-5]
        pawdict['thick'] = ['*','*',[],[('END',2),('DEF',1),('SPD',-1),('AGI',-2)],['thick','heavy','dense','solid','meaty'],5]
        pawdict['muscular'] = ['*','*',[],[('STR',2),('DEF',1),('AGI',-1),('END',-2)],['brawny','muscular','burly'],5]
        pawdict['bulky'] = ['*','*',['narrow','flexible','small'],[('STR',3),('END',-2),('AGI',-1)],['bulky','massive','hefty'],5]
        pawdict['stumpy'] = ['*','*',['flexible','grade_off','prehensile'],[('DEF',10),('STR',6),('AGI',-10),('SPD',-6)],['stumpy','stocky','stout'],5]
        pawdict['flexible'] = ['*','*',['bulky','stumpy'],[('AGI',4),('ATK',2),('DEF',-2),('END',-4)],['flexible','limber','bendable'],0]
        pawdict['padded'] = ['*','*',[],[('DEF',3),('END',2),('ATK',-2),('AGI',-3)],['padded','calloused','thickly-padded'],2]
        pawdict['large'] = ['*','*',['small'],[('AP',3),('AGI',-2)],['large','enormous','giant','huge'],3]
        pawdict['small'] = ['*','*',['large','bulky'],[('AGI',3),('AP',-2)],['small','tiny','miniature','petite'],-3]
        pawdict['prehensile'] = ['*','*',['ultra_rare','grade_off','stumpy'],[('AP',10)],['prehensile'],0]

        pincdict = {}
        pincdict['long'] = ['*','*',['short','blunt'],[('ATK',5),('AGI',-2)],['long','lengthy','protracted'],2]
        pincdict['short'] = ['*','*',['long'],[('ATK',3),('AGI',-1)],['short','stubby'],0]
        pincdict['thick'] = ['*','*',['thin'],[('ATK',3),('AGI',-1)],['thick','dense'],2]
        pincdict['thin'] = ['*','*',['thick'],[('ATK',2)],['thin','narrow','slender'],0]
        pincdict['blunt'] = ['*','*',['sharp','long'],[('AP',3),('ATK',-2)],['blunt','dull'],0]
        pincdict['sharp'] = ['*','*',['blunt'],[('ATK',3),('AP',-1)],['sharp','pointy','blade-like'],0]
        pincdict['spiky'] = ['*','*',['smooth'],[('ATK',3),('AP',-2)],['spiky','spiny'],0]
        pincdict['smooth'] = ['*','*',['spiky','serrated'],[('AP',3),('ATK',-2)],['smooth','sleek','polished'],0]
        pincdict['serrated'] = ['*','*',['smooth','rare'],[('ATK',4),('AP',-2)],['serrated','jagged','sawlike'],0]
        pincdict['prehensile'] = ['*','*',['ultra_rare','grade_off'],[('AP',10)],['prehensile'],0]

        probdict = {}
        probdict['long'] = ['*','*',['short'],[('AGI',3),('ATK',3),('DEF',-3),('END',-3)],['long','lengthy','protracted','tubular'],0]
        probdict['short'] = ['*','*',['long'],[('STR',3),('DEF',3),('AGI',-3),('ATK',-3)],['short','stubby','stunted'],-1]
        probdict['narrow'] = ['*','*',['wide','bulky','stumpy'],[('AGI',5),('AP',5),('ATK',-3),('STR',-5)],['narrow','slender'],-2]
        probdict['thick'] = ['*','*',['narrow','lithe'],[('END',3),('DEF',3),('AGI',-3),('AP',-3)],['thick','heavy','dense','solid'],2]
        probdict['thin'] = ['*','*',['thick','bulky','stumpy'],[('AGI',3),('DEF',-1),('END',-2)],['thin','light','flimsy','reedy'],-1]
        probdict['wide'] = ['*','*',['narrow','bulky'],[('END',4),('ATK',4),('DEF',-4),('AGI',-4)],['wide','broad'],2]
        probdict['flexible'] = ['*','*',['bulky','stumpy'],[('AGI',4),('AP',4),('DEF',-4),('END',-4)],['flexible','limber','bendable'],0]
        probdict['bulky'] = ['*','*',['thin','narrow','lithe','small'],[('STR',3),('END',-2),('AGI',-1)],['bulky','massive','hefty'],2]
        probdict['stumpy'] = ['*','*',['thin','narrow','lithe','grade_off'],[('DEF',3),('STR',2),('AGI',-3),('SPD',-2)],['stumpy','stocky','stout'],2]
        probdict['muscular'] = ['*','*',['lithe'],[('STR',4),('AP',2),('AGI',-1),('END',-2)],['muscular','strong'],2]
        probdict['lithe'] = ['*','*',['thick','bulky','stumpy','muscular'],[('AP',3),('SPD',3),('STR',-2),('DEF',-1)],['sinewy','lithe','supple'],-2]
        probdict['spike-tipped'] = ['*','*',['sting-tipped','grade_off','very_rare'],[('ATK',10)],['spike-tipped','blade-tipped','claw-tipped'],2]
        probdict['sting-tipped'] = ['*','*',['spike-tipped','grade_off','very_rare'],[('ATK',6)],['sting-tipped','stinger-tipped'],2]
        probdict['large'] = ['*','*',['small','short','thin'],[('AP',3),('AGI',-2)],['large','enormous','giant','huge'],2]
        probdict['small'] = ['*','*',['large','long','bulky'],[('AGI',3),('AP',-2)],['small','tiny','miniature','petite'],-2]

        scaledict = {}
        scaledict['ridged'] = ['*','*',['smooth','bumpy','grade_off'],[('AC',10)],['ridged','ribbed','furrowed'],0]
        scaledict['smooth'] = ['*','*',['ridged','bumpy','grade_off'],[('AGI',5),('AP',5)],['smooth','sleek','flat'],0]
        scaledict['bumpy'] = ['*','*',['ridged','smooth','grade_off'],[('AC',5),('AGI',5)],['bumpy','knobby','lumpy'],0]
        scaledict['diamond-shaped'] = ['*','*',['round','grade_off'],[('AC',10)],['diamond-shaped'],0]
        scaledict['round'] = ['*','*',['diamond-shaped','grade_off'],[('AC',5),('AP',5)],['round','circular','oval'],0]
        scaledict['hard'] = ['*','*',['soft'],[('AC',3),('AP',-1)],['hard','stiff','rigid','inflexible'],0]
        scaledict['soft'] = ['*','*',['hard'],[('AP',3),('AC',-1)],['soft','flexible','pliable'],0]
        scaledict['shiny'] = ['*','*',['dull'],[('DEF',3)],['shiny','gleaming','glossy','polished'],0]
        scaledict['dull'] = ['*','*',['shiny'],[('AP',3)],['dull','opaque'],0]
        scaledict['large'] = ['*','*',['small'],[('DEF',3)],['large','big','huge'],0]
        scaledict['small'] = ['*','*',['large'],[('AP',3)],['small','tiny','miniature'],0]

        segdict = {}
        segdict['long'] = ['*','*',['short','small'],[('END',3),('DEF',-3)],['long','lengthy','protracted','elongated'],5]
        segdict['short'] = ['*','*',['long','large'],[('DEF',3),('END',-3)],['short','stubby','stunted','stocky'],-5]
        segdict['thin'] = ['*','*',['thick','bulbous','bulky'],[('AGI',3),('STR',-3)],['thin','narrow','slender'],-5]
        segdict['thick'] = ['*','*',['thin','small'],[('STR',3),('AGI',-3)],['thick','broad','wide'],5]
        segdict['bulbous'] = ['*','*',['very_rare','thin','squarish','tubelike','small'],[('STR',3),('DEF',-3)],['bulbous','bulging','bloated'],5]
        segdict['squarish'] = ['*','*',['bulbous','very_rare','tubelike'],[('END',2)],['squarish','blockish'],0]
        segdict['large'] = ['*','*',['short','small','tubelike'],[('STR',4)],['large','enormous','big','huge'],10]
        segdict['small'] = ['*','*',['long','large','bulky','bulbous','thick'],[('AGI',4)],['small','tiny','miniature','petite'],-10]
        segdict['bulky'] = ['*','*',['thin','small','tubelike','very_rare'],[('STR',3),('END',-2),('AGI',-1)],['bulky','awkward'],5]
        segdict['tubelike'] = ['*','*',['bulky','large','squarish','bulbous','grade_off','very_rare'],[('SPD',2),('AGI',2),('DEF',-3)],['tubelike','snakelike','hoselike'],0]
        segdict['sleek'] = ['*','*',['bulky','squarish','bulbous','bulky'],[('SPD',3),('AP',2),('DEF',-2),('HP',-3)],['sleek','delicate','aquiline'],-5]

        shelldict = {}
        shelldict['convex'] = ['*','*',['concave'],[('AC',10),('DEF',10),('AGI',-6),('SPD',-6)],['arched','towering','domed','convex'],10]
        shelldict['concave'] = ['*','*',['convex','spired'],[('AC',6),('DEF',6),('AGI',-4),('SPD',-4)],['concave','dimpled'],5]
        shelldict['thick'] = ['*','*',['thin'],[('AC',15),('DEF',5),('AGI',-5),('ATK',-15)],['thick','heavy','dense','solid'],15]
        shelldict['thin'] = ['*','*',['thick'],[('DEF',4),('AC',4),('AGI',-2),('ATK',-2)],['thin','light','delicate'],0]
        shelldict['spired'] = ['*','*',['plated','concave','grade_off','rare'],[('AC',6),('AGI',-3)],['spired','coiled','winding'],5]
        shelldict['plated'] = ['*','*',['spired','grade_off'],[('AC',15),('AGI',-3),('SPD',-2)],['plated','overlayed','interlocking'],5]
        shelldict['spiky'] = ['*','*',['smooth','ridged'],[('AC',10),('ATK',5),('AGI',-5),('AP',-5)],['spiky','barbed','spiny'],5]
        shelldict['smooth'] = ['*','*',['spiky','ridged'],[('AC',8),('DEF',4),('AGI',-3),('AP',-3)],['smooth','glossy','polished','glassy'],0]
        shelldict['ridged'] = ['*','*',['spiky','smooth'],[('DEF',4),('AC',4),('AGI',-2),('AP',-2)],['ridged','striated','furrowed'],0]
        shelldict['large'] = ['*','*',['small'],[('AC',5),('AGI',-3)],['large','enormous','giant','huge'],5]
        shelldict['small'] = ['*','*',['large'],[('AC',3),('AGI',-1)],['small','tiny','miniature','petite'],0]

        skindict = {}
        skindict['thick'] = ['*','*',['thin'],[('AC',2),('DEF',3),('END',2),('AGI',-2),('SPD',-3)],['thick','tough','dense','solid'],5]
        skindict['thin'] = ['*','*',['thick'],[('SPD',4),('AGI',2),('END',-2),('DEF',-3),('AC',-2)],['thin','light','flimsy'],-5]
        skindict['translucent'] = ['*','*',['transparent','rare'],[('AP',3),('DEF',-1)],['translucent','diaphanous','membranous'],-5]
        skindict['transparent'] = ['*','*',['translucent','ultra_rare'],[('AP',5),('DEF',-3)],['transparent','see-through','membranous'],-5]
        skindict['smooth'] = ['*','*',['rough'],[('AGI',3),('AC',-1)],['smooth','sleek','unblemished'],0]
        skindict['rough'] = ['*','*',['smooth'],[('AC',3),('AGI',-1)],['rough','bumpy','blemished'],0]
        skindict['hard'] = ['*','*',['soft','baggy'],[('AC',3),('AGI',-1)],['hard','tough','inflexible','stiff'],5]
        skindict['soft'] = ['*','*',['hard'],[('AGI',3),('AC',-1)],['soft','flexible','pliable'],0]
        skindict['baggy'] = ['*','*',['firm','hard'],[('END',3),('AP',-1)],['baggy','droopy','loose','sagging'],5]
        skindict['firm'] = ['*','*',['baggy'],[('AP',3),('END',-1)],['firm','elastic','taut'],0]

        stingdict = {}
        stingdict['long'] = ['*','*',['short','blunt'],[('ATK',5),('AGI',-2)],['long','lengthy','protracted'],2]
        stingdict['short'] = ['*','*',['long'],[('ATK',3),('AGI',-1)],['short','stubby'],0]
        stingdict['thick'] = ['*','*',['thin'],[('ATK',3),('AGI',-1)],['thick','dense'],2]
        stingdict['thin'] = ['*','*',['thick'],[('ATK',2)],['thin','narrow','slender'],0]
        stingdict['curved'] = ['*','*',['straight'],[('ATK',3),('AGI',-1)],['curved','bowed','curled','hooked'],0]
        stingdict['straight'] = ['*','*',['curved'],[('ATK',2)],['straight'],0]
        stingdict['retracting'] = ['*','*',['grade_off','rare'],[('AP',10),('AGI',10)],['retracting'],0]
        stingdict['blunt'] = ['*','*',['sharp','barbed','long'],[('DEF',3),('ATK',-2)],['blunt','dull'],0]
        stingdict['sharp'] = ['*','*',['blunt'],[('ATK',3),('AP',-1)],['sharp','pointy','blade-like'],0]
        stingdict['barbed'] = ['*','*',['blunt','grade_off','rare'],[('ATK',10),('DEF',-5)],['barbed'],0]

        taildict = {}
        taildict['long'] = ['*','*',['short','stumpy','small'],[('AGI',4)],['long','lengthy','protracted'],5]
        taildict['short'] = ['*','*',['long','large'],[('AP',6)],['short','stubby','stunted'],-5]
        taildict['thick'] = ['*','*',['thin','lithe'],[('AP',4),('DEF',1),('SPD',-1),('AGI',-2)],['thick','heavy','dense','solid','meaty'],5]
        taildict['thin'] = ['*','*',['thick','large'],[('AGI',4),('SPD',1),('DEF',-1),('AP',-2)],['thin','light','flimsy','reedy'],-10]
        taildict['spike-tipped'] = ['*','*',['sting-tipped','tufted','grade_off','very_rare'],[('ATK',10)],['spike-tipped','blade-tipped','claw-tipped'],5]
        taildict['sting-tipped'] = ['*','*',['spike-tipped','tufted','grade_off','very_rare'],[('ATK',6)],['sting-tipped','stinger-tipped'],5]
        taildict['flexible'] = ['*','*',['stumpy'],[('AGI',4),('AP',4)],['flexible','limber','bendable'],0]
        taildict['stumpy'] = ['*','*',['long','flexible','lithe','many-jointed','prehensile'],[('END',2),('DEF',4)],['stumpy','stocky','stout'],2]
        taildict['tufted'] = ['*','*',['sting-tipped','spike-tipped','grade_off'],[('AGI',2),('DEF',2)],['tufted'],2]
        taildict['muscular'] = ['*','*',['lithe'],[('STR',2),('AP',4),('AGI',-1),('END',-2)],['brawny','muscular','burly'],5]
        taildict['lithe'] = ['*','*',['thick','bulky','muscular'],[('SPD',3),('STR',-2),('DEF',-1)],['sinewy','lithe','supple'],-5]
        taildict['many-jointed'] = ['*','*',['grade_off','stumpy','flexible','rare'],[('AP',8),('AGI',4),('END',-2),('SPD',-2)],['multi-jointed','several-jointed','many-jointed'],0]
        taildict['large'] = ['*','*',['small','short','thin'],[('AP',2),('AGI',-3)],['large','enormous','giant','huge'],5]
        taildict['small'] = ['*','*',['large','long'],[('AGI',3),('AP',-2)],['small','tiny','miniature','petite'],-5]
        taildict['prehensile'] = ['*','*',['ultra_rare','grade_off','stumpy'],[('AP',10)],['prehensile'],0]

        tentdict = {}
        tentdict['long'] = ['*','*',['short','small'],[('SPD',2),('AGI',1),('STR',-1),('DEF',-2)],['long','lengthy','protracted'],0]
        tentdict['short'] = ['*','*',['long','large'],[('DEF',2),('STR',1),('AGI',-1),('SPD',-2)],['short','stubby'],-5]
        tentdict['thick'] = ['*','*',['thin','lithe'],[('END',2),('DEF',1),('SPD',-1),('AGI',-2)],['thick','heavy','dense','solid','meaty'],5]
        tentdict['thin'] = ['*','*',['thick','bulky','large'],[('AGI',2),('SPD',1),('DEF',-1),('END',-2)],['thin','light','flimsy','reedy'],-10]
        tentdict['muscular'] = ['*','*',['lithe'],[('STR',2),('DEF',1),('AGI',-1),('END',-2)],['brawny','muscular','burly'],5]
        tentdict['lithe'] = ['*','*',['thick','bulky','muscular'],[('SPD',3),('STR',-2),('DEF',-1)],['sinewy','lithe','supple'],-5]
        tentdict['bulky'] = ['*','*',['thin','lithe','small'],[('STR',3),('END',-2),('AGI',-1)],['bulky','massive','hefty'],5]
        tentdict['stumpy'] = ['*','*',['thin','lithe','grade_off'],[('DEF',3),('STR',2),('AGI',-3),('SPD',-2)],['stumpy','stocky','stout'],5]
        tentdict['sucker-covered'] = ['*','*',['grade_off'],[('AGI',8),('SPD',-4)],['sucker-covered'],1]
        tentdict['tendril-covered'] = ['*','*',['grade_off','rare'],[('AGI',6),('SPD',-3)],['tendril-covered'],1]
        tentdict['clawed'] = ['*',['Terrestrial','Subterranean','Amphibian'],['grade_off','very_rare'],[('ATK',10),('AGI',-2)],['clawed','spurred'],1]
        tentdict['taloned'] = ['*',['Aerial'],['grade_off'],[('ATK',10),('AGI',-2)],['taloned','very_rare'],1]        
        tentdict['large'] = ['*','*',['small','short','thin'],[('STR',3),('AGI',-2)],['large','enormous','giant','huge'],5]
        tentdict['small'] = ['*','*',['large','long','bulky'],[('AGI',3),('STR',-2)],['small','tiny','miniature','petite'],-5]
        tentdict['prehensile'] = ['*','*',['ultra_rare','grade_off'],[('AP',10)],['prehensile'],0]

        tonguedict = {}
        tonguedict['long'] = ['*','*',['short'],[('AP',3)],['long','lengthy','elongated','protracted'],0]
        tonguedict['short'] = ['*','*',['long'],[('AP',2)],['short','stubby'],0]
        tonguedict['muscular'] = ['*','*',[],[('STR',2),('AP',2)],['muscular','strong'],0]
        tonguedict['thick'] = ['*','*',['thin'],[('AP',2)],['thick','meaty'],0]
        tonguedict['thin'] = ['*','*',['thick'],[('AP',3)],['thin','slender','worm-like'],0]
        tonguedict['rough'] = ['*','*',['smooth'],[('DEF',2)],['rough','bumpy','coarse'],0]
        tonguedict['smooth'] = ['*','*',['rough'],[('AP',2)],['smooth','velvety','soft'],0]
        tonguedict['forked'] = ['*','*',['very_rare','grade_off'],[('AP',6)],['forked'],0]
        tonguedict['prehensile'] = ['*','*',['ultra_rare','grade_off'],[('AP',10)],['prehensile'],0]

        toothdict = {}
        toothdict['long'] = ['*','*',['short'],[('ATK',3)],['long','lengthy','elongated'],0]
        toothdict['short'] = ['*','*',['long'],[('DEF',3)],['short','stubby'],0]
        toothdict['sharp'] = ['*','*',['blunt'],[('ATK',4)],['sharp','blade-like','pointed'],0]
        toothdict['curved'] = [['Carnivore','Omnivore','Other'],'*',['blunt','squarish','chisel-like'],[('ATK',4)],['curved','hooked','arched'],0]
        toothdict['blunt'] = [['Herbivore','Omnivore','Other'],'*',['curved','sharp','serrated','chisel-like'],[('DEF',4)],['blunt','dull','flat'],0]
        toothdict['serrated'] = [['Carnivore','Omnivore','Other'],'*',['blunt','chisel-like'],[('ATK',5)],['serrated','jagged','sawlike'],0]
        toothdict['squarish'] = ['*','*',['curved','chisel-like'],[('DEF',3),('END',2)],['squarish','boxy'],0]
        toothdict['chisel-like'] = [['Herbivore','Omnivore','Other'],'*',['serrated','blunt','squarish','curved','grade_off'],[('DEF',8),('ATK',2)],['chisel-like'],0]
        toothdict['large'] = ['*','*',['short','small'],[('ATK',4)],['large','enormous','giant','huge'],2]
        toothdict['small'] = ['*','*',['long','large'],[('DEF',4)],['small','tiny','miniature','petite'],-1]

        torsodict = {}
        torsodict['long'] = ['*','*',['short','small'],[('END',3),('DEF',-3)],['long','lengthy','protracted','elongated'],5]
        torsodict['short'] = ['*','*',['long','large'],[('DEF',3),('END',-3)],['short','stubby','stunted','stocky'],-5]
        torsodict['thin'] = ['*','*',['thick','bulbous','stumpy','bulky'],[('AGI',3),('STR',-3)],['thin','narrow','slender'],-5]
        torsodict['thick'] = ['*','*',['thin','scrawny','lithe'],[('STR',3),('AGI',-3)],['thick','broad','wide'],5]
        torsodict['muscular'] = ['*','*',['lithe','scrawny'],[('STR',4),('END',-2)],['muscular','brawny','bulky'],5]
        torsodict['scrawny'] = ['*','*',['lithe','muscular','bulbous','stumpy','bulky','thick'],[('END',4),('STR',-4)],['scrawny','gaunt','skinny'],-5]
        torsodict['lithe'] = ['*','*',['muscular','scrawny','bulbous','squarish','stumpy','bulky','thick'],[('AGI',4),('STR',-2)],['lithe','supple','lean'],0]
        torsodict['bulbous'] = ['*','*',['small','very_rare','scrawny','thin','lithe','squarish','tubelike'],[('STR',3),('DEF',-3)],['bulbous','bulging','bloated'],5]
        torsodict['squarish'] = ['*','*',['bulbous','lithe','tubelike'],[('END',2)],['squarish','blockish'],0]
        torsodict['large'] = ['*','*',['short','small','tubelike'],[('STR',4)],['large','enormous','big','huge'],10]
        torsodict['small'] = ['*','*',['bulbous','long','large','bulky'],[('AGI',4)],['small','tiny','miniature','petite'],-10]
        torsodict['bulky'] = ['*','*',['thin','lithe','small','scrawny','tubelike'],[('STR',3),('END',-2),('AGI',-1)],['bulky','awkward'],5]
        torsodict['stumpy'] = ['*','*',['thin','lithe','grade_off','scrawny','tubelike'],[('DEF',3),('STR',2),('AGI',-3),('SPD',-2)],['stumpy'],5]
        torsodict['tubelike'] = ['*','*',['bulky','large','squarish','bulbous','stumpy','grade_off'],[('SPD',2),('AGI',2),('DEF',-3)],['tubelike','snakelike','hoselike'],0]

        trunkdict = {}
        trunkdict['long'] = ['*','*',['short'],[('AGI',3),('ATK',3),('DEF',-3),('END',-3)],['long','lengthy','protracted','tubular'],0]
        trunkdict['short'] = ['*','*',['long'],[('STR',3),('DEF',3),('AGI',-3),('ATK',-3)],['short','stubby','stunted'],-1]
        trunkdict['narrow'] = ['*','*',['wide','bulky','stumpy'],[('AGI',5),('AP',5),('ATK',-3),('STR',-5)],['narrow','slender'],-2]
        trunkdict['thick'] = ['*','*',['narrow','lithe'],[('END',3),('DEF',3),('AGI',-3),('AP',-3)],['thick','heavy','dense','solid'],2]
        trunkdict['thin'] = ['*','*',['thick','bulky','stumpy'],[('AGI',3),('DEF',-1),('END',-2)],['thin','light','flimsy','reedy'],-1]
        trunkdict['wide'] = ['*','*',['narrow','bulky'],[('END',4),('ATK',4),('DEF',-4),('AGI',-4)],['wide','broad'],2]
        trunkdict['flexible'] = ['*','*',['bulky','stumpy'],[('AGI',4),('AP',4),('DEF',-4),('END',-4)],['flexible','limber','bendable'],0]
        trunkdict['bulky'] = ['*','*',['thin','narrow','lithe'],[('STR',3),('END',-2),('AGI',-1)],['bulky','massive','hefty'],5]
        trunkdict['stumpy'] = ['*','*',['thin','narrow','lithe','grade_off','prehensile'],[('DEF',3),('STR',2),('AGI',-3),('SPD',-2)],['stumpy','stocky','stout'],5]
        trunkdict['muscular'] = ['*','*',['lithe'],[('STR',4),('AP',2),('AGI',-1),('END',-2)],['muscular','strong'],5]
        trunkdict['lithe'] = ['*','*',['thick','bulky','stumpy','muscular'],[('AP',3),('SPD',3),('STR',-2),('DEF',-1)],['sinewy','lithe','supple'],-5]
        trunkdict['spike-tipped'] = ['*','*',['sting-tipped','grade_off','very_rare'],[('ATK',10)],['spike-tipped','blade-tipped','claw-tipped'],5]
        trunkdict['sting-tipped'] = ['*','*',['spike-tipped','grade_off','very_rare'],[('ATK',6)],['sting-tipped','stinger-tipped'],5]
        trunkdict['prehensile'] = ['*','*',['ultra_rare','grade_off','stumpy'],[('AP',10)],['prehensile'],0]

        wingdict = {}
        wingdict['short'] = ['*','*',['long','large'],[('AGI',4),('SPD',-3),('END',-1)],['short','stubby','stunted'],-5]
        wingdict['broad'] = ['*','*',['narrow'],[('END',2),('STR',2),('SPD',-2),('AGI',-2)],['broad','wide'],5]
        wingdict['long'] = ['*','*',['short'],[('AGI',2),('SPD',2),('DEF',-2),('STR',-2)],['long','lengthy','protracted'],5]
        wingdict['narrow'] = ['*','*',['broad'],[('AGI',3),('END',-3)],['narrow','slender'],-5]
        wingdict['triangular'] = ['*','*',['arched'],[('AGI',3),('AP',6),('STR',-6)],['triangular','pyriform','cuneate'],-2]
        wingdict['large'] = ['*','*',['short','small'],[('STR',4),('END',4),('SPD',-6),('AGI',-2)],['large','expansive','giant','voluminous'],10]
        wingdict['small'] = ['*','*',['large','long'],[('SPD',6),('AGI',2),('STR',-3),('END',-3)],['small','tiny','miniature','petite'],-5]
        wingdict['arched'] = ['*','*',['triangular'],[('STR',6),('AGI',-3),('SPD',-3)],['arched','vaulted','curved','bowed'],0]
        wingdict['pointed'] = ['*','*',[],[('END',5),('AGI',2),('SPD',-2),('DEF',-5)],['pointed','acute','cuspate'],0]
        wingdict['flat'] = ['*','*',[],[('END',4),('STR',2),('DEF',-2),('SPD',-4)],['flat','planar','level','smooth'],-2]
        wingdict['slotted'] = ['*','*',[],[('STR',3),('END',2),('ATK',-2),('SPD',-3)],['grooved','slotted','ridged','striated'],-2]
        wingdict['back-swept'] = ['*','*',['grade_off'],[('AP',15),('SPD',5),('ATK',5),('DEF',-5),('END',-5),('STR',-5)],['back-swept'],0]        

        bodydict = {}

        # Body
        bodydict['hips'] = hipdict
        bodydict['head'] = segdict
        bodydict['torso'] = torsodict
        bodydict['thorax'] = segdict
        bodydict['cephalothorax'] = segdict
        bodydict['abdomen'] = segdict
        bodydict['body'] = segdict

        # Body Covering
        bodydict['exoskeleton'] = exodict
        bodydict['feathers'] = feathdict
        bodydict['fur'] = furdict
        bodydict['scales'] = scaledict
        bodydict['skin'] = skindict
        bodydict['shell'] = shelldict

        # Arms & Hands
        bodydict['arms'] = limbdict
        bodydict['hands'] = handdict

        # Legs
        bodydict['midlegs'] = limbdict
        bodydict['frontlegs'] = limbdict
        bodydict['backlegs'] = limbdict

        # Extremities
        bodydict['claws'] = clawdict
        bodydict['digits'] = digitdict
        bodydict['paws'] = pawdict
        bodydict['hooves'] = hoofdict
        bodydict['feet'] = pawdict
        bodydict['pincers'] = pincdict
        bodydict['sting'] = stingdict
        bodydict['tailsting'] = stingdict
        bodydict['tailspike'] = clawdict
        bodydict['probsting'] = stingdict
        bodydict['probspike'] = clawdict
        bodydict['trunksting'] = stingdict
        bodydict['trunkspike'] = clawdict

        # Other Limb Types
        bodydict['fins'] = findict
        bodydict['tentacles'] = tentdict
        bodydict['wings'] = wingdict
        bodydict['tails'] = taildict

        # Head
        bodydict['feelers'] = tentdict
        bodydict['whiskers'] = furdict
        bodydict['horns'] = horndict
        bodydict['jaw'] = jawdict
        bodydict['mouth'] = mouthdict
        bodydict['nose'] = nosedict
        bodydict['headpincers'] = pincdict
        bodydict['proboscis'] = probdict
        bodydict['tongue'] = tonguedict
        bodydict['teeth'] = toothdict
        bodydict['trunk'] = trunkdict
        bodydict['eyes'] = eyedict
        bodydict['ears'] = eardict
        bodydict['antennae'] = antdict
        bodydict['beak'] = beakdict
        bodydict['gills'] = gilldict

# Structure: [Spheres,Predations,Limbs,Traits,Skill Bonuses] (skill bonuses to be added later)

# Plan: Make up lots of these and assign them to lists of body part/trait combinations. Each creature will pick functions according to
# which traits and parts it possesses. Thus - morphological functions!

        functiondict = {}
        functiondict['grasping its prey'] = ['*',['Omnivore','Carnivore'],['hands','paws','tentacles','pincers','tails'],['muscular','broad','thick','bulky','flexible','large','many-jointed']]
        functiondict['striking its prey'] = ['*',['Omnivore','Carnivore'],['paws','tails'],['muscular','thick','bulky','broad','large','many-jointed','spike-tipped','sting-tipped']]
##        functiondict['grasping climbable surfaces'] = ['*','*',['paws','tails','hands','tentacles',
##        'digging'
##        'cracking shells and bones'
##        'rending flesh'
##        'cracking shells and bones'
##        'manipulating and constructing webs'
##        'maintaining its balance'
##        'pouncing on its prey'
##        'reaching for vegetatation'
##        'cracking open nuts or husking fruit'
##        'climbing'
##        'digging'
##        'defense'
##        'performing complex mating displays'
##        'frightening away predators'
##        'sprinting'
##        'sustained running'
##        'climbing'
##        'jumping over long distances'
##        'maintaining its balance'
##        'slow and careful movement'
##        'speedy hopping'
##        'oddly efficient waddling movement'
##        'awkward waddling movement'
##        'maintaining careful balance'
##        'using a slow, creeping pace'

        sizedict = {}
        sizedict['gigantic'] = [['gigantic','monolithic','vast','monstrous','colossal'],['gigantically','monolithically','vastly','monstrously'],2000,50001,6]
        sizedict['huge'] = [['huge','enormous','massive','humongous'],['hugely','enormously','massively','humongously'],500,2000,5]
        sizedict['large'] = [['large','considerable','great','substantial','prodigious','respectable'],['large','considerably','substantially','prodigiously','great'],100,500,4]
        sizedict['decent'] = [['decent','modest','medium','fair','moderate'],['decently','modestly','medium','fair','moderately'],50,100,3]
        sizedict['small'] = [['small','diminutive'],['dimutively','small'],10,50,2]
        sizedict['tiny'] = [['tiny','miniature','miniscule'],['tiny','miniature','miniscule'],1,10,1]


        count = 0

        for creaturenum in range(1,1001):
            creature = {}
            creature['traits'] = {}
            creaturename = MakeName(PLang)
            creature['name'] = creaturename
            ctitles = ['this creature','the %s' % creaturename.capitalize(),'this animal','this beast']
            predation = wchoice([('Carnivore',.30),('Herbivore',.30),('Omnivore',.30),('Other',.10)])
            creature['predation'] = predation
            sphere = wchoice([('Terrestrial',.40),('Aquatic',.25),('Aerial',.15),('Amphibian',.10),('Subterranean',.10)])

            # Biome Diversification

            tempzone = wchoice([('Temperate',.4),('Arctic',.3),('Tropical',.3)])
            biomedict = {}
            biomedict['Terrestrial'] = [('Temperate',['Deciduous Forest','Shrubland','Desert','Cacti Forest','Heathland','Broadleaf Forest', \
                                                      'Mixed Forest','Coniferous Forest','Evergreen Forest','Cave','Swamp', 'Plain', \
                                                      'Highland','Mountain','Marshland']), \
                                        ('Arctic',['Coniferous Forest','Evergreen Forest','Cave','Desert','Tundra','Highland','Mountain','Glacier']), \
                                        ('Tropical',['Tropical Forest','Shrubland','Desert','Cacti Forest','Heathland','Cave','Swamp', \
                                                     'Savannah','Highland','Mountain','Deciduous Forest','Broadleaf Forest','Marshland'])]

            biomedict['Amphibian'] = [('Temperate',['River Bank','Pond','Swamp','Beach','Lakeshore','Marshland']), \
                                      ('Arctic',['River Bank','Beach','Lakeshore']), \
                                      ('Tropical',['River Bank','Pond','Swamp','Beach','Lakeshore','Marshland'])]

            biomedict['Aquatic'] = [('Temperate',['River','Pond','Swamp','Ocean','Lake','Marshland']), \
                                    ('Arctic',['River','Ocean','Lake']), \
                                    ('Tropical',['River','Pond','Swamp','Ocean','Lake','Marshland'])]

            biomedict['Aerial'] = [('Temperate',['Deciduous Forest','Shrubland','Desert','Cacti Forest','Heathland','Broadleaf Forest', \
                                                 'Mixed Forest','Coniferous Forest','Evergreen Forest','Tropical Forest','Swamp', \
                                                 'Plain','Highland','Mountain','Marshland']), \
                                   ('Arctic',['Coniferous Forest','Evergreen Forest','Tundra','Desert','Highland','Mountain']), \
                                   ('Tropical',['Tropical Forest','Shrubland','Desert','Cacti Forest','Heathland','Cave','Swamp', \
                                                'Savannah','Highland','Mountain','Marshland'])]
            biomedict['Subterranean'] = [('Temperate',['Deciduous Forest','Shrubland','Desert','Cacti Forest','Heathland','Broadleaf Forest', \
                                                       'Mixed Forest','Coniferous Forest','Evergreen Forest','Cave','Swamp','Plain', \
                                                       'Highland','Mountain','Marshland']), \
                                         ('Arctic',['Coniferous Forest','Evergreen Forest','Cave','Desert','Tundra','Highland','Mountain','Glacier']), \
                                         ('Tropical',['Tropical Forest','Shrubland','Desert','Cacti Forest','Heathland','Cave','Swamp', \
                                                      'Savannah','Highland','Mountain','Deciduous Forest','Broadleaf Forest','Marshland'])]

            biomes = wchoice([(1,.9),(2,.06),(3,.03),(4,.01)])
            biomelist = []
            
            for biome in range(biomes):
                try:
                    biomelist.append(choice(filter(lambda x: x not in biomelist,filter(lambda x: x[0] == tempzone,biomedict[sphere])[0][1])))
                except IndexError:
                    break
            creature['biomes'] = biomelist
            creature['tempzone'] = tempzone
            creature['sphere'] = sphere
            vertebrate = choice([True,False])
            creature['vertebrate'] = vertebrate

            # Creature Behavioral Choices

            # (Aggression)
            if predation in ['Herbivore','Other']:
                belligerence = wchoice([(randrange(1,4),.3),(randrange(4,7),.6),(randrange(7,11),.1)])
            elif predation == 'Omnivore':
                belligerence = wchoice([(randrange(1,4),.3),(randrange(4,7),.4),(randrange(7,11),.3)])
            else:
                belligerence = wchoice([(randrange(1,4),.1),(randrange(4,7),.4),(randrange(7,11),.5)])
            if predation in ['Carnivore']:
                belligerence = max(belligerence,3)
            creature['belligerence'] = belligerence

            # (Territoriality)
            if creature['predation'] in ['Herbivore','Other']:
                territoriality = wchoice([(randrange(1,3),.3),(randrange(3,4),.6),(randrange(4,7),.1)])
            elif creature['predation'] == 'Omnivore':
                territoriality = wchoice([(randrange(1,3),.3),(randrange(3,4),.4),(randrange(4,7),.3)])
            else:
                territoriality = wchoice([(randrange(1,3),.1),(randrange(3,4),.4),(randrange(4,7),.5)])
            creature['territoriality'] = territoriality
            if predation in ['Carnivore']:
                territoriality = max(territoriality,3)
            # ...(and modify territoriality depending on aggression.)
            belmod = belligerence / 2
            territoriality = min(territoriality + belmod,10)

            # Creature Statistics

            skew = randrange(-3,4)

            num1 = randrange(4,11)
            num2 = randrange(4,11)
            num3 = randrange(4,11)

            numlist = [num1,num2,num3]
            random.shuffle(numlist)

            creature['STR'] = numlist[0] + skew
            creature['END'] = numlist[1] + skew
            creature['AGI'] = numlist[2] + skew

            num1 = randrange(4,11)
            num2 = randrange(4,11)
            num3 = randrange(4,11)

            numlist = [num1,num2,num3]
            random.shuffle(numlist)

            creature['WIL'] = numlist[0] - skew
            creature['INT'] = numlist[1] - skew
            creature['WIT'] = numlist[2] - skew

            # General Morphological Diversification

            if not vertebrate:
                hasexoskeleton = choice([True,False])
                heads = wchoice([(0,.02),(1,.97),(randrange(2,21),.01)])
                thermreg = 'ectothermic'
            else:
                heads = wchoice([(1,.975),(randrange(2,21),.025)])
                hasexoskeleton = False
                thermreg = choice(['ectothermic','endothermic'])

            # Determine # of Heads

            if heads > 0:
                creature['heads'] = heads

            # Determine Body Type

            bodytype = wchoice([('segmented',.05),('centralized',.9),('non-segmented',.05)])
            if bodytype == 'segmented':
                creature['abdomen'] = 1
                if randrange(1,3) == 1:
                    creature['thorax'] = 1
                else:
                    if heads > 0:
                        creature.pop('heads')
                    cephalothorax = wchoice([(1,.975),(randrange(2,6),.025)])
                    creature['cephalothorax'] = cephalothorax
            elif bodytype == 'centralized':
                creature['torso'] = 1
                creature['hips'] = 1
            else:
                creature['body'] = 1
                
            description = []
            para1 = []
            para2 = []
            para3 = []

            # Determine Creature Size
            size = wchoice([(randrange(1,11),.4),(randrange(11,101),.4),(randrange(101,501),.15), \
                            (randrange(501,2001),.04),(randrange(2001,10001),.005),(randrange(10001,50001),.005)])
            malesize = max(int((size * float(randrange(90,150))) / 100),1)
            femalesize = max(int((size * float(randrange(70,110))) / 100),1)
            creature['malesize'] = malesize
            creature['femalesize'] = femalesize
            creature['size'] = (malesize + femalesize) / 2

            for item in sizedict.items():
                if size in range(item[1][2],item[1][3]):
                    sizedesc = item[0]
                    sizecat = item[1][4]
                    creature['sizecat'] = item[1][4]
                    break

            roughsizemin = max(int(max(creature['malesize'],creature['femalesize']) * 0.9),1)
            roughsizemax = max(int(max(creature['malesize'],creature['femalesize']) * 1.1),2)
            if roughsizemin > 50:
                roughsizemin = int(round(roughsizemin,-1))
                roughsizemax = max(int(round(roughsizemax,-1)),roughsizemin + 10)
            if sizecat < 3:
                sizeterms = t('triflingwords')
                creature['nfeatures'] = [dchoice(t('triflingwords')) + ' ' + dchoice(t('sizewords'))]
            elif sizecat == 3:
                sizeterms = t('averagewords')
            else:
                sizeterms = t('augustwords') + t('immensewords')
                creature['nfeatures'] = [dchoice(t('immensewords')) + ' ' + dchoice(t('immensewords'))]
            line = choice(['The %s is %s-sized species; it weighs around %s pounds.' % (creaturename,p.a(dchoice(sizedict[sizedesc][1])), \
                                                                                                    (roughsizemin + roughsizemax) / 2), \
                                  'Where physical %s is concerned, %s is %s species; it weighs from %s to %s pounds.' % \
                                  (dchoice(t('sizewords')),dchoice(ctitles),p.a(dchoice(sizeterms)), \
                                   roughsizemin,roughsizemax), \
                                  'The %s has %s physical %s; it weighs between %s to %s pounds.' % \
                                  (creaturename,dchoice(sizeterms),dchoice(t('sizewords')),roughsizemin,roughsizemax), \
                                  '%s is a %s of %s proportions.' % (dchoice(ctitles,1),dchoice(t('cwords')),dchoice(sizeterms)), \
                                  '%s is a %s of %s proportions; it weighs between %s and %s pounds.' % \
                                  (dchoice(ctitles,1),dchoice(t('cwords')),dchoice(sizeterms),roughsizemin,roughsizemax)])
            para1.append(line)

            paraswitch = True

            # Determine Reproductive Habits

            # (Reproductive Frequency)
            # This is a general number to determine how promiscuous the animal is.

            repofreq = randrange(1,11)
            repofreq = max(1,repofreq - (sizecat - 1))
            creature['repofreq'] = repofreq

            # (Gestation Period)
            # Influenced by creature size and reproductive frequency.

            gestation = (365 / repofreq) * sizecat
            creature['gestation'] = gestation

            line = '%s has a gestation period of %s days and %s.' % (dchoice(ctitles,1),str(gestation),dchoice(t('crep-' + str(repofreq))))
            para3.append(line)

            spherewordsdict = {}
            spherewordsdict['Terrestrial'] = ['terrestrial %s','land-dwelling %s','earthbound %s','land-going %s','%s of the land']
            spherewordsdict['Amphibian'] = ['amphibian %s','amphibious %s','%s of both land and water']
            spherewordsdict['Aquatic'] = ['aquatic %s','water-going %s','%s of the water','water-dwelling %s']
            spherewordsdict['Subterranean'] = ['subterranean %s','underground %s','subterrestrial %s']
            spherewordsdict['Aerial'] = ['aerial %s','sky-dwelling %s','%s of the sky','sky-going %s','%s of the air']

            line = '%s is %s.' % (dchoice(ctitles,1),p.a(choice(spherewordsdict[creature['sphere']]) % (dchoice(t('cwords')))))
            para3.append(line)
            
            nbiomelist = []
            for biome in creature['biomes']: nbiomelist.append(p.plural_noun(biome.lower()))
            line = choice(['%s %s %s %s.' % (dchoice(ctitles,1),dchoice(t('mainlywords')),dchoice(t('inhabitswords')),p.join(nbiomelist))])

            para3.append(line)

            # Territoriality

            if territoriality < 4:
                line = choice(['%s is not territorial.' % (dchoice(ctitles,1)), \
                                      '%s does not %s %s %s.' % (dchoice(ctitles,1),dchoice(t('careaboutwords')),dchoice(t('terrguardwords')) + 'ing',p.a(dchoice(t('territorywords')))), \
                                      '%s is not %s %s with %s %s.' % (dchoice(ctitles,1),dchoice(t('verywords')),dchoice(t('concernedwords')),dchoice(t('terrguardwords')) + 'ing', \
                                                                       p.a(dchoice(t('territorywords'))))])

            elif territoriality in [4,5]:
                line = choice(['%s may or may not %s %s.' % (dchoice(ctitles,1),dchoice(t('terrguardwords')),p.a(dchoice(t('territorywords')))), \
                                      '%s %s chooses to %s %s.' % (dchoice(ctitles,1),dchoice(t('rarelywords')),dchoice(t('terrguardwords')),p.a(dchoice(t('territorywords')))), \
                                      'It is only %s that %s chooses to %s %s.' % (dchoice(t('rarelywords')),dchoice(ctitles),dchoice(t('terrguardwords')), \
                                                                                   p.a(dchoice(t('territorywords'))))])
            
            elif territoriality in [6,7]:
                line = choice(['%s, %s prefers to %s %s.' % (dchoice(t('oftenwords'),1),dchoice(ctitles),dchoice(t('terrguardwords')),p.a(dchoice(t('territorywords')))), \
                                      '%s %s chooses to %s %s.' % (dchoice(ctitles,1),dchoice(t('oftenwords')),dchoice(t('terrguardwords')),p.a(dchoice(t('territorywords')))), \
                                      '%s is %s %s %s %s.' % (dchoice(ctitles,1),dchoice(t('oftenwords')),dchoice(t('knowntowords')),dchoice(t('terrguardwords')),p.a(dchoice(t('territorywords'))))])

            else:
                line = choice(['%s is %s territorial.' % (dchoice(ctitles,1),dchoice(t('verywords'))), \
                                      '%s is %s be %s territorial and %s when its boundaries are %s.' % (dchoice(ctitles,1),dchoice(t('knowntowords')),dchoice(t('verywords')), \
                                                                                                          dchoice(t('dangerouswords')),dchoice(t('breachedwords'))), \
                                      '%s should %s %s %s %s at all costs.' % (dchoice(t('travwordsplur'),1),dchoice(t('avoidwords')),dchoice(t('breachingwords')),dchoice(ctitles,0,1), \
                                                                               dchoice(t('territorywords'))), \
                                      '%s %s %s %s to those who %s its %s.' % (dchoice(ctitles,1),dchoice(t('iswords')),dchoice(t('verywords')),dchoice(t('dangerouswords')), \
                                                                               dchoice(t('breachwords')),dchoice(t('territorywords')))])

            para3.append(line)

            # Belligerence
            
            # Small Creatures
            if sizecat < 3:
                # Belligerent Meat-Eaters
                if creature['predation'] in ['Carnivore','Omnivore'] and creature['belligerence'] > 7:
                    line = choice([' %s may be %s, but it makes up for ' % (dchoice(ctitles,1),dchoice(sizedict[sizedesc][0])) + choice(['it','its size','its physical stature']) \
                           + ' ' + choice(['with its ferocity','with sheer ferocity','in viciousness','with viciousness','with its savagery', \
                                            'with killer instinct','with killer instinct','with its fearsomeness','in fearsomeness', \
                                            'with its predatory prowess','with its terrifying demeanor','with its violent tendencies']) + '.', \
                                          ' %s %s %s %s, and is %s by %s.' % (dchoice(ctitles,1),dchoice(t('iswords')),dchoice(idict[3] + idict[4] + idict[5]), \
                                                                             dchoice(t('aggwords')),dchoice(t('despisedwords')),dchoice(t('peoplewords'))), \
                                          ' %s its lack of %s, %s is %s %s.' % (dchoice(t('despitewords'),1),dchoice(t('sizewords')),dchoice(ctitles), dchoice(idict[3] + idict[4] + idict[5]), \
                                                                          dchoice(t('aggwords'))), \
                                          ' %s is %s by %s %s its %s %s %s its %s.' % (dchoice(ctitles,1),choice(['feared',dchoice(t('despisedwords'))]), \
                                                                                       dchoice(t('peoplewords')),dchoice(t('becausewords')),dchoice(t('aggwords')),dchoice(t('naturewords')), \
                                                                                       dchoice(t('despitewords')),dchoice(t('sizewords')))])
                    para3[-1] += line

                # Semi-Docile Meat-Eaters
                elif creature['predation'] in ['Carnivore','Omnivore'] and creature['belligerence'] in range(4,8):
                    line = choice([' %s its predatory %s, %s is not %s %s.' % (dchoice(t('despitewords'),1),dchoice(t('naturewords')),dchoice(ctitles), \
                                                                           dchoice(idict[2]),dchoice(t('aggwords'))), \
                                          ' %s its predatory %s, %s is %s %s.' % (dchoice(t('despitewords'),1),dchoice(t('dietwords')),dchoice(ctitles), \
                                                                                    dchoice(idict[1] + idict[2]),dchoice(t('docilewords'))), \
                                          ' %s %s is %s, it %s %s %s.' % (dchoice(t('thoughwords'),1),dchoice(ctitles), p.a(dchoice(t('predatorwords'))), \
                                                                          dchoice(t('iswords')),dchoice(idict[1] + idict[2]),\
                                                                          dchoice(t('docilewords'))), \
                                          ' For %s, %s is %s %s %s.' % (p.a(dchoice(t('predatorwords'))),dchoice(ctitles),dchoice(t('inclinedwords')), \
                                                                        dchoice(idict[1]),dchoice(t('docilewords')))])
                    para3[-1] += line

                # Extremely Docile Meat-Eaters
                elif creature['predation'] in ['Carnivore','Omnivore'] and creature['belligerence'] < 4:
                    line = choice([' %s is known to be %s %s and %s, especially for %s.' % (dchoice(ctitles,1),dchoice(idict[3] + idict[4] + idict[5]), \
                                                                                                           dchoice(t('docilewords')),dchoice(t('shywords')),p.a(dchoice(t('predatorwords')))), \
                                          ' %s being %s, %s is among the most %s of %s.' % (dchoice(t('despitewords'),1),p.a(dchoice(t('predatorwords'))),dchoice(ctitles), \
                                                                                            dchoice(t('shywords')),dchoice(t('cwordsplur'))), \
                                          ' %s is %s %s %s %s being %s.' % (dchoice(ctitles,1),dchoice(t('inclinedwords')),dchoice(idict[1]),dchoice(t('shywords')), \
                                                                           dchoice(t('despitewords')),p.a(dchoice(t('predatorwords'))))])
                    para3[-1] += line

                # Belligerent Non-Predators
                elif creature['predation'] in ['Herbivore','Other'] and creature['belligerence'] > 7:
                    if creature['predation'] == 'Herbivore':
                        predphrase = 'an herbivore'
                        dietphrase = 'herbivorous'
                    else:
                        predphrase = 'not %s' % p.a(dchoice(t('predatorwords')))
                        dietphrase = 'unusual (and non-predatory)'
                    line = choice([' %s %s is %s, it is %s %s.' % (dchoice(t('thoughwords'),1),dchoice(ctitles),predphrase,dchoice(idict[4] + idict[5]),dchoice(t('aggwords'))), \
                                          ' %s its non-predatory %s, %s is %s %s.' % (dchoice(t('despitewords'),1),dchoice(t('dietwords')),dchoice(ctitles), \
                                                                                   dchoice(idict[4] + idict[5]),dchoice(t('aggwords'))), \
                                          ' %s %s %s %s, it is %s %s.' % (dchoice(t('despitewords'),1),dchoice(ctitles,0,1),dietphrase, \
                                                                          dchoice(t('dietwords')),dchoice(idict[4] + idict[5]),dchoice(t('aggwords'))), \
                                          ' %s would be well-advised to %s %s, for %s its non-predatory diet, it %s %s %s.' % \
                                          (dchoice(t('travwordsplur'),1),dchoice(t('avoidwords')),dchoice(ctitles),dchoice(t('despitewords')),dchoice(t('iswords')),dchoice(idict[4] + idict[5]), \
                                           dchoice(t('aggwords')))])
                    para3[-1] += line

                # Semi-Docile Non-Predators
                elif creature['predation'] in ['Herbivore','Other'] and creature['belligerence'] in range(4,8):
                    line = choice([' %s being %s, %s %s %s %s.' % (dchoice(t('despitewords'),1),dchoice(sizedict[sizedesc][0]), dchoice(ctitles), \
                                                                dchoice(t('iswords')), dchoice(idict[1]), dchoice(t('illtempwords'))), \
                                          ' %s it is %s, %s %s %s %s.' % (dchoice(t('thoughwords'),1),dchoice(sizedict[sizedesc][0]), dchoice(ctitles), \
                                                                        dchoice(t('iswords')), dchoice(idict[1]), dchoice(t('illtempwords'))), \
                                          ' %s is usually not %s so long as it is not %s.' % (dchoice(ctitles,1),p.a(dchoice(t('dangerwords'))),dchoice(t('angeredwords')))])
                    para3[-1] += line

                # Docile Non-Predators
                elif creature['predation'] in ['Herbivore','Other'] and creature['belligerence'] < 4:
                    line = choice([' %s %s %s and %s %s make it %s.' % (dchoice(ctitles,1,1),dchoice(sizedict[sizedesc][0]),dchoice(t('sizewords')), \
                                                                  dchoice(t('docilewords')),dchoice(t('naturewords')), \
                                                                  choice(['respected','reclusive','honored among many races', \
                                                                                 'respected by many races','revered','revered by some', \
                                                                                 'revered among many races','respected by some', \
                                                                                 'honored by some'])), \
                                          ' Between %s %s %s and its %s %s, it is %s %s by %s.' % (dchoice(ctitles,0,1),dchoice(sizedict[sizedesc][0]), \
                                                                                                dchoice(t('sizewords')),dchoice(t('docilewords')), \
                                                                                                dchoice(t('naturewords')),dchoice(t('oftenwords')),dchoice(t('respectedwords')), \
                                                                                                dchoice(t('peoplewords')))])
                    para3[-1] += line

            # Medium Creatures
            if sizecat in [3,4]:
                # Belligerent Meat-Eaters
                if creature['predation'] in ['Carnivore','Omnivore'] and creature['belligerence'] > 7:
                    line = choice([' %s %s %s %s and %s %s %s, it %s a %s to %s.' % (dchoice(t('becausewords'),1),dchoice(ctitles,0,1),dchoice(sizedict[sizedesc][0]), \
                                                                                                 dchoice(t('sizewords')),dchoice(idict[4] + idict[5]),dchoice(t('aggwords')),dchoice(t('naturewords')), \
                                                                                                 dchoice(t('iswords')),dchoice(t('dangerwords')),dchoice(t('travwordsplur'))), \
                                          ' Between being %s of %s and %s in its tendencies, the %s is a wise %s to %s.' % \
                                          (dchoice(sizedict[sizedesc][0]),dchoice(t('sizewords')),dchoice(t('aggwords')),creaturename,dchoice(t('cwords')),dchoice(t('avoidwords'))), \
                                          ' All but the most %s of %s should %s this %s %s-natured %s.' % (dchoice(t('seasonedwords')),dchoice(t('travwordsplur')), dchoice(t('avoidwords')), \
                                                                                                             dchoice(idict[4] + idict[5]),dchoice(t('aggwords')),dchoice(t('cwords'))), \
                                          ' %s its %s %s and %s %s, the %s is much-%s.' % (dchoice(t('becausewords'),1),dchoice(t('illtempwords')),dchoice(t('naturewords')), \
                                                                                              dchoice(t('aggwords')),dchoice(t('habitswords')),creaturename,dchoice(t('despisedwords')))])
                    para3[-1] += line

                # Semi-Docile Meat-Eaters
                elif creature['predation'] in ['Carnivore','Omnivore'] and creature['belligerence'] in range(4,8):
                    line = choice([' %s it is not especially %s, %s is still considered a %s to %s.' % (dchoice(t('thoughwords'),1),dchoice(t('illtempwords')),dchoice(ctitles), \
                                                                                                          dchoice(t('dangerwords')),dchoice(t('travwordsplur'))), \
                                          ' %s is not among the most %s of %s; %s, it is still considered a %s when %s.' % (dchoice(ctitles,1),dchoice(t('illtempwords')), \
                                                                                                                            dchoice(t('cwordsplur')),dchoice(t('howeverwords')), \
                                                                                                                            dchoice(t('dangerwords')),dchoice(t('angeredwords'))), \
                                          ' Caution is warranted around %s, since it is %s of stature and not entirely %s of %s.' \
                                          % (dchoice(ctitles),dchoice(sizedict[sizedesc][0]),dchoice(t('docilewords')),dchoice(t('naturewords')))])
                    para3[-1] += line

                # Extremely Docile Meat-Eaters
                elif creature['predation'] in ['Carnivore','Omnivore'] and creature['belligerence'] < 4:
                    line = choice([' %s its %s %s and predatory %s, %s is usually not a %s to %s.' % (dchoice(t('despitewords'),1),dchoice(sizedict[sizedesc][0]),dchoice(t('sizewords')), \
                                                                                                                dchoice(t('dietwords')),dchoice(ctitles),dchoice(t('dangerwords')),dchoice(t('travwordsplur'))), \
                                          ' %s %s %s %s, it is only considered a %s if %s.' % (dchoice(t('becausewords'),1),dchoice(ctitles,0,1),dchoice(t('docilewords')), \
                                                                                               dchoice(t('naturewords')),dchoice(t('dangerwords')),dchoice(t('angeredwords'))), \
                                          ' %s is amongst the most %s of %s %s its %s %s and predatory diet.' % (dchoice(ctitles,1),dchoice(t('docilewords')),dchoice(t('cwordsplur')), \
                                                                                                                 dchoice(t('despitewords')),dchoice(sizedict[sizedesc][0]),dchoice(t('sizewords')))])
                    para3[-1] += line

                # Belligerent Non-Predators
                elif creature['predation'] in ['Herbivore','Other'] and creature['belligerence'] > 7:
                    line = choice([' %s %s non-predatory %s, it is %s %s; between this and its %s physical %s, %s would do well to %s it.' % \
                                          (dchoice(t('despitewords'),1),dchoice(ctitles,1,1),dchoice(t('dietwords')),dchoice(idict[4] + idict[5]),dchoice(t('illtempwords')), \
                                           dchoice(sizedict[sizedesc][0]),dchoice(t('sizewords')),dchoice(t('travwordsplur')),dchoice(t('avoidwords'))), \
                                          ' %s it is not a meat-eater, %s is %s %s.' % (dchoice(t('thoughwords'),1),dchoice(ctitles),dchoice(idict[4] + idict[5]),dchoice(t('aggwords'))), \
                                          ' Between %s %s %s and %s %s %s, it is best %s by %s.' % (dchoice(ctitles,0,1),dchoice(sizedict[sizedesc][0]),dchoice(t('sizewords')), \
                                                                                                     dchoice(idict[4] + idict[5]),dchoice(t('illtempwords')),dchoice(t('habitswords')), \
                                                                                                     dchoice(t('avoidedwords')),dchoice(t('travwordsplur')))])
                    para3[-1] += line

                # Semi-Docile Non-Predators
                elif creature['predation'] in ['Herbivore','Other'] and creature['belligerence'] in range(4,8):
                    line = choice([' %s is usually not a %s so long as it is not %s.' % (dchoice(ctitles,1),dchoice(t('dangerwords')),dchoice(t('angeredwords'))), \
                                          ' %s is %s not %s when %s.' % (dchoice(ctitles,1),dchoice(t('generallywords')),dchoice(t('illtempwords')),dchoice(t('avoidedwords'))), \
                                          ' %s rarely poses a %s to %s if %s, %s its %s %s.' % (dchoice(ctitles,1),dchoice(t('dangerwords')),dchoice(t('travwordsplur')), \
                                                                                                dchoice(t('avoidedwords')),dchoice(t('despitewords')),dchoice(sizedict[sizedesc][0]), \
                                                                                                dchoice(t('sizewords')))])
                    para3[-1] += line

                # Extremely Docile Non-Predators
                elif creature['predation'] in ['Herbivore','Other'] and creature['belligerence'] < 4:
                    line = choice([' %s the %s is by no means %s %s, it is %s %s and %s.' % (dchoice(t('thoughwords'),1),creaturename,p.a(dchoice(sizedict['tiny'][0] + sizedict['small'][0])), \
                                                                                        dchoice(t('cwords')),dchoice(idict[1]),dchoice(t('shywords')), \
                                                                                        dchoice(t('docilewords'))), \
                                          ' %s is %s and %s of %s.' % (dchoice(ctitles,1),dchoice(t('shywords')),dchoice(t('docilewords')),dchoice(t('naturewords'))), \
                                          ' %s is among the most %s of %s.' % (dchoice(ctitles,1),dchoice(t('docilewords')),dchoice(t('cwordsplur')))])
                    para3[-1] += line

            # Large Creatures

            if sizecat > 4:
                # Belligerent Meat-Eaters
                if creature['predation'] in ['Carnivore','Omnivore'] and creature['belligerence'] > 7:
                    line = choice([' %s is truly a %s %s to %s, and should be considered %s %s if %s.' % \
                                          (dchoice(ctitles,1),dchoice(t('terrifyingwords')),dchoice(t('visionwords')),dchoice(t('beholdwords')),dchoice(t('verywords')), \
                                           dchoice(t('dangerouswords')),dchoice(t('encounteredwords'))), \
                                          ' Between %s %s %s and %s %s, it should be %s at all costs.' % (dchoice(ctitles,0,1),dchoice(t('immensewords')),dchoice(t('weightwords')), \
                                                                                                          dchoice(t('aggwords')),dchoice(t('naturewords')),dchoice(t('avoidedwords'))), \
                                          ' This %s, %s %s is %s to any %s who %s it.' % (dchoice(t('immensewords')),dchoice(t('aggwords')),dchoice(t('cwords')),p.a(dchoice(t('dangerwords'))), \
                                                                                          dchoice(t('travwordsplur')),dchoice(t('encounterwords')))])
                    para3[-1] += line

                # Semi-Docile Meat-Eaters
                elif creature['predation'] in ['Carnivore','Omnivore'] and creature['belligerence'] in range(4,8):
                    line = choice([' %s it %s somewhat %s (unless %s), %s is still %s %s to any %s it decides to view as a potential meal.' % \
                                          (dchoice(t('thoughwords'),1),dchoice(t('iswords')),dchoice(t('docilewords')),dchoice(t('angeredwords')),dchoice(ctitles),p.a(dchoice(t('immensewords'))), \
                                           dchoice(t('dangerwords')),dchoice(t('travwordsplur'))), \
                                          ' %s, %s %s left %s in peace, but its %s %s and the fact that it is %s make it %s to those who %s it.' % \
                                          (dchoice(t('sometimeswords'),1),dchoice(ctitles),dchoice(t('hasknownwords')),dchoice(t('travwordsplur')),dchoice(t('immensewords')),dchoice(t('weightwords')), \
                                          p.a(dchoice(t('predatorwords'))),p.a(dchoice(t('dangerwords'))),dchoice(t('encounterwords')))])
                    para3[-1] += line

                # Extremely Docile Meat-Eaters
                elif creature['predation'] in ['Carnivore','Omnivore'] and creature['belligerence'] < 4:
                    line = choice([' %s its %s %s and the fact that it is a %s, %s is an extremely %s %s.' % \
                                          (dchoice(t('despitewords'),1),dchoice(t('immensewords')),dchoice(t('weightwords')),dchoice(t('predatorwords')),dchoice(ctitles),dchoice(t('docilewords')), \
                                          dchoice(t('cwords'))), \
                                          ' %s it is a %s %s, %s has displayed %s %s towards being %s to %s.' % \
                                          (dchoice(t('thoughwords'),1),dchoice(t('immensewords')),dchoice(t('predatorwords')),dchoice(ctitles),p.a(dchoice(t('oddwords'))), \
                                           dchoice(t('tendencywords')),dchoice(t('docilewords')),dchoice(t('travwordsplur'))), \
                                          ' The %s %s is %s %s %s.' % (dchoice(t('immensewords')),creaturename,p.a(dchoice(t('surprisinglywords'))),dchoice(t('shywords')), \
                                                                       dchoice(t('cwords')))])
                    para3[-1] += line

                # Belligerent Non-Predators
                elif creature['predation'] in ['Herbivore','Other'] and creature['belligerence'] > 7:
                    line = choice([' %s %s %s %s; considering this and its %s %s, %s would do well to %s it.' % \
                                          (dchoice(ctitles,1),dchoice(t('iswords')),dchoice(idict[4] + idict[5]),dchoice(t('illtempwords')), \
                                           dchoice(t('immensewords')),dchoice(t('weightwords')),dchoice(t('travwordsplur')),dchoice(t('avoidwords'))), \
                                          ' %s it is not a meat-eater, %s is %s %s. %s this and its %s %s, it %s %s %s.' % \
                                          (dchoice(t('thoughwords'),1),dchoice(ctitles),dchoice(idict[4] + idict[5]),dchoice(t('aggwords')), \
                                           dchoice(t('becausewords'),1),dchoice(t('immensewords')),dchoice(t('weightwords')),dchoice(t('iswords')),dchoice(t('verywords')),dchoice(t('dangerouswords'))), \
                                          ' Between %s %s %s and %s %s %s, it is best %s by %s.' % (dchoice(ctitles,0,1),dchoice(t('immensewords')),dchoice(t('weightwords')), \
                                                                                                     dchoice(idict[4] + idict[5]),dchoice(t('illtempwords')),dchoice(t('habitswords')), \
                                                                                                     dchoice(t('avoidedwords')),dchoice(t('travwordsplur')))])
                    para3[-1] += line

                # Semi-Docile Non-Predators
                elif creature['predation'] in ['Herbivore','Other'] and creature['belligerence'] in range(4,8):
                    line = choice([' %s %s is not %s, it still %s %s to %s because of its %s %s.' % \
                                          (dchoice(t('thoughwords'),1),dchoice(ctitles),p.a(dchoice(t('predatorwords'))),dchoice(t('iswords')),p.a(dchoice(t('dangerwords'))), \
                                           dchoice(t('travwordsplur')),dchoice(t('immensewords')),dchoice(t('weightwords'))), \
                                          ' %s not %s %s, %s %s %s %s when %s, especially because of its %s %s.' % \
                                          (dchoice(t('thoughwords'),1),dchoice(t('verywords')),dchoice(t('aggwords')),dchoice(ctitles),dchoice(t('iswords')),dchoice(idict[4] + idict[5]), \
                                           dchoice(t('dangerouswords')),dchoice(t('angeredwords')),dchoice(t('immensewords')),dchoice(t('weightwords'))), \
                                          ' %s %s %s and not-entirely-%s %s make it a good %s to %s unless absolutely necessary.' % \
                                          (dchoice(ctitles,1,1),dchoice(t('immensewords')),dchoice(t('weightwords')),dchoice(t('docilewords')),dchoice(t('naturewords')), \
                                          dchoice(t('cwords')),dchoice(t('avoidwords')))])
                    para3[-1] += line

                # Extremely Docile Non-Predators
                elif creature['predation'] in ['Herbivore','Other'] and creature['belligerence'] < 4:
                    line = choice([' %s %s %s %s, it is %s %s unless %s.' % (dchoice(t('despitewords'),1),dchoice(ctitles,0,1),dchoice(t('immensewords')), \
                                                                                    dchoice(t('weightwords')),dchoice(t('verywords')),dchoice(t('docilewords')),dchoice(t('angeredwords'))), \
                                          ' %s %s is %s %s, it is also %s %s and %s.' % (dchoice(t('thoughwords'),1),dchoice(ctitles),p.a(dchoice(t('immensewords'))),dchoice(t('cwords')), \
                                                                                  dchoice(t('verywords')),dchoice(t('shywords')),dchoice(t('docilewords'))), \
                                          ' %s is %s by %s %s its %s %s and %s %s.' % (dchoice(ctitles,1),dchoice(t('respectedwords')),dchoice(t('peoplewords')),dchoice(t('becausewords')), \
                                                                                   dchoice(t('docilewords')),dchoice(t('naturewords')),dchoice(t('immensewords')),dchoice(t('weightwords')))])
                    para3[-1] += line

            # Sphere Diversification:
            # First, for each sphere, decide the main morphological choices according to the weighted choice function.
            # Then, determine the number of limbs and other body parts according to a similarly weighted scheme.
            # After this algorithm, we will move on to determining the function of body parts and color schemes.

            if sphere == 'Terrestrial':

                # Head differentiation
                
                if creature.get('heads') > 0 or creature.get('cephalothorax') > 0:
                    
                    # Antennae
                    antennae = wchoice([(0,.95),(2,.04),(randrange(4,9,2),.01)])
                    if antennae > 0:
                        creature['antennae'] = antennae
                        
                    # Eyes
                    eyes = wchoice([(0,.005),(1,.005),(2,.95),(randrange(2,21),.04)])
                    if eyes > 0:
                        creature['eyes'] = eyes

                    # Feelers
                    feelers = wchoice([(0,.98),(2,.01),(randrange(2,21,2),.01)])
                    if feelers > 0:
                        creature['feelers'] = feelers

                    # Whiskers
                    whiskers = wchoice([(0,.6),(randrange(2,21,2),.2),(randrange(22,61,2),.2)])
                    if whiskers > 0:
                        creature['whiskers'] = whiskers
                        
                    # Jaw/mouth/nose/teeth/tongue
                    
                    jawtype = wchoice([('jaw',.96),('beak',.01),('pincers',.03)])

                    if jawtype == 'beak':
                        creature['beak'] = 1
                        teeth = wchoice([(0,.99),(randrange(2,51,2),.005),(randrange(100,3001,2),.005)])
                        if teeth > 0:
                            creature['teeth'] = teeth
                        creature['tongue'] = 1

                    elif jawtype == 'pincers':
                        creature['headpincers'] = wchoice([(2,.95),(randrange(4,9,2),.05)])
                        creature['mouth'] = 1
                        if randrange(1,21) == 1:
                            nose = wchoice([('nose',.95),('proboscis',.025),('trunk',.025)])
                            creature[nose] = 1
                        teeth = wchoice([(randrange(2,51,2),.9),(randrange(100,3001,2),.1)])
                        creature['teeth'] = teeth
                        creature['tongue'] = 1

                    else:
                        creature['jaw'] = 1
                        creature['mouth'] = 1
                        nose = wchoice([('nose',.95),('proboscis',.025),('trunk',.025)])
                        creature[nose] = 1
                        teeth = wchoice([(randrange(2,51,2),.9),(randrange(100,3001,2),.1)])
                        creature['teeth'] = teeth
                        creature['tongue'] = 1
                        
                    # Horns
                    horns = wchoice([(0,.9),(1,.045),(2,.045),(randrange(3,101),.01)])
                    if horns > 0:
                        creature['horns'] = horns
                        
                    # Ears
                    ears = wchoice([(0,.0025),(2,.995),(randrange(4,21,2),.0025)])
                    if ears > 0:
                        creature['ears'] = ears

                # Head differentiation finished!
                # Moving on to body differentiation...

                # Arms

                arms = wchoice([(0,.96),(2,.035),(randrange(4,11,2),.005)])
                if arms > 0:
                    handtype = wchoice([('hands',.9),('claws',.05),('pincers',.05)])
                    hands = arms
                    if handtype == 'hands':
                        digits = wchoice([(2,.02),(3,.3),(4,.3),(5,.3),(randrange(5,21),.08)])
                        creature['handdigits'] = digits
                    creature['arms'] = arms
                    creature['hands'] = hands

                if arms == 0:
                    tentacles = wchoice([(0,.98),(2,.019),(randrange(4,13,2),.001)])
                    if tentacles > 0:
                        creature['tentacles'] = tentacles
                
                # Legs

                if bodytype != 'non-segmented':
                    legs = wchoice([(2,.2),(4,.73),(6,.04),(randrange(8,41,2),.02),(randrange(42,501,2),.01)])
                    creature['legs'] = legs
                else:
                    legs = wchoice([(randrange(2,7,2),.6),(randrange(8,41,2),.3),(randrange(42,501,2),.01),(0,.09)])
                if legs > 0:
                    if legs == 2:
                        creature['midlegs'] = 2
                        creature['midext'] = 2
                        midexttype = wchoice([('paws',0.6),('hooves',0.2),('feet',0.2)])
                        creature['type-midext'] = midexttype
                        if midexttype != 'hooves':
                            midextdigits = wchoice([(2,.02),(3,.3),(4,.3),(5,.3),(randrange(5,21),.08)])
                            creature['midextdigits'] = midextdigits
                    if legs == 4:
                        creature['frontlegs'] = 2
                        creature['backlegs'] = 2
                        creature['frontext'] = 2
                        creature['backext'] = 2
                        backexttype = wchoice([('paws',0.6),('hooves',0.2),('feet',0.2)])
                        if backexttype != 'hooves':
                            backextdigits = wchoice([(2,.02),(3,.3),(4,.3),(5,.3),(randrange(5,21),.08)])
                            creature['backextdigits'] = backextdigits
                        creature['type-backext'] = backexttype
                        frontexttype = wchoice([(backexttype,0.97),('pincers',0.02),('claws',0.01)])
                        creature['type-frontext'] = frontexttype
                        if not frontexttype in ['hooves','pincers']:
                            frontextdigits = wchoice([(2,.02),(3,.3),(4,.3),(5,.3),(randrange(5,21),.08)])
                            creature['frontextdigits'] = frontextdigits
                    if legs > 4:
                        creature['frontlegs'] = 2
                        creature['backlegs'] = 2
                        creature['frontext'] = 2
                        creature['backext'] = 2
                        creature['midlegs'] = legs - 4
                        creature['midext'] = legs - 4
                        midexttype = wchoice([('paws',0.6),('hooves',0.2),('feet',0.2)])
                        creature['type-midext'] = midexttype
                        if midexttype != 'hooves':
                            midextdigits = wchoice([(2,.02),(3,.3),(4,.3),(5,.3),(randrange(5,21),.08)])
                            creature['midextdigits'] = midextdigits
                        backexttype = wchoice([(midexttype,0.97),('claws',0.03)])
                        creature['type-backext'] = backexttype
                        if backexttype != 'hooves':
                            backextdigits = wchoice([(2,.02),(3,.3),(4,.3),(5,.3),(randrange(5,21),.08)])
                            creature['backextdigits'] = backextdigits
                        frontexttype = wchoice([(midexttype,0.9),('pincers',0.05),('claws',0.05)])
                        creature['type-frontext'] = frontexttype
                        if frontexttype != 'hooves':
                            frontextdigits = wchoice([(2,.02),(3,.3),(4,.3),(5,.3),(randrange(5,21),.08)])
                            creature['frontextdigits'] = frontextdigits

                # Shell

                shell = wchoice([(1,.05),(0,.95)])
                if shell > 0:
                    creature['shell'] = 1

                # Tail
                tails = wchoice([(1,.75),(0,.2),(randrange(1,6),.05)])
                if tails > 0:
                    creature['tails'] = tails

                # Wings
                wings = wchoice([(2,.015),(randrange(4,11,2),.005),(0,.98)])
                if wings > 0:
                    creature['wings'] = wings
                    if randrange(1,3) == 1:
                        creature['wing-cover'] = 'feathers'
                        creature['type-cover'] = 'feathers'
                        cover = 'feathers'
                        creature['feathers'] = 1
                    
                # Body Covering
                if not 'type-cover' in creature.keys():
                    if bodytype == 'segmented':
                        cover = wchoice([('exoskeleton',.8),('skin',.02),('fur',.03),('scales',.12),('feathers',.03)])
                    else:
                        cover = wchoice([('exoskeleton',.03),('skin',.03),('fur',.51),('scales',.38),('feathers',.05)])
                    if cover in ['fur','scales','feathers']:
                        creature['skin'] = 1
                    creature[cover] = 1
                    creature['type-cover'] = cover

                if creature.get('wings') and not creature.get('wing-cover'):
                    creature['wing-cover'] = wchoice([('feathers',.8),('skin',.1),('scales',.1)])


            elif sphere == 'Amphibian':
                
                # Head differentiation
                
                if creature.get('heads') > 0 or creature.get('cephalothorax') > 0:
                    
                    # Antennae
                    antennae = wchoice([(0,.95),(2,.04),(randrange(4,9,2),.01)])
                    if antennae > 0:
                        creature['antennae'] = antennae
                        
                    # Eyes
                    eyes = wchoice([(0,.005),(1,.005),(2,.95),(randrange(2,21),.04)])
                    if eyes > 0:
                        creature['eyes'] = eyes

                    # Feelers
                    feelers = wchoice([(0,.88),(2,.11),(randrange(2,21,2),.01)])
                    if feelers > 0:
                        creature['feelers'] = feelers

                    # Whiskers
                    whiskers = wchoice([(0,.6),(randrange(2,21,2),.2),(randrange(22,61,2),.2)])
                    if whiskers > 0:
                        creature['whiskers'] = whiskers

                    # Gills

                    gills = wchoice([(0,.7),(1,.3)])
                    if gills > 0:
                        creature['gills'] = gills
                        
                    # Jaw/mouth/nose/teeth/tongue
                    
                    jawtype = wchoice([('jaw',.96),('beak',.01),('pincers',.03)])

                    if jawtype == 'beak':
                        creature['beak'] = 1
                        teeth = wchoice([(0,.99),(randrange(2,51,2),.005),(randrange(100,3001,2),.005)])
                        if teeth > 0:
                            creature['teeth'] = teeth
                        creature['tongue'] = 1

                    elif jawtype == 'pincers':
                        creature['headpincers'] = wchoice([(2,.95),(randrange(4,9,2),.05)])
                        creature['mouth'] = 1
                        teeth = wchoice([(0,.91),(randrange(2,51,2),.05),(randrange(100,3001,2),.04)])
                        creature['teeth'] = teeth
                        creature['tongue'] = 1

                    else:
                        creature['jaw'] = 1
                        creature['mouth'] = 1
                        teeth = wchoice([(randrange(2,51,2),.9),(randrange(100,3001,2),.1)])
                        creature['teeth'] = teeth
                        creature['tongue'] = 1
                        
                    # Horns
                    horns = wchoice([(0,.98),(1,.01),(2,.009),(randrange(3,101),.001)])
                    if horns > 0:
                        creature['horns'] = horns

                # Head differentiation finished!
                # Moving on to body differentiation...

                # Arms

                arms = wchoice([(0,.99),(2,.009),(randrange(4,11,2),.001)])
                if arms > 0:
                    handtype = wchoice([('hands',.9),('claws',.05),('pincers',.05)])
                    hands = arms
                    if handtype == 'hands':
                        digits = wchoice([(2,.02),(3,.3),(4,.3),(5,.3),(randrange(5,21),.08)])
                        creature['handdigits'] = digits
                    creature['arms'] = arms
                    creature['hands'] = hands

                if arms == 0:
                    tentacles = wchoice([(0,.98),(2,.019),(randrange(4,13,2),.001)])
                    if tentacles > 0:
                        creature['tentacles'] = tentacles
                
                # Legs

                if bodytype != 'non-segmented':
                    legs = wchoice([(0,.1),(2,.27),(4,.56),(6,.04),(randrange(8,41,2),.02),(randrange(42,501,2),.01)])
                    creature['legs'] = legs
                else:
                    legs = wchoice([(randrange(2,7,2),.1),(randrange(8,41,2),.3),(randrange(42,501,2),.01),(0,.59)])
                if legs > 0:
                    if legs == 2:
                        creature['midlegs'] = 2
                        creature['midext'] = 2
                        midexttype = wchoice([('claws',0.6),('pincers',0.2),('feet',0.2)])
                        creature['type-midext'] = midexttype
                        if midexttype == 'feet':
                            midextdigits = wchoice([(2,.02),(3,.3),(4,.3),(5,.3),(randrange(5,21),.08)])
                            creature['midextdigits'] = midextdigits
                    if legs == 4:
                        creature['frontlegs'] = 2
                        creature['backlegs'] = 2
                        creature['frontext'] = 2
                        creature['backext'] = 2
                        backexttype = wchoice([('claws',0.6),('pincers',0.2),('feet',0.2)])
                        if backexttype == 'feet':
                            backextdigits = wchoice([(2,.02),(3,.3),(4,.3),(5,.3),(randrange(5,21),.08)])
                            creature['backextdigits'] = backextdigits
                        creature['type-backext'] = backexttype
                        frontexttype = wchoice([(backexttype,0.97),('pincers',0.02),('claws',0.01)])
                        creature['type-frontext'] = frontexttype
                        if not frontexttype in ['claws','pincers']:
                            frontextdigits = wchoice([(2,.02),(3,.3),(4,.3),(5,.3),(randrange(5,21),.08)])
                            creature['frontextdigits'] = frontextdigits
                    if legs > 4:
                        creature['frontlegs'] = 2
                        creature['backlegs'] = 2
                        creature['frontext'] = 2
                        creature['backext'] = 2
                        creature['midlegs'] = legs - 4
                        creature['midext'] = legs - 4
                        midexttype = wchoice([('claws',0.6),('pincers',0.2),('feet',0.2)])
                        creature['type-midext'] = midexttype
                        if midexttype == 'feet':
                            midextdigits = wchoice([(2,.02),(3,.3),(4,.3),(5,.3),(randrange(5,21),.08)])
                            creature['midextdigits'] = midextdigits
                        backexttype = wchoice([(midexttype,0.97),('claws',0.03)])
                        creature['type-backext'] = backexttype
                        if backexttype == 'feet':
                            backextdigits = wchoice([(2,.02),(3,.3),(4,.3),(5,.3),(randrange(5,21),.08)])
                            creature['backextdigits'] = backextdigits
                        frontexttype = wchoice([(midexttype,0.9),('pincers',0.05),('claws',0.05)])
                        creature['type-frontext'] = frontexttype
                        if frontexttype == 'feet':
                            frontextdigits = wchoice([(2,.02),(3,.3),(4,.3),(5,.3),(randrange(5,21),.08)])
                            creature['frontextdigits'] = frontextdigits

                # Shell

                shell = wchoice([(1,.05),(0,.95)])
                if shell > 0:
                    creature['shell'] = 1

                # Tail
                tails = wchoice([(1,.75),(0,.2),(randrange(1,6),.05)])
                if tails > 0:
                    creature['tails'] = tails

                # Wings
                wings = wchoice([(2,.015),(randrange(4,11,2),.005),(0,.98)])
                if wings > 0:
                    creature['wings'] = wings
                    if randrange(1,21) == 1:
                        creature['wing-cover'] = 'feathers'
                        creature['type-cover'] = 'feathers'
                        cover = 'feathers'
                        creature['feathers'] = 1
                    
                # Body Covering
                if not 'type-cover' in creature.keys():
                    if bodytype == 'segmented':
                        cover = wchoice([('exoskeleton',.4),('skin',.4),('scales',.2)])
                    else:
                        cover = wchoice([('exoskeleton',.03),('skin',.55),('scales',.42)])
                    if cover in ['fur','scales','feathers']:
                        creature['skin'] = 1
                    creature[cover] = 1
                    creature['type-cover'] = cover

                if creature.get('wings') and not creature.get('wing-cover'):
                    creature['wing-cover'] = wchoice([('feathers',.02),('skin',.68),('scales',.3)])

##
##            elif sphere == 'Aquatic':
##                legs = wchoice([(randrange(2,7,2),.045),(randrange(8,41,2),.045),(randrange(42,501,2),.01),(0,.9)])
##                if legs == 0:
##                    fins = wchoice([(randrange(4,13),0.9),(randrange(14,25),.05),(0,.05)])
##                arms = wchoice([(0,.98),(2,.02)])
##                tails = wchoice([(1,.75),(0,.2),(randrange(1,6),.05)])
##                shell = wchoice([(1,.05),(0,.95)])
##                jawtype = wchoice([('Jaw',.96),('Beak',.02),('Pincers',.02)])
##
##            elif sphere == 'Aerial':
##                legs = wchoice([(randrange(2,7,2),.9),(randrange(8,41,2),.025),(randrange(42,501,2),.025),(0,.05)])
##                arms = wchoice([(0,.98),(2,.02)])
##                wings = wchoice([(2,.98),(randrange(4,11,2),.02)])
##                tails = wchoice([(1,.75),(0,.2),(randrange(1,6),.05)])
##                shell = wchoice([(1,.01),(0,.99)])
##                jawtype = wchoice([('Jaw',.28),('Beak',.7),('Pincers',.02)])
##
##            elif sphere == 'Subterranean':
##                jawtype = wchoice([('Jaw',.9),('Beak',.05),('Pincers',.05)])
##                legs = wchoice([(randrange(2,7,2),.8),(randrange(8,41,2),.1),(randrange(42,501,2),.05),(0,.05)])
##                arms = wchoice([(0,.8),(2,.15),(randrange(4,11,2),.05)])
##                tails = wchoice([(1,.75),(0,.2),(randrange(1,6),.05)])
##                shell = wchoice([(1,.2),(0,.8)])
##                jawtype = wchoice([('Jaw',.06),('Beak',.05),('Pincers',.35)])
##
##            # Predation Diversification
##
##            if predation == 'Carnivore':
##                jawdesc = choice(['elongated', 'fleshy', 'protruding', 'wide', 'muscular', 'very muscular', 'very wide', 'viselike', \
##                                           'blunt', 'crooked', 'unhinging', 'short'])
##                if jawtype == 'Jaw':
##                    teeth = choice(['long', 'curved', 'sharp', 'pointed', 'serrated', 'stubby', 'yellowed', 'blackish', 'curved', 'hooked', 'bright white', 'knifelike'])
##                    teethnum = wchoice([(randrange(2,51,2),.9),(randrange(100,3001,2),.1)])
##                elif jawtype == 'Beak':
##                    beakcol = choice(['exotically colored', 'black', 'white', 'orange', 'yellow', 'red', 'cruel-looking', 'pointed', 'prong-tipped', \
##                              'viscious-looking', 'oddly-formed'])
##                else:
##                    pincerdesc = choice(['sharply curved', 'spear-like', 'short', 'very long', 'scissor-like', 'long', 'insect-like', \
##                                                'serrated', 'razor-sharp', 'spiked'])


            # Body Description

            # Head(s)
            if creature.get('heads'):
                if creature['heads'] == 1:
                    chosentraits = self.ptraits(creature,'head')
                    line = choice(['%s has %s head.' % (dchoice(ctitles,1),p.a(p.join(chosentraits))), \
                                          '%s head is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    para1.append(line)
                else:
                    line = 'It has %s heads.' % (p.number_to_words(creature['heads']))
                    para1.append(line)
                    if creature['heads'] < 4:
                        for head in range(creature['heads']):
                            chosentraits = self.ptraits(creature,'head')
                            line = ' %s %s head is %s.' % (dchoice(ctitles,1,1),p.number_to_words(p.ordinal(head + 1)),p.join(chosentraits))
                            para1[-1] += line
                    else:
                        chosentraits = self.ptraits(creature,'head')
                        line = ' %s heads are %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))
                        para1[-1] += line

                # Antennae
                if creature.get('antennae'):
                    chosentraits = self.ptraits(creature,'antennae')
                    if creature['heads'] == 1:
                        line = choice(['%s has %s %s antennae.' % (dchoice(ctitles,1),p.number_to_words(creature['antennae']), \
                                                                          p.join(chosentraits)), \
                                              '%s %s antennae are %s.' % (dchoice(ctitles,1,1),p.number_to_words(creature['antennae']), \
                                                                          p.join(chosentraits))])
                        para1.append(line)
                    else:
                        line = choice(['%s has %s %s antennae per head.' % (dchoice(ctitles,1),p.number_to_words(creature['antennae']), \
                                                                                   p.join(chosentraits)), \
                                              '%s antennae are %s; it has %s per head.' % (dchoice(ctitles,1,1),p.join(chosentraits), \
                                                                                           p.number_to_words(creature['antennae']))])
                        para1.append(line)

                # Eyes
                if creature.get('eyes'):
                    colors = t('blue') + t('brown') + t('green') + t('gray') + t('black') + t('purple') + t('red') + t('orange') + t('silver') + \
                             t('white') + t('yellow')
                    eyecolor = choice(colors)
                    chosentraits = self.ptraits(creature,'eyes')
                    
                    if (randrange(1,6) == 1 and eyecolor not in t('black')) or 'reflective' in chosentraits:
                        if 'reflective' in chosentraits:
                            eyemod = choice(t('neon'))

                        else:
                            eyemod = choice(t('dull') + t('bright') + t('pale') + t('flecked'))

                        # Color Modification
                        if eyemod in t('flecked'):
                            colors.remove(eyecolor)
                            eyecolor2 = choice(colors)
                            if creature['eyes'] > 1 or (creature['eyes'] > 0 and creature['heads'] > 1):
                                eyeline = choice(['%s eyes are %s %s with %s.' % (dchoice(ctitles,1,1),eyecolor,eyemod,eyecolor2), \
                                                         'They are %s %s with %s.' % (eyecolor,eyemod,eyecolor2)])
                            else:
                                eyeline = choice(['%s eye is %s %s with %s.' % (dchoice(ctitles,1,1),eyecolor,eyemod,eyecolor2), \
                                                         'It is %s %s with %s.' % (eyecolor,eyemod,eyecolor2)])

                        else:
                            eyecolor = eyemod + ' ' + eyecolor
                            if creature['eyes'] > 1 or (creature['eyes'] > 0 and creature['heads'] > 1):
                                eyeline = choice(['%s eyes are %s.' % (dchoice(ctitles,1,1),eyecolor), \
                                                         'They are %s.' % (eyecolor)])
                            else:
                                eyeline = choice(['%s eye is %s.' % (dchoice(ctitles,1,1),eyecolor), \
                                                         'It is %s.' % (eyecolor)])
                    else:
                        if creature['eyes'] > 1 or (creature['eyes'] > 0 and creature['heads'] > 1):
                            eyeline = choice(['%s eyes are %s.' % (dchoice(ctitles,1,1),eyecolor), \
                                                     'They are %s.' % (eyecolor)])
                        else:
                            eyeline = choice(['%s eye is %s.' % (dchoice(ctitles,1,1),eyecolor), \
                                                     'It is %s.' % (eyecolor)])
                    # End Color Modification
                            
                    if creature['heads'] == 1 and creature['eyes'] > 1:
                        line = choice(['%s has %s %s eyes.' % (dchoice(ctitles,1),p.number_to_words(creature['eyes']), \
                                                                          p.join(chosentraits)), \
                                              '%s %s eyes are %s.' % (dchoice(ctitles,1,1),p.number_to_words(creature['eyes']), \
                                                                          p.join(chosentraits))])
                        
                    elif creature['heads'] > 1 and creature['eyes'] > 1:
                        line = choice(['%s has %s %s eyes per head.' % (dchoice(ctitles,1),p.number_to_words(creature['eyes']), \
                                                                                   p.join(chosentraits)), \
                                              '%s eyes are %s; it has %s per head.' % (dchoice(ctitles,1,1),p.join(chosentraits), \
                                                                                           p.number_to_words(creature['eyes']))])

                    elif creature['heads'] == 1 and creature['eyes'] == 1:
                        line = choice(['%s has a single %s eye.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                              '%s singular eye is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                        
                    else:
                        line = choice(['%s has a single %s eye per head.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                              'Each of %s heads has a single %s eye.' % (dchoice(ctitles,0,1),p.join(chosentraits))])
                    para1.append(line + ' ' + eyeline)

                else:
                    line = choice(['%s has no eyes.' % (dchoice(ctitles,1)), \
                                          '%s is eyeless.' % (dchoice(ctitles,1))])
                    para1.append(line)

                # Gills
                if creature.get('gills'):
                    chosentraits = self.ptraits(creature,'gills')
                    line = choice(['%s has %s gills.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                          '%s gills are %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    para1.append(line)

                # Jaw
                if creature.get('jaw'):
                    chosentraits = self.ptraits(creature,'jaw')
                    if creature['heads'] == 1:
                        line = choice(['%s has %s jaw.' % (dchoice(ctitles,1),p.a(p.join(chosentraits))), \
                                              '%s jaw is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    else:
                        line = choice(['%s has %s jaws.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                              '%s jaws are %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    para1.append(line)

                # Beak
                if creature.get('beak'):
                    chosentraits = self.ptraits(creature,'beak')
                    if creature['heads'] == 1:
                        line = choice(['%s has %s beak.' % (dchoice(ctitles,1),p.a(p.join(chosentraits))), \
                                              '%s beak is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    else:
                        line = choice(['%s has %s beaks.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                              '%s beaks are %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    para1.append(line)

                # Mouth-Pincers
                if creature.get('headpincers'):
                    chosentraits = self.ptraits(creature,'pincers')
                    if creature['heads'] == 1:
                        line = choice(['%s has %s pincers.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                              '%s pincers are %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    else:
                        line = choice(['%s has %s %s pincers per head.' % (dchoice(ctitles,1),p.number_to_words(creature['headpincers']), \
                                                                                   p.join(chosentraits)), \
                                              '%s pincers are %s; it has %s per head.' % (dchoice(ctitles,1,1),p.join(chosentraits), \
                                                                                           p.number_to_words(creature['headpincers']))])
                    para1.append(line)

                # Feelers
                if creature.get('feelers'):
                    chosentraits = self.ptraits(creature,'feelers')
                    if creature['heads'] == 1:
                        line = '%s has %s %s tentacle-like feelers around its %s.' % (dchoice(ctitles,1),p.number_to_words(creature['feelers']), \
                                                                                      p.join(chosentraits),jawtype)
                    else:
                        line = '%s has %s %s tentacle-like feelers around each of its %s.' % (dchoice(ctitles,1),p.number_to_words(creature['feelers']), \
                                                                                              p.join(chosentraits), p.plural_noun(jawtype))
                    para1.append(line)

                # Whiskers
                if creature.get('whiskers'):
                    chosentraits = self.ptraits(creature,'whiskers')
                    line = choice(['%s has %s whiskers.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                          '%s whiskers are %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    para1.append(line)

                # Mouth

                if creature.get('mouth'):
                    chosentraits = self.ptraits(creature,'mouth')
                    if creature['heads'] == 1:
                        line = choice(['%s has %s mouth.' % (dchoice(ctitles,1),p.a(p.join(chosentraits))), \
                                              '%s mouth is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    else:
                        line = choice(['%s has %s mouths.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                              '%s mouths are %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    para1.append(line)

                # Tongue

                if creature.get('tongue'):
                    chosentraits = self.ptraits(creature,'tongue')
                    if creature['heads'] == 1:
                        line = choice(['%s has %s tongue.' % (dchoice(ctitles,1),p.a(p.join(chosentraits))), \
                                              '%s tongue is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    else:
                        line = choice(['%s has %s tongues.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                              '%s tongues are %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    para1.append(line)

                # Teeth

                if creature.get('teeth'):
                    chosentraits = self.ptraits(creature,'teeth')
                    if creature['heads'] == 1:
                        line = choice(['%s has %s %s teeth.' % (dchoice(ctitles,1),p.number_to_words(creature['teeth']), \
                                                                       p.join(chosentraits)), \
                                              '%s %s teeth are %s.' % (dchoice(ctitles,1,1),p.number_to_words(creature['teeth']), \
                                                                       p.join(chosentraits))])
                    else:
                        line = choice(['%s has %s %s teeth per mouth.' % (dchoice(ctitles,1),p.number_to_words(creature['teeth']), \
                                                                                 p.join(chosentraits)), \
                                              '%s teeth are %s; it has %s per mouth.' % (dchoice(ctitles,1,1),p.join(chosentraits), \
                                                                                         p.number_to_words(creature['teeth']))])
                    para1.append(line)
                elif not creature.get('beak'):
                    line = choice(['%s is toothless.' % (dchoice(ctitles,1)), \
                                          '%s has no teeth.' % (dchoice(ctitles,1))])
                    para1.append(line)

                # Nose
                
                if creature.get('nose'):
                    chosentraits = self.ptraits(creature,'nose')
                    if creature['heads'] == 1:
                        line = choice(['%s has %s nose.' % (dchoice(ctitles,1),p.a(p.join(chosentraits))), \
                                              '%s nose is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    else:
                        line = choice(['%s has %s noses.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                              '%s noses are %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    para1.append(line)

                # Proboscise

                if creature.get('proboscis'):
                    chosentraits = self.ptraits(creature,'proboscis')
                    if creature['heads'] == 1:
                        line = choice(['%s has %s proboscis.' % (dchoice(ctitles,1),p.a(p.join(chosentraits))), \
                                              '%s proboscis is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    else:
                        line = choice(['%s has %s proboscises.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                              '%s proboscises are %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    para1.append(line)

                # Trunk

                if creature.get('trunk'):
                    chosentraits = self.ptraits(creature,'trunk')
                    if creature['heads'] == 1:
                        line = choice(['%s has %s trunk.' % (dchoice(ctitles,1),p.a(p.join(chosentraits))), \
                                              '%s trunk is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    else:
                        line = choice(['%s has %s trunks.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                              '%s trunks are %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    para1.append(line)

                # Horns
                if creature.get('horns'):
                    chosentraits = self.ptraits(creature,'horns')
                    if creature['heads'] == 1 and creature['horns'] > 1:
                        line = choice(['%s has %s %s horns.' % (dchoice(ctitles,1),p.number_to_words(creature['horns']), \
                                                                          p.join(chosentraits)), \
                                              '%s %s horns are %s.' % (dchoice(ctitles,1,1),p.number_to_words(creature['horns']), \
                                                                          p.join(chosentraits))])
                        para1.append(line)
                    elif creature['heads'] > 1 and creature['horns'] > 1:
                        line = choice(['%s has %s %s horns per head.' % (dchoice(ctitles,1),p.number_to_words(creature['horns']), \
                                                                                   p.join(chosentraits)), \
                                              '%s horns are %s; it has %s per head.' % (dchoice(ctitles,1,1),p.join(chosentraits), \
                                                                                           p.number_to_words(creature['horns']))])
                        para1.append(line)

                    elif creature['heads'] == 1 and creature['horns'] == 1:
                        line = choice(['%s has a single %s horn.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                              '%s singular horn is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                        para1.append(line)
                        
                    elif creature['heads'] > 1 and creature['horns'] == 1:
                        line = choice(['%s has a single %s horn per head.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                              'Each of %s heads has a single %s horn.' % (dchoice(ctitles,0,1),p.join(chosentraits))])
                        para1.append(line)

                # Ears
                if creature.get('ears'):
                    chosentraits = self.ptraits(creature,'ears')
                    if creature['heads'] == 1:
                        line = choice(['%s has %s %s ears.' % (dchoice(ctitles,1),p.number_to_words(creature['ears']), \
                                                                          p.join(chosentraits)), \
                                              '%s %s ears are %s.' % (dchoice(ctitles,1,1),p.number_to_words(creature['ears']), \
                                                                          p.join(chosentraits))])
                        para1.append(line)
                    elif creature['heads']:
                        line = choice(['%s has %s %s ears per head.' % (dchoice(ctitles,1),p.number_to_words(creature['ears']), \
                                                                                   p.join(chosentraits)), \
                                              '%s ears are %s; it has %s per head.' % (dchoice(ctitles,1,1),p.join(chosentraits), \
                                                                                           p.number_to_words(creature['ears']))])
                        para1.append(line)

                else:
                    line = choice(['%s has no discernable ears.' % (dchoice(ctitles,1)), \
                                          '%s is earless.' % (dchoice(ctitles,1))])
                    para1.append(line)

            elif not creature.get('cephalothorax'):
                line = choice(['%s has no discernable head.' % (dchoice(ctitles,1)), \
                                      '%s is headless.' % (dchoice(ctitles,1))])
                para1.append(line)

            paraswitch = False

            # Segmented Body Notes
            if bodytype == 'segmented':
                if creature.get('thorax'):
                    
                    line = choice(['%s body is %s three %s %s.' % (dchoice(ctitles,1,1),dchoice(t('dividewords')),dchoice(t('mainwords')),dchoice(t('segwordplur'))), \
                                          '%s has an insect-like, %s body structure.' % (dchoice(ctitles,1,1),dchoice(t('segadj'))), \
                                          '%s has three %s body %s.' % (dchoice(ctitles,1),dchoice(t('mainwords')),dchoice(t('segwordplur')))])
                    para2.append(line)

                elif creature.get('cephalothorax'):
                    line = choice(['%s body is %s two %s %s.' % (dchoice(ctitles,1,1),dchoice(t('dividewords')),dchoice(t('mainwords')),dchoice(t('segwordplur'))), \
                                          '%s has an arthropod-like, %s body structure.' % (dchoice(ctitles,1),dchoice(t('segadj'))), \
                                          '%s has two %s body %s.' % (dchoice(ctitles,1),dchoice(t('mainwords')),dchoice(t('segwordplur')))])
                    para2.append(line)

                elif creature.get('body'):
                    line = choice(['%s body consists of a single %s %s.' % (dchoice(ctitles,1,1),dchoice(t('mainwords')),dchoice(t('segwordsing'))), \
                                          '%s body is simple, consisting of a single %s.' % (dchoice(ctitles,1,1),dchoice(t('mainwords')),dchoice(t('segwordsing')))])
                    para2.append(line)

            paraswitch = True

            # Thorax
            if creature.get('thorax'):
                chosentraits = self.ptraits(creature,'thorax')
                line = choice(['%s has %s thorax.' % (dchoice(ctitles,1),p.a(p.join(chosentraits))), \
                                      '%s thorax is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                para2.append(line)

            # Cephalothorax
            if creature.get('cephalothorax'):
                chosentraits = self.ptraits(creature,'cephalothorax')
                line = choice(['%s has %s cephalothorax.' % (dchoice(ctitles,1),p.a(p.join(chosentraits))), \
                                      '%s cephalothorax is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                para2.append(line)

            # Abdomen
            if creature.get('abdomen'):
                chosentraits = self.ptraits(creature,'abdomen')
                line = choice(['%s has %s abdomen.' % (dchoice(ctitles,1),p.a(p.join(chosentraits))), \
                                      '%s abdomen is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                para2.append(line)

            paraswitch = False

            # Torso
            if creature.get('torso'):
                chosentraits = self.ptraits(creature,'torso')
                line = choice(['%s has %s torso.' % (dchoice(ctitles,1),p.a(p.join(chosentraits))), \
                                      '%s torso is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                para2.append(line)

            paraswitch = True

            # Hips
            if creature.get('hips'):
                chosentraits = self.ptraits(creature,'hips')
                line = choice(['%s has %s hips.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                      '%s hips are %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                para2.append(line)

            # Non-Segmented Body
            if creature.get('body'):
                chosentraits = self.ptraits(creature,'body')
                line = choice(['%s has %s body.' % (dchoice(ctitles,1),p.a(p.join(chosentraits))), \
                                      '%s body is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                para2.append(line)

            # Determine Connecting Point of Limbs

            if creature.get('cephalothorax'):
                upperlimbseg = 'cephalothorax'
                lowerlimbseg = 'cephalothorax'
            elif creature.get('thorax'):
                upperlimbseg = 'thorax'
                lowerlimbseg = 'cephalothorax'
            elif creature.get('torso'):
                upperlimbseg = 'torso'
                lowerlimbseg = 'hips'
            else:
                upperlimbseg = 'body'
                lowerlimbseg = 'body'

            # Tentacles
            if creature.get('tentacles'):
                chosentraits = self.ptraits(creature,'tentacles')
                line = choice(['%s has %s %s tentacles %s from its %s.' % \
                                      (dchoice(ctitles,1),p.number_to_words(creature['tentacles']),p.join(chosentraits), \
                                       dchoice(t('appextingwords')),upperlimbseg), \
                                      '%s %s tentacles are %s; they %s from its %s.' % \
                                      (dchoice(ctitles,1,1),p.number_to_words(creature['tentacles']),p.join(chosentraits), \
                                       dchoice(t('appextwords')),upperlimbseg)])
                para2.append(line)

            # Arms
            if creature.get('arms'):
                chosentraits = self.ptraits(creature,'arms')
                line = choice(['%s has %s %s arms.' % (dchoice(ctitles,1),p.number_to_words(creature['arms']), \
                                                                             p.join(chosentraits)), \
                                      '%s %s arms are %s.' % (dchoice(ctitles,1,1),p.number_to_words(creature['arms']), \
                                                                                   p.join(chosentraits))])
                para2.append(line)

                chosentraits = self.ptraits(creature,handtype)
                line = choice(['%s has %s %s.' % (dchoice(ctitles,1),p.join(chosentraits),handtype), \
                                      '%s %s are %s.' % (dchoice(ctitles,1,1),handtype,p.join(chosentraits))])
                para2[-1] += ' ' + line

                if handtype == 'hands':
                    chosentraits = self.ptraits(creature,'digits')
                    chosentraits2 = self.ptraits(creature,'claws')
                    line = choice(['%s has %s %s %s per hand that %s in %s %s.' % (dchoice(ctitles,1),p.number_to_words(creature['handdigits']),p.join(chosentraits),p.plural_noun(dchoice(t('digitwords'))), \
                                                                                          dchoice(t('endwords')),p.join(chosentraits2),p.plural_noun(dchoice(t('clawwords')))), \
                                          '%s %s %s %s in %s %s. It has %s %s per hand.' % (dchoice(ctitles,1,1),p.join(chosentraits),p.plural_noun(dchoice(t('digitwords'))),
                                                                                            dchoice(t('endwords')),p.join(chosentraits2),p.plural_noun(dchoice(t('clawwords'))), \
                                                                                            p.number_to_words(creature['handdigits']),p.plural_noun(dchoice(t('digitwords'))))])
                    para2[-1] += ' ' + line

            # Legs
            if creature.get('legs'):
                if creature['legs'] == 2:
                    chosentraits = self.ptraits(creature,'midlegs')
                    line = choice(['%s is a biped. Its legs are %s.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                          '%s two legs are %s.' % (dchoice(ctitles,1,1),p.join(chosentraits)), \
                                          '%s has two %s legs.' % (dchoice(ctitles,1),p.join(chosentraits))])
                    para2.append(line)

                    chosentraits = self.ptraits(creature,midexttype)
                    line = choice(['%s has %s %s.' % (dchoice(ctitles,1),p.join(chosentraits),midexttype), \
                                          '%s %s are %s.' % (dchoice(ctitles,1,1),midexttype,p.join(chosentraits))])
                    para2[-1] += ' ' + line
                    if creature.get('midextdigits'):
                        chosentraits = self.ptraits(creature,'digits')
                        chosentraits2 = self.ptraits(creature,'claws')
                        line = choice(['%s has %s %s toes per %s that %s in %s %s.' % \
                                              (dchoice(ctitles,1),p.number_to_words(creature['midextdigits']),p.join(chosentraits),p.singular_noun(midexttype), \
                                               dchoice(t('endwords')),p.join(chosentraits2),p.plural_noun(dchoice(t('clawwords')))), \
                                              '%s %s toes %s in %s %s. It has %s toes per %s.' % \
                                              (dchoice(ctitles,1,1),p.join(chosentraits), \
                                               dchoice(t('endwords')),p.join(chosentraits2),p.plural_noun(dchoice(t('clawwords'))), \
                                               p.number_to_words(creature['midextdigits']),p.singular_noun(midexttype))])
                        para2[-1] += ' ' + line

                elif creature['legs'] == 4:
                    chosentraits = self.ptraits(creature,'frontlegs')
                    line = choice(['%s is a quadruped. Its front legs are %s.' % (dchoice(ctitles,1),p.join(chosentraits)), \
                                          'It has four legs. %s front legs are %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                    para2.append(line)

                    chosentraits = self.ptraits(creature,'backlegs')
                    line = '%s back legs are %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))
                    para2[-1] += ' ' + line

                    if frontexttype == backexttype:
                        chosentraits = self.ptraits(creature,frontexttype)
                        line = choice(['%s four %s are %s' % (dchoice(ctitles,1,1),frontexttype,p.join(chosentraits)), \
                                              '%s %s are %s' % (dchoice(ctitles,1,1),frontexttype,p.join(chosentraits))])
                        para2[-1] += ' ' + line
                        if creature.get('frontextdigits'):
                            if frontextdigits == backextdigits:
                                chosentraits = self.ptraits(creature,'digits')
                                chosentraits2 = self.ptraits(creature,'claws')
                                line = '; each has %s %s toes %s in %s %s.' % (p.number_to_words(creature['frontextdigits']), p.join(chosentraits), \
                                                                               dchoice(t('endingwords')),p.a(p.join(chosentraits2)), \
                                                                               dchoice(t('clawwords')))
                                para2[-1] += line
                            else:
                                chosentraits = self.ptraits(creature,'digits')
                                chosentraits2 = self.ptraits(creature,'claws')
                                line = '. Its front %s have %s toes and its back have %s; each toe %s in %s %s.' % \
                                       (frontexttype,p.number_to_words(creature['frontextdigits']),p.number_to_words(creature['backextdigits']), \
                                        dchoice(t('endwords')) + 's',p.a(p.join(chosentraits2)),dchoice(t('clawwords')))
                                para2[-1] += line
                        else:
                            para2[-1] += '.'
                    else:
                        chosentraits = self.ptraits(creature,frontexttype)
                        line = choice(['%s front legs have %s %s.' % (dchoice(ctitles,1,1),p.join(chosentraits),frontexttype), \
                                              '%s has %s %s on its front legs.' % (dchoice(ctitles,1),p.join(chosentraits),frontexttype)])
                        para2[-1] += ' ' + line
                        if not frontexttype in ['hooves','pincers','claws']:
                            chosentraits = self.ptraits(creature,'digits')
                            chosentraits2 = self.ptraits(creature,'claws')
                            line = choice(['Each %s has %s %s toes that %s in %s %s.' % (p.singular_noun(frontexttype),p.number_to_words(creature['frontextdigits']), \
                                                                                        p.join(chosentraits),dchoice(t('endwords')),p.join(chosentraits2),dchoice(t('clawwords')) + 's'), \
                                                  'They have %s %s toes %s in %s %s.' % (p.number_to_words(creature['frontextdigits']),p.join(chosentraits), \
                                                                                                dchoice(t('endingwords')),p.join(chosentraits2),dchoice(t('clawwords')) + 's')])
                            para2[-1] += ' ' + line
                            
                        chosentraits = self.ptraits(creature,backexttype)
                        line = choice(['%s back legs have %s %s.' % (dchoice(ctitles,1,1),p.join(chosentraits),backexttype), \
                                              '%s has %s %s on its back legs.' % (dchoice(ctitles,1),p.join(chosentraits),backexttype)])
                        para2[-1] += ' ' + line
                        if not backexttype in ['hooves','claws','pincers']:
                            chosentraits = self.ptraits(creature,'digits')
                            chosentraits2 = self.ptraits(creature,'claws')
                            line = choice(['Each %s has %s %s toes that %s in %s %s.' % (p.singular_noun(backexttype),p.number_to_words(creature['backextdigits']), \
                                                                                        p.join(chosentraits),dchoice(t('endwords')),p.join(chosentraits2),dchoice(t('clawwords')) + 's'), \
                                                  'They have %s %s toes %s in %s %s.' % (p.number_to_words(creature['backextdigits']),p.join(chosentraits), \
                                                                                                dchoice(t('endingwords')),p.join(chosentraits2),dchoice(t('clawwords')) + 's')])
                            para2[-1] += ' ' + line

                elif creature['legs'] > 4:
                    chosentraits = self.ptraits(creature,'frontlegs')
                    line = choice(['%s has %s legs. Its front legs are %s.' % (dchoice(ctitles,1),p.number_to_words(legs),p.join(chosentraits)), \
                                          '%s has a total of %s legs. Its front two legs are %s.' % (dchoice(ctitles,1),p.number_to_words(legs),p.join(chosentraits))])
                    para2.append(line)

                    chosentraits = self.ptraits(creature,'backlegs')
                    line = '%s back two legs are %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))
                    para2[-1] += ' ' + line

                    chosentraits = self.ptraits(creature,'midlegs')
                    line = '%s middle %s legs are %s.' % (dchoice(ctitles,1,1),p.number_to_words(legs - 4),p.join(chosentraits))
                    para2[-1] += ' ' + line

                    chosentraits = self.ptraits(creature,frontexttype)
                    line = choice(['%s front legs have %s %s.' % (dchoice(ctitles,1,1),p.join(chosentraits),frontexttype), \
                                          '%s has %s %s on its front legs.' % (dchoice(ctitles,1),p.join(chosentraits),frontexttype)])

                    para2[-1] += ' ' + line
                    if frontexttype not in ['hooves','pincers','claws']:
                        chosentraits = self.ptraits(creature,'digits')
                        chosentraits2 = self.ptraits(creature,'claws')
                        line = choice(['Each %s has %s %s toes that %s in %s %s.' % (p.singular_noun(frontexttype),p.number_to_words(creature['frontextdigits']), \
                                                                                    p.join(chosentraits),dchoice(t('endwords')),p.join(chosentraits2),dchoice(t('clawwords')) + 's'), \
                                              'They have %s %s toes %s in %s %s.' % (p.number_to_words(creature['frontextdigits']),p.join(chosentraits), \
                                                                                            dchoice(t('endingwords')),p.join(chosentraits2),dchoice(t('clawwords')) + 's')])
                        para2[-1] += ' ' + line

                    chosentraits = self.ptraits(creature,midexttype)
                    line = choice(['%s middle %s legs have %s %s.' % (dchoice(ctitles,1,1),p.number_to_words(legs - 4),p.join(chosentraits),midexttype), \
                                          '%s has %s %s on its middle %s legs.' % (dchoice(ctitles,1),p.join(chosentraits),midexttype,p.number_to_words(legs - 4))])

                    para2[-1] += ' ' + line
                    if midexttype not in ['hooves','pincers','claws']:
                        chosentraits = self.ptraits(creature,'digits')
                        chosentraits2 = self.ptraits(creature,'claws')
                        line = choice(['Each %s has %s %s toes that %s in %s %s.' % (p.singular_noun(midexttype),p.number_to_words(creature['midextdigits']), \
                                                                                    p.join(chosentraits),dchoice(t('endwords')),p.join(chosentraits2),dchoice(t('clawwords')) + 's'), \
                                              'They have %s %s toes %s in %s %s.' % (p.number_to_words(creature['midextdigits']),p.join(chosentraits), \
                                                                                            dchoice(t('endingwords')),p.join(chosentraits2),dchoice(t('clawwords')) + 's')])
                        para2[-1] += ' ' + line
                        
                    chosentraits = self.ptraits(creature,backexttype)
                    line = choice(['%s back legs have %s %s.' % (dchoice(ctitles,1,1),p.join(chosentraits),backexttype), \
                                          '%s has %s %s on its back legs.' % (dchoice(ctitles,1),p.join(chosentraits),backexttype)])
                    para2[-1] += ' ' + line
                    if backexttype not in ['hooves','pincers','claws']:
                        chosentraits = self.ptraits(creature,'digits')
                        chosentraits2 = self.ptraits(creature,'claws')
                        line = choice(['Each %s has %s %s toes that %s in %s %s.' % (p.singular_noun(backexttype),p.number_to_words(creature['backextdigits']), \
                                                                                    p.join(chosentraits),dchoice(t('endwords')),p.join(chosentraits2),dchoice(t('clawwords')) + 's'), \
                                              'They have %s %s toes %s in %s %s.' % (p.number_to_words(creature['backextdigits']),p.join(chosentraits), \
                                                                                            dchoice(t('endingwords')),p.join(chosentraits2),dchoice(t('clawwords')) + 's')])
                        para2[-1] += ' ' + line
                              
            # Wings
            if creature.get('wings'):
                chosentraits = self.ptraits(creature,'wings')
                line = choice(['%s has %s %s wings %s from its %s.' % \
                                      (dchoice(ctitles,1),p.number_to_words(creature['wings']),p.join(chosentraits), \
                                       dchoice(t('appextingwords')),upperlimbseg), \
                                      '%s %s wings are %s; they %s from its %s.' % \
                                      (dchoice(ctitles,1,1),p.number_to_words(creature['wings']),p.join(chosentraits), \
                                       dchoice(t('appextwords')),upperlimbseg)])
                para2.append(line)

                chosentraits = self.ptraits(creature,creature['wing-cover'])
                line = '%s wings are covered in %s %s.' % (dchoice(ctitles,1,1),p.join(chosentraits),creature['wing-cover'])
                para2[-1] += ' ' + line

            # Shell
            if creature.get('shell'):
                chosentraits = self.ptraits(creature,'shell')
                line = choice(['%s has %s shell covering its body.' % \
                                      (dchoice(ctitles,1),p.a(p.join(chosentraits))), \
                                      '%s shell is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits))])
                para2.append(line)

            # Tails
            if creature.get('tails'):
                chosentraits = self.ptraits(creature,'tails')
                if tails > 1:
                    line = choice(['%s %s tails are %s.' % (dchoice(ctitles,1,1),p.number_to_words(creature['tails']),p.join(chosentraits)), \
                                          '%s has %s %s tails.' % (dchoice(ctitles,1),p.number_to_words(creature['tails']),p.join(chosentraits))])
                else:
                    line = choice(['%s tail is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits)), \
                                          '%s has a %s tail.' % (dchoice(ctitles,1),p.join(chosentraits))])
                
                para2.append(line)

            # Body Covering
            if creature.get('type-cover') and creature.get('type-cover') != 'skin':

                if randrange(1,6) == 1:
                    covermod = True
                else:
                    covermod = False

                if cover == 'scales':
                    colorlist = [('green',.5),('blue',.05),('black',.05),('brown',.1),('orange',.02),('purple',.02), \
                                 ('red',.05),('white',.05),('gray',.05),('silver',.02),('tan',.05),('yellow',.04)]
                    if covermod:
                        covermod = choice(t('pale') + t('bright') + t('dull') + t('neon') + t('flecked') + t('striped') + \
                                                  t('patched') + t('spotted'))
                                                  
                elif cover == 'fur':
                    colorlist = [('brown',.4),('gray',.1),('black',.2),('silver',.05),('tan',.1),('yellow',.05), \
                                 ('white',.1)]
                    if covermod:
                        covermod = choice(t('pale') + t('bright') + t('dull') + t('striped') + t('patched') + t('spotted'))

                elif cover == 'feathers':
                    colorlist = [('green',.03),('blue',.05),('black',.05),('brown',.15),('orange',.05),('purple',.05), \
                                 ('red',.1),('white',.2),('gray',.2),('silver',.02),('tan',.05),('yellow',.05)]
                    if covermod:
                        covermod = choice(t('pale') + t('bright') + t('dull') + t('striped') + t('spotted') + t('flecked') + \
                                                  t('tipped') + t('patched'))

                elif cover == 'exoskeleton':
                    colorlist = [('green',.03),('blue',.03),('black',.3),('brown',.3),('orange',.02),('purple',.02), \
                                 ('red',.05),('white',.05),('gray',.05),('silver',.05),('tan',.05),('yellow',.05)]
                    if covermod:
                        covermod = choice(t('pale') + t('bright') + t('dull') + t('striped') + t('spotted') + t('flecked') + \
                                                  t('patched'))

                skincolorlist = [('black',.02),('gray',.02),('tan',.95),('white',.01)]
                
                chosentraits = self.ptraits(creature,cover)
                if cover == 'exoskeleton':
                    line = choice(['%s has %s %s.' % (dchoice(ctitles,1),p.a(p.join(chosentraits)),cover), \
                                          '%s %s is %s.' % (dchoice(ctitles,1,1),cover,p.join(chosentraits))])
                    color = choice(t(wchoice(colorlist)))
                    if covermod:
                        if covermod in t('striped') + t('spotted') + t('flecked') + t('patched') + t('tipped') and cover != 'skin':
                            while True:
                                color2 = choice(t(wchoice(colorlist)))
                                if color2 != color:
                                    break
                            colorline = choice(['%s %s is %s %s with %s.' % (dchoice(ctitles,1,1),cover,color,covermod,color2), \
                                                       'It is %s %s with %s.' % (color,covermod,color2)])
                        else:
                            colorline = choice(['%s %s is %s %s.' % (dchoice(ctitles,1,1),cover,covermod,color), \
                                                       'It is %s %s.' % (covermod,color)])
                    else:
                        colorline = choice(['%s %s is %s.' % (dchoice(ctitles,1,1),cover,color), \
                                                   'It is %s.' % (color)])

                # Determine Fur/Scale/Feather Cover Areas
                
                elif cover != 'skin':
                    if cover == 'fur':
                        cphrase1 = 'It is'
                        cphrase2 = 'is'
                    else:
                        cphrase1 = 'They are'
                        cphrase2 = 'are'
                    color = choice(t(wchoice(colorlist)))
                    if covermod:
                        if covermod in t('striped') + t('spotted') + t('flecked') + t('patched') + t('tipped'):
                            while True:
                                color2 = choice(t(wchoice(colorlist)))
                                if color2 != color:
                                    break
                            colorline = choice(['%s %s %s %s %s with %s.' % (dchoice(ctitles,1,1),cover,cphrase2,color,covermod,color2), \
                                                       '%s %s %s with %s.' % (cphrase1,color,covermod,color2)])
                        else:
                            colorline = choice(['%s %s %s %s %s.' % (dchoice(ctitles,1,1),cover,cphrase2,covermod,color), \
                                                       '%s %s %s.' % (cphrase1,covermod,color)])
                    else:
                        colorline = choice(['%s %s %s %s.' % (dchoice(ctitles,1,1),cover,cphrase2,color), \
                                                   '%s %s.' % (cphrase1,color)])
                    
                    if randrange(1,7) < 3:
                        calist = []
                        if creature.get('torso'):
                            torsocover = wchoice([('its entire torso',.5),('the front of its torso',.15),('the back of its torso',.15),(None,.2)])
                            if torsocover:
                                calist.append(torsocover)
                            tummycover = wchoice([('its belly',.3),('its upper belly',.1),('its lower belly',.1),(None,.5)])
                            if tummycover:
                                calist.append(tummycover)
                        if creature.get('abdomen'):
                            abdomencover = wchoice([('its entire abdomen',.5),('the front of its abdomen',.15),('the back of its abdomen',.15),(None,.2)])
                            if abdomencover:
                                calist.append(abdomencover)
                            if creature.get('thorax'):
                                thoraxcover = wchoice([('its entire thorax',.5),('the front of its thorax',.15),('the back of its thorax',.15),(None,.2)])
                                if thoraxcover:
                                    calist.append(thoraxcover)
                            if creature.get('cephalothorax'):
                                cephalocover = wchoice([('its entire cephalothorax',.5),('the top of its cephalothorax',.05),('the bottom of its cephalothorax',.05), \
                                                        ('the sides of its cephalothorax',.05),('the top and sides of its cephalothorax',.05), \
                                                        ('the bottom and sides of its cephalothorax',.05),(None,.25)])
                                if cephalocover:
                                    calist.append(cephalocover)
                        if creature.get('body'):
                            bodycover = wchoice([('the top of its body',.15),('the bottom of its body',.15),('the sides of its body',.15), \
                                                 ('the top and sides of its body',.15),('the bottom and sides of its body',.15),(None,.25)])
                            if bodycover:
                                calist.append(bodycover)
                        if creature.get('head'):
                            if randrange(1,3) == 1:
                                headcover = wchoice([('the top',.15),('the sides',.15),('the back',.15), \
                                                     ('the top and sides',.1),('the back and sides',.1), \
                                                     (None,.35)]) + 'of its head'
                            else:
                                headcover = 'its head'
                            if headcover:
                                calist.append(headcover)
                            if randrange(1,3) == 1:
                                facecover = wchoice([('the sides of its face',.15),('around its eyes and mouth',.15), ('its forehead',.15), ('around its %s' % jawtype,.15), \
                                                     (None,.4)])
                            else:
                                facecover = 'its face'
                                if facecover:
                                    calist.append(facecover)
                        if legs > 0:
                            legscover = wchoice([('its legs',.4),('the tops of its legs',.1),('the sides of its legs',.1),('the front of its legs',.1),('the back of its legs',.1), \
                                                 (None,.2)])
                            if legscover:
                                calist.append(legscover)
                        if arms > 0:
                            armscover = wchoice([('its arms',.4),('the tops of its arms',.1),('the sides of its arms',.1),('the front of its arms',.1),('the back of its arms',.1), \
                                                 (None,.2)])
                            if armscover:
                                calist.append(armscover)
                        if tails > 0:
                            tailscover = wchoice([('the tip of its tail',.1),('the base of its tail',.1),('its tail',.55),(None,.25)])
                            if tailscover:
                                calist.append(tailscover)
                        
                    else:
                        calist = ['its entire body']

                    if cover == 'fur':
                        coverword = 'covers'
                    else:
                        coverword = 'cover'

                    line = choice(['%s %s %s %s %s.' % (dchoice(ctitles,1,1),p.join(chosentraits),cover,coverword,p.join(calist)), \
                                          '%s has %s %s that %s %s.' % (dchoice(ctitles,1),p.join(chosentraits),cover,coverword,p.join(calist))])

                    line += ' ' + colorline

                para2.append(line)
                    
            elif creature.get('type-cover') == 'skin':
                skincolorlist = [('black',.02),('gray',.02),('tan',.95),('white',.01)]

            if creature.get('skin'):

                try:
                    color = choice(t(wchoice(skincolorlist)))
                except UnboundLocalError:
                    print creature
                covermod = False
                if randrange(1,6) == 1:
                    covermod = choice(t('pale') + t('bright') + t('dull'))
                if covermod:
                    skincolorline = choice(['%s skin is %s %s.' % (dchoice(ctitles,1,1),covermod,color), \
                                               'It is %s %s.' % (covermod,color)])
                else:
                    skincolorline = choice(['%s skin is %s.' % (dchoice(ctitles,1,1),color), \
                                                   'It is %s.' % (color)])

                chosentraits2 = self.ptraits(creature,'skin')
                    
                line = choice(['%s has %s skin.' % (dchoice(ctitles,1),p.join(chosentraits2)),
                                             '%s skin is %s.' % (dchoice(ctitles,1,1),p.join(chosentraits2))])
                line += ' ' + skincolorline

                para2.append(line)

                # Creature Description Generation Complete!

                # Adjust stats according to morphological traits.

                mods = {}
                mods['STR'] = 0
                mods['AGI'] = 0
                mods['END'] = 0
                mods['INT'] = 0
                mods['WIL'] = 0
                mods['WIT'] = 0
                mods['SPD'] = 0
                mods['AP'] = 0
                mods['DEF'] = 0
                mods['ATK'] = 0
                mods['AC'] = 0
                mods['HP'] = 0

                cover = creature['type-cover']
        
                if cover == 'skin':
                    creature['CAC'] = 5
                elif cover == 'feathers':
                    creature['CAC'] = 5
                elif cover == 'fur':
                    creature['CAC'] = 10
                    mods['SPD'] = -2
                elif cover == 'scales':
                    creature['CAC'] = 15
                    mods['SPD'] = -4
                elif cover == 'exoskeleton':
                    creature['CAC'] = 20
                    mods['SPD'] = -6

                for item in creature['traits'].items():
                    for value in item[1]:
                        modtuples = bodydict[item[0]][value[0]][3]
                        for mod in modtuples:
                            if value[1] > 0:
                                if value[1] == 1:
                                    value[1] = 1.5
                                mods[mod[0]] += (int(mod[1] * value[1]))
                            else:
                                mods[mod[0]] += mod[1]

                creature['mods'] = mods
                
                creature['description'] = ' '.join(para1) + '\n\n' + ' '.join(para2) + '\n\n' + ' '.join(para3)
                if sizecat > 4:
                    creaturechar = creaturename[0].upper()
                else:
                    creaturechar = creaturename[0].lower()
                creature['creaturechar'] = creaturechar
                charcolor = libtcod.Color(randrange(0,256),randrange(0,256),randrange(0,256))
                creature['charcolor'] = charcolor
                wcreaturedict[creaturename] = creature

        # Spirits Gen

        wgtext = 'Creating\nspirits...'
        CurText = FadeText(wgtext, 1, 9, con=wswindow, speed=25).start()

        wspiritdict = {}

        wgtext = 'Establishing\nbiomes... this\nmay take a\nfew moments.'
        CurText = FadeText(wgtext, 1, 12, con=wswindow, speed=25).start()

        checklist = ['Shrubland','Heathland','Marshland','Cacti Forest','Broadleaf Forest','Deciduous Forest','Mixed Forest', \
                     'Coniferous Forest','Evergreen Forest','Tropical Forest','Swamp','Desert','Cave','Beach','River','Highland', \
                     'Mountain','Plain','Tundra','Savannah','Glacier','River Bank','Pond','Ocean','Lake','Lakeshore']

        wbiomedict = {}
        for x in range(MAP_WIDTH):
            for y in range(MAP_HEIGHT):
                wbiomedict['%s,%s' % (x,y)] = []
        for check in checklist:
            vars()[check] = []
            for x in range(MAP_WIDTH):
                for y in range(MAP_HEIGHT):
                    if queryTile(x, y, [check]):
                        vars()[check] += [[x,y]]
                        wbiomedict['%s,%s' % (x,y)] += [check]

        wgtext = 'Finished!'
        CurText = FadeText(wgtext, 1, 17, con=wswindow, speed=25).start()

        wgtext = 'Dispersing\ncreatures...'
        CurText = FadeText(wgtext, 1, 19, con=wswindow, speed=25).start()

        for creature in wcreaturedict.values():
            creature['extinct'] = False
            startposlist = []
            for biome in creature['biomes']: startposlist += vars()[biome]

            if creature['tempzone'] == 'Tropical':
                startposlist = filter(lambda pos: pos[1] > (((MAP_HEIGHT / 4) * 3) + tivar[pos[0]]),startposlist)
            elif creature['tempzone'] == 'Arctic':
                startposlist = filter(lambda pos: (float(pos[1]) / MAP_HEIGHT * 102) < ivar[pos[0]],startposlist)
            elif creature['tempzone'] == 'Temperate':
                startposlist = filter(lambda pos: ((float(pos[1]) / MAP_HEIGHT * 102) > ivar[pos[0]]) and \
                                      (pos[1] < (((MAP_HEIGHT / 4) * 3) + tivar[pos[0]])),startposlist)

            if creature['sphere'] == 'Aquatic':
                startposlist = filter(lambda pos: wheightdict['%s,%s' % (pos[0],pos[1])] < 152,startposlist)
            else:
                startposlist = filter(lambda pos: wheightdict['%s,%s' % (pos[0],pos[1])] > 151,startposlist)
            
            try:
                startpos = choice(startposlist)
            except IndexError:
                creature['extinct'] = True
                continue
            creature['startpos'] = startpos
            libtcod.console_print_ex(wgwindow, startpos[0], startpos[1], libtcod.BKGND_NONE, libtcod.LEFT, creature['creaturechar'])
            libtcod.console_set_char_foreground(wgwindow, startpos[0], startpos[1], creature['charcolor'])

        wgtext = 'Finished!'
        CurText = FadeText(wgtext, 1, 22, con=wswindow, speed=25).start()


        wgtext = 'Spreading\ncreatures...\nThis may take\nquite a while...'
        CurText = FadeText(wgtext, 1, 24, con=wswindow, speed=25).start()

        cpopdict = {}

        # Initial Population
                
        for creature in wcreaturedict.values():
            name = creature['name']
            if creature['extinct']:
                continue
            startpos = creature['startpos']
            cpopdict[name] = [(startpos,10)]

        # Main creature spread algorithm

        poslist = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
        checkdict = {}
        waitingdict = {}
        spreaddict = {}
        stepcount = 0

        for item in cpopdict.items():
            startpos = item[1][0][0]
            name = item[0]
            checkdict['%s,%s' % (startpos[0],startpos[1]) + ':%s' % name] = True
            waitingdict['%s,%s' % (startpos[0],startpos[1]) + ':%s' % name] = [1,True]

        while True:
            key = libtcod.Key()
            mouse = libtcod.Mouse()
            handle_keys()
            stepcount += 1
            if stepcount > 100:
                break
            libtcod.console_print_ex(wswindow, 9, 29, libtcod.BKGND_NONE, libtcod.CENTER, 'Step %s/100' % stepcount)
            for item in waitingdict.items():
                if item[1][0] > 1:
                    waitingdict[item[0]] = [item[1][0] - 1,item[1][1]]
                else:
                    spreaddict[item[0]] = item[1][1]
                    waitingdict.pop(item[0])

            for item in spreaddict.items():
                name = item[0].split(':')[1]
                if len(cpopdict[name]) > 2000:
                    spreaddict.pop(item[0])
                    continue
                curpos = item[0].split(':')[0].split(',')
                curpos = [int(curpos[0]),int(curpos[1])]
                if item[1]:
                    cpopdict[name].append((curpos,2))
                    libtcod.console_set_default_foreground(wgwindow, wcreaturedict[name]['charcolor'])
                    libtcod.console_print_ex(wgwindow, curpos[0], curpos[1], libtcod.BKGND_NONE, libtcod.LEFT, wcreaturedict[name]['creaturechar'])
                for pos in poslist:
                    habitable = False
                    newpos = [curpos[0] - pos[0],curpos[1] - pos[1]]
                    try:
                        checkdict['%s,%s' % (newpos[0],newpos[1]) + ':%s' % name]
                        continue
                    except KeyError:
                        checkdict['%s,%s' % (newpos[0],newpos[1]) + ':%s' % name] = True
                        if not ((newpos[0] > 0 and newpos[0] < MAP_WIDTH) and \
                           (newpos[1] > 0 and newpos[1] < MAP_HEIGHT)):
                            continue
                        for biome in wcreaturedict[name]['biomes']:
                            if biome in wbiomedict['%s,%s' % (newpos[0],newpos[1])]:
                                habitable = True
                        if habitable:
                            spreadcheck = (10 - wcreaturedict[name]['repofreq']) / 2
                            waitingdict['%s,%s' % (newpos[0],newpos[1]) + ':%s' % name] = [spreadcheck + randrange(0,3),True]
                        else:
                            spreadcheck = ((10 - wcreaturedict[name]['repofreq']) / 2) * 3
                            waitingdict['%s,%s' % (newpos[0],newpos[1]) + ':%s' % name] = [spreadcheck + randrange(0,3),False]
                spreaddict.pop(item[0])

        libtcod.console_clear(wswindow)

        libtcod.console_set_default_foreground(wswindow, hcolor)
        libtcod.console_print_ex(wswindow, 9, ((SCREEN_HEIGHT - 2) / 2) - 9, libtcod.BKGND_NONE, libtcod.CENTER, 'Creature gen\nfinished!')

        libtcod.console_set_default_foreground(wswindow, libtcod.white)
        libtcod.console_print_ex(wswindow, 9, ((SCREEN_HEIGHT - 2) / 2) - 6, libtcod.BKGND_NONE, libtcod.CENTER, 'To move on to\nhistory gen,\ntype \'h\'.\n\nOtherwise,\npress \'g\' to\ngenerate a\nnew map.')
            
        WorldGoing = False
        CreatureDone = True
        
        genbutton = ButtonBox(wswindow, 6, ((SCREEN_HEIGHT - 2) / 2) + 4, 'New Map', 'g')
        namebutton = ButtonBox(wswindow, 4, ((SCREEN_HEIGHT - 2) / 2) + 8, 'History Gen', 'h')
        
        del self

####################################
# XII. History Generation          #
####################################

class WorldHistory(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)

    def run(self):
        global SCREEN_HEIGHT, VIEW_HEIGHT, SCREEN_WIDTH, VIEW_WIDTH, wiwindow, \
               wgwindow, wswindow, worldmap, wheightdict, wfeaturedict, wgpic, \
               NoKeys, WorldGoing, HistoryDone, woceandict, wlakedict, \
               wlakedict, wtundradict, wcavedict, wriverdict, wlangdict, PLang, \
               wcitydict, wvillagedict, wcastledict, year, wcivdict, wcreaturedict, \
               wspiritdict, wgoddict, wplainsdict, wswampdict, wglacierdict, ButtonList, \
               wtexturedict, wbiomedict, MouseLock, wgcoldict, wmountaindict

        WorldGoing = True
        
        DrawWorld(wgwindow, cities = False)

        libtcod.console_set_default_foreground(wswindow, libtcod.white)
        libtcod.console_print_ex(wswindow, 9, 1, libtcod.BKGND_NONE, libtcod.CENTER, 'World History')

        libtcod.console_set_default_foreground(wswindow, hcolor)
        libtcod.console_print_ex(wswindow, 9, 3, libtcod.BKGND_NONE, libtcod.CENTER, '~*~*~*~')

        wgtext = 'Creating civs...'
        CurText = FadeText(wgtext, 1, 5, con=wswindow, speed=25).start()
        wcivdict = {}
        wcitydict = {}
        wvillagedict = {}
        wcastledict = {}
        wbattledict = {}
        wterritorydict = {}

        civnum = randrange(15,35)
        wcivdict['civnum'] = civnum
        civleft = civnum
        libtcod.console_set_default_foreground(wswindow, libtcod.white)
        time.sleep(2)
        
        while civleft > 0:
            time.sleep(.1)
            civleft -= 1
            libtcod.console_print_ex(wswindow, 9, 7, libtcod.BKGND_NONE, libtcod.CENTER, '(%s/%s)' % (civnum - civleft,civnum))

            # Civ Initialization
            
            language = MakeLang()
            name = MakeName(language)
            wcivdict[name] = language
            wcivdict[civnum - civleft] = name
            wcivdict[name + '-economy'] = 'placeholder'
            wcivdict[name + '-religion'] = 'placeholder'
            wcivdict[name + '-troops'] = randrange(100,500)
            wcivdict[name + '-population'] = randrange(100,2000) + wcivdict[name + '-troops']

            government = choice(['Tribe', 'Republic', 'Monarchy', 'Empire'])
            wcivdict[name + '-government'] = government
            if government == 'Tribe':
                title = choice(['The %s Tribe' % name, 'The %s' % name, 'The %s Clan' % name, name])
            elif government == 'Republic':
                title = choice(['The Council of %s' % name, 'The Republic of %s' % name, 'The %s Republic' % name, name])
            elif government == 'Monarchy':
                title = choice(['The Kingdom of %s' % name, name, 'The Principality of %s' % name, 'The Grand Duchy of %s' % name, 'The %s Sultanate' % name])
            elif government == 'Empire':
                title = choice(['The %s Empire' % name, 'The Holy %s Empire' % name, name, 'The Dominion of %s' % name])
            wcivdict[name + '-title'] = title

            # Civ Traits - (Lowest <--> Highest)

            wcivdict[name + '-militancy'] = randrange(1,11) + randrange(0,4)
            wcivdict[name + '-civility'] = 10 - wcivdict[name + '-militancy'] + randrange(0,4)
            wcivdict[name + '-technology'] = randrange(1,11) + randrange(0,4)
            wcivdict[name + '-magic'] = 10 - wcivdict[name + '-technology'] + randrange(0,4)
            wcivdict[name + '-commerce'] = randrange(1,11) + randrange(0,4)
            wcivdict[name + '-spirituality'] = 10 - wcivdict[name + '-commerce'] + randrange(0,4)
            
            a = randrange(50,256)
            b = randrange(50,256)
            c = randrange(50,256)
            wcivdict[name + '-civcol'] = libtcod.Color(a,b,c)
            wcivdict[name + '-civcol2'] = libtcod.Color(c / 2,b / 2,a / 2)
            
        wgtext = 'Placing civs...'
        CurText = FadeText(wgtext, 1, 9, con=wswindow, speed=25).start()

        civleft = civnum
        year = 1

        while civleft > 0:
            addciv = False
            time.sleep(.1)
            x = randrange(0,MAP_WIDTH)
            y = randrange(0,MAP_HEIGHT)
            if wmlev > wheightdict['%s,%s' % (x,y)] > 152:
                addciv = True
            if not addciv:
                continue
            civleft -= 1
            curciv = wcivdict[civnum - civleft]
            libtcod.console_set_default_foreground(wgwindow, libtcod.white)
            libtcod.console_set_default_background(wgwindow, wcivdict[curciv + '-civcol2'])
            name = MakeName(wcivdict[curciv])
            if wcivdict[curciv + '-population'] > 1000:
                libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(citychar)))
                wcitydict[name] = [[x,y],curciv,wcivdict[curciv + '-population'] - wcivdict[curciv + '-troops'],year]
            else:
                libtcod.console_print_ex(wgwindow, x, y, libtcod.BKGND_ALPHA(0.8), libtcod.LEFT, chr(DoChar(villagechar)))
                wvillagedict[name] = [[x,y],curciv,wcivdict[curciv + '-population'] - wcivdict[curciv + '-troops']]
            libtcod.console_print_ex(wswindow, 9, 11, libtcod.BKGND_NONE, libtcod.CENTER, '(%s/%s)' % (civnum - civleft,civnum))
            libtcod.console_print_ex(wgwindow, x, y - 2, libtcod.BKGND_ALPHA(0.6), libtcod.CENTER, wcivdict[curciv + '-title'])
            wcivdict[wcivdict[civnum - civleft] + '-startpos'] = [x,y]
            wcivdict[wcivdict[civnum - civleft] + '-territory'] = [[x,y]]
            wterritorydict['%s,%s' % (x,y)] = civnum - civleft

        wgtext = 'Spreading civs...\nThis may take\nquite a while.'
        CurText = FadeText(wgtext, 1, 13, con=wswindow, speed=25).start()

        for civ in range(1,civnum + 1):
            rlist = []
            for civ2 in range(1,wcivdict['civnum'] + 1):
                startrel = 40 - (abs(wcivdict[wcivdict[civ] + '-militancy'] - wcivdict[wcivdict[civ2] + '-militancy']) + \
                                 abs(wcivdict[wcivdict[civ] + '-technology'] - wcivdict[wcivdict[civ2] + '-technology']) + \
                                 abs(wcivdict[wcivdict[civ] + '-commerce'] - wcivdict[wcivdict[civ2] + '-commerce']))
                rlist.append('%s,%s' % (civ2,startrel))
            wcivdict[wcivdict[civ] + '-relations'] = rlist

        curposdict = {}
        waitingdict1 = {}
        waitingdict2 = {}
        checkeddict = {}
        poslist = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
        
        for civ in range(1,civnum + 1):
            waitingdict1[wcivdict[civ]] = []
            waitingdict2[wcivdict[civ]] = []
            curposdict[wcivdict[civ]] = [wcivdict[wcivdict[civ] + '-startpos']]
        
        year = 0
        stopyear = 1500
        curcivs = range(1,civnum + 1)
        
        while year <= stopyear:
            libtcod.console_print_ex(wswindow, 9, 17, libtcod.BKGND_NONE, libtcod.CENTER, 'Year %s' % year)
            
            for civ in curcivs:
                civname = wcivdict[civ]
                for pos in waitingdict1[civname]:
                    if waitingdict2['%s,%s' % (pos[0],pos[1])] == 0:
                        waitingdict1[civname].remove(pos)
                        curposdict[civname].append(pos)
                    else:
                        waitingdict2['%s,%s' % (pos[0],pos[1])] -= 1
                        
                for pos in curposdict[civname]:
                    if wheightdict['%s,%s' % (pos[0],pos[1])] > 151:
                        wterritorydict['%s,%s' % (pos[0],pos[1])] = civ
                        libtcod.console_set_char_background(wgwindow, pos[0], pos[1], wcivdict[civname + '-civcol'], libtcod.BKGND_ALPHA(0.8))
                        randnum = randrange(1,301)
                        if randnum in range(1,3):
                            settlename = MakeName(wcivdict[civname])
                            settlepop = randrange(100,1500)
                            libtcod.console_set_default_foreground(wgwindow, wcivdict[civname + '-civcol'])
                            wcivdict[civname + '-population'] = wcivdict[civname + '-population'] + settlepop
                            if settlepop > 999:
                                libtcod.console_print_ex(wgwindow, pos[0], pos[1], libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(citychar)))
                                wcitydict[settlename] = [pos,civname,settlepop,year]
                            else:
                                libtcod.console_print_ex(wgwindow, pos[0], pos[1], libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(villagechar)))
                                wvillagedict[settlename] = [pos,civname,settlepop,year]
                        elif randnum == 3:
                            castlename = MakeName(wcivdict[civname])
                            castlegarrison = randrange(50,500)
                            wcivdict[wcivdict[civ] + '-population'] = wcivdict[civname + '-population'] + castlegarrison
                            wcivdict[wcivdict[civ] + '-troops'] = wcivdict[civname + '-troops'] + castlegarrison
                            libtcod.console_set_default_foreground(wgwindow, wcivdict[civname + '-civcol'])
                            libtcod.console_print_ex(wgwindow, pos[0], pos[1], libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(castlechar)))
                            wcastledict[castlename] = [pos,civname,castlegarrison,year]

                    for curpos in map(lambda x: [pos[0] - x[0], pos[1] - x[1]],poslist):
                        try:
                            checkeddict['%s,%s' % (curpos[0],curpos[1])]
                            pass
                        except KeyError:
                            checkeddict['%s,%s' % (curpos[0],curpos[1])] = 1
                            try:
                                curposcheck = [wheightdict['%s,%s' % (curpos[0],curpos[1])],wfeaturedict['%s,%s' % (curpos[0],curpos[1])]]
                                if 180 > curposcheck[0] > 151:
                                    if 'd' in curposcheck[1]:
                                        wait = 2
                                    elif 's' in curposcheck[1]:
                                        wait = 1
                                    elif curposcheck[0] > 168:
                                        wait = 1
                                    else:
                                        wait = 0
                                    waitingdict1[civname].append(curpos)
                                    waitingdict2['%s,%s' % (curpos[0],curpos[1])] = wait
                                elif curposcheck[0] < 152:
                                    waitingdict1[civname].append(curpos)
                                    waitingdict2['%s,%s' % (curpos[0],curpos[1])] = 4
                            except KeyError:
                                continue

                    curposdict[civname].remove(pos)
            year += 10

        NoKeys = True

        wgtext = 'Finished!'
        CurText = FadeText(wgtext, 1, 19, con=wswindow, speed=25).start()

        time.sleep(1.0)

        while True:
            try:
                if init['WORLDGEN PICS'] == 'YES':
                    wgcpic = libtcod.image_from_console(wgwindow)
                    libtcod.image_save(wgcpic,'.\\image\\gfx\\worldgenpc.png')
                break
            except WindowsError:
                pass

        NoKeys = False

        savedict = {}
        
        savedict['PLang'] = PLang
        savedict['PName'] = PName
        savedict['worldname'] = worldname

        savedict['wtmapdict'] = wtmapdict
        savedict['wfeaturedict'] = wfeaturedict
        savedict['wheightdict'] = wheightdict
        savedict['wtexturedict'] = wtexturedict
        savedict['wriverdict'] = wriverdict
        savedict['wcavedict'] = wcavedict
        savedict['wpeakdict'] = wpeakdict
        savedict['wforestdict'] = wforestdict
        savedict['wdesertdict'] = wdesertdict
        savedict['wtundradict'] = wtundradict
        savedict['wgcoldict'] = wgcoldict
        savedict['wplainsdict'] = wplainsdict
        savedict['wswampdict'] = wswampdict
        savedict['wlakedict'] = wlakedict
        savedict['wisledict'] = wisledict
        savedict['woceandict'] = woceandict
        savedict['wglacierdict'] = wglacierdict
        savedict['wtempdict'] = wtempdict
        savedict['wmountaindict'] = wmountaindict
        savedict['wcivdict'] = wcivdict
        savedict['wcitydict'] = wcitydict
        savedict['wvillagedict'] = wvillagedict
        savedict['wcastledict'] = wcastledict
        savedict['wbattledict'] = wbattledict
        savedict['wterritorydict'] = wterritorydict
        savedict['wcreaturedict'] = wcreaturedict
        savedict['wbiomedict'] = wbiomedict

        savedict['rivchardict'] = rivchardict
        savedict['rivcoldict'] = rivcoldict
        savedict['rivbgdict'] = rivbgdict
        savedict['tribdict'] = tribdict
        savedict['wrivdirdict'] = wrivdirdict
        savedict['ivar'] = ivar

        savedict['MAP_HEIGHT'] = MAP_HEIGHT
        savedict['MAP_WIDTH'] = MAP_WIDTH
        savedict['RMAP_HEIGHT'] = RMAP_HEIGHT
        savedict['RMAP_WIDTH'] = RMAP_WIDTH

        libtcod.console_set_default_foreground(wswindow, hcolor)
        libtcod.console_print_ex(wswindow, 9, 21, libtcod.BKGND_NONE, libtcod.CENTER, 'History gen\nfinished!')

        libtcod.console_set_default_foreground(wswindow, libtcod.yellow)
        libtcod.console_print_ex(wswindow, 9, 24, libtcod.BKGND_NONE, libtcod.CENTER, 'Saving world -\nplease wait...')    

        NoKeys = True
        time.sleep(1.0)
        worldfile = open('.\\data\\world\\%s.sav' % worldname, 'wb')
        gc.disable()
        cPickle.dump(savedict, worldfile, -1)
        gc.enable()
        worldfile.close()
        NoKeys = False

        libtcod.console_set_default_foreground(wswindow, libtcod.yellow)
        libtcod.console_print_ex(wswindow, 9, 27, libtcod.BKGND_NONE, libtcod.CENTER, 'Done!')     

        libtcod.console_set_default_foreground(wswindow, libtcod.white)
        libtcod.console_print_ex(wswindow, 9, 29, libtcod.BKGND_NONE, libtcod.CENTER, 'World generation\nis done. To\nexit, press\nescape or\nright-click.')

        WorldGoing = False
        HistoryDone = True
        del self


####################################
# XIII. World Atlas                #
####################################

class WorldAtlas(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)

    def run(self):
        global playery, oplayery, wawindow, wswindow, DOSCREEN, wtmapdict, nation, \
               natnum, civrange, relswitch, civreldict, hoveropt, MenuSetting

        MenuList = []
        MenuSetting = 'WAMain'

        wlist = os.listdir('.\\data\\world')
        wlist = filter(lambda x: x[-4:] == '.sav', wlist)
        printline = 0
        if len(wlist) > 0:
            for save in wlist:
                wlist[printline] = save[0:-4]
                printline += 1
            playery,oplayery = 1,1
            self.atlasmenu = Menu(wswindow, 2, 4, wlist, title = 'Choose a World:', talign = 'center', tx = 9, ty = 2, \
                             MethodList = [(True,Atlas.loadWorld)], BMethodList = [Atlas.exitAtlas])
            self.atlasmenu.start()
        else:
            libtcod.console_print_ex(wswindow, 2, 4, libtcod.BKGND_NONE, libtcod.LEFT, 'No worlds are\nsaved.')

    def loadWorld(self):
        global MouseLock, Cursor, BTorch, init
        
        MouseLock = True
        wdictfile = open('.\\data\\world\\%s' % wlist[mplayery - 1] + '.sav','rb')
        gc.disable()
        wdict = cPickle.load(wdictfile)
        gc.disable()
        wdictfile.close()
        LoadWorld(wdict)        
        DrawWorld(wgwindow, cities = False)
        self.worldpic = libtcod.image_from_console(wgwindow)
        libtcod.image_scale(self.worldpic, (VIEW_WIDTH - 10) * 2, (VIEW_HEIGHT - 20) * 2)
        self.loadWorldScreen()
        MouseLock = False

    def loadWorldScreen(self):
        global MenuSetting, MenuList, playery, oplayery, bplayery, ButtonList

        bplayery = {}
        ButtonList = []
            
        libtcod.console_set_default_background(wawindow, libtcod.black)
        libtcod.console_clear(wawindow)

        DrawScroll(wawindow, 4, 5, VIEW_WIDTH - 10 + 1, VIEW_HEIGHT - 20 + 1)
        libtcod.image_blit_2x(self.worldpic, wawindow, 5, 6)
        
        MenuList = []
        libtcod.console_clear(wswindow)
        MenuSetting = 'WAWorld'

        libtcod.console_set_default_foreground(wawindow, libtcod.white)
        libtcod.console_print_ex(wawindow, VIEW_WIDTH / 2, 2, libtcod.BKGND_NONE, libtcod.CENTER, 'The World of ' + worldname)
        libtcod.console_clear(wswindow)
        optionlist = ['Locations', 'People', 'Bestiary', 'Nations', 'Events', 'Gods', 'Legends']
        self.atlasmenu = Menu(wswindow, 2, 4, optionlist, title = 'Main Menu:', talign = 'center', tx = 9, ty = 2, \
                         MethodList = [('Nations',Atlas.loadNations),('Bestiary',Atlas.loadBestiaryMain)], \
                         BMethodList = [doWorldAtlasSetup,Atlas.run])
        self.atlasmenu.start()

    def loadNations(self):
        global MenuSetting, MenuList, playery, oplayery

        libtcod.console_clear(wswindow)
        MenuSetting = 'WANationList'
        MenuList = []
        optionlist = []
        for civ in range(1, wcivdict['civnum'] + 1):
            optionlist.append(wcivdict[civ])
        self.atlasmenu = Menu(wswindow, 2, 4, optionlist, title = 'Nations:', talign = 'center', tx = 9, ty = 2, \
                         MethodList = [(True,Atlas.loadIndivNation)], BMethodList = [Atlas.loadWorldScreen])
        self.atlasmenu.start()

    def loadIndivNation(self):
        global MenuSetting, MenuList, playery, oplayery, mplayery

        libtcod.console_clear(wswindow)
        MenuSetting = 'WAIndivNation'
        MenuList = []

        libtcod.console_set_default_background(wawindow, libtcod.black)
        libtcod.console_clear(wswindow)
        libtcod.console_clear(wawindow)
        self.nation = wcivdict[mplayery]
        self.natnum = mplayery
        nation = self.nation
        natnum = self.natnum

        civrange = range(1, wcivdict['civnum'] + 1)
        civrange.remove(natnum)
        
        DrawScroll(wawindow, 9, 5, VIEW_WIDTH - 20 + 1, VIEW_HEIGHT - 30 + 1)
        DrawWorld(wawindow, VIEW_WIDTH - 20, VIEW_HEIGHT - 30, \
                  wcivdict[nation + '-startpos'][0], wcivdict[nation + '-startpos'][1], \
                  10, 6, territory = True)

        libtcod.console_set_default_foreground(wawindow, libtcod.white)
        libtcod.console_print_ex(wawindow, VIEW_WIDTH / 2, 2, libtcod.BKGND_NONE, libtcod.CENTER, wcivdict[nation + '-title'])
        libtcod.console_set_default_foreground(wawindow, wcivdict[nation + '-civcol'])
        libtcod.console_set_default_background(wawindow, wcivdict[nation + '-civcol2'])
        libtcod.console_print_ex(wawindow, 40, 19, libtcod.BKGND_ALPHA(0.6), libtcod.CENTER, \
                                     wcivdict[nation + '-title'])

        optionlist = ['Government', 'Towns/Castles', 'Other Places', 'Relations', 'History', 'Religion']
        self.atlasmenu = Menu(wswindow, 2, 4, optionlist, title = nation + ':', talign = 'center', tx = 9, ty = 2, \
                         MethodList = [('Relations',Atlas.loadNationRelations)], BMethodList = [Atlas.loadWorldScreen,Atlas.loadNations])
        self.atlasmenu.start()

    def loadNationRelations(self):
        global MenuSetting, MenuList, playery, oplayery, mplayery, relswitch

        nation = self.nation
        natnum = self.natnum
        relswitch = True
        libtcod.console_set_default_background(wawindow, libtcod.black)
        libtcod.console_clear(wawindow)
        libtcod.console_set_default_foreground(wawindow, libtcod.white)
        libtcod.console_set_color_control(libtcod.COLCTRL_1, wcivdict[nation + '-civcol'], libtcod.black)
        libtcod.console_print_ex(wawindow, VIEW_WIDTH / 2, 2, libtcod.BKGND_NONE, libtcod.CENTER, 'Foreign Relations of %c' % (libtcod.COLCTRL_1) \
                                     + wcivdict[nation + '-title'] + '%c:' % (libtcod.COLCTRL_STOP))
        civreldict = {}
        DrawWorld(wgwindow, terrain = True, forests = False, scrub = False, caves = False, \
                  rivers = False, cities = False, territory = False)
        for civ in range(1, wcivdict['civnum'] + 1):
            civrel = fnmatch.filter(wcivdict[wcivdict[natnum] + '-relations'], '%s,*' % str(civ))[0]
            civrel = int(civrel[len(str(civ)) + 1:])
            if civ != natnum:
                if civrel > 39:
                    relationship = 'Friendly'
                    relcol = libtcod.dark_green
                elif civrel in range(36,39):
                    relationship = 'Amiable'
                    relcol = libtcod.green
                elif civrel in range(31,36):
                    relationship = 'Receptive'
                    relcol = libtcod.light_green
                elif civrel in range(26,31):
                    relationship = 'Neutral'
                    relcol = libtcod.yellow
                elif civrel in range(21,26):
                    relationship = 'Cool'
                    relcol = libtcod.light_cyan
                elif civrel in range(16,21):
                    relationship = 'Chilly'
                    relcol = libtcod.cyan
                elif civrel in range(11,16):
                    relationship = 'Contemptuous'
                    relcol = libtcod.orange
                elif civrel in range(6,11):
                    relationship = 'Hostile'
                    relcol = libtcod.red
                elif civrel < 6:
                    relationship = 'Hateful'
                    relcol = libtcod.dark_red
                civreldict[civ] = [relationship,relcol]
                libtcod.console_set_default_foreground(wawindow, libtcod.white)
                libtcod.console_set_color_control(libtcod.COLCTRL_1, relcol, libtcod.black)
                libtcod.console_print_ex(wawindow, VIEW_WIDTH / 2, 3 + civ, libtcod.BKGND_NONE, libtcod.CENTER, wcivdict[civ] + \
                                             ': %c' % (libtcod.COLCTRL_1) + relationship + '%c' % (libtcod.COLCTRL_STOP))
            else:
                libtcod.console_print_ex(wawindow, VIEW_WIDTH / 2, 3 + natnum, libtcod.BKGND_NONE, libtcod.CENTER, nation + ': ---')
                civreldict[civ] = ['N/A',libtcod.white]
            libtcod.console_print_ex(wawindow, VIEW_WIDTH / 2, 5 + wcivdict['civnum'], libtcod.BKGND_NONE, libtcod.CENTER, "To view a map of this civilization's\n" \
                                         "relations, press 'm'.")
            relbutton = ButtonBox(wawindow, (VIEW_WIDTH / 2) - 6, 9 + wcivdict['civnum'],'Relations Map','m',offx = SCREEN_WIDTH - VIEW_WIDTH - 3)
            self.civreldict = civreldict

    def loadRelationsMap(self):
        global MAP_WIDTH, MAP_HEIGHT, VIEW_WIDTH, VIEW_HEIGHT
        
        libtcod.console_set_default_background(wawindow, libtcod.black)
        libtcod.console_clear(wawindow)

        for x in range(MAP_WIDTH):
                for y in range(MAP_HEIGHT):
                    try:
                        libtcod.console_set_char_background(wgwindow, x, y, self.civreldict[wterritorydict['%s,%s' % (x,y)]][1], libtcod.BKGND_SET)
                    except KeyError:
                       pass
                    
        relpic = libtcod.image_from_console(wgwindow)
        newrel = solidScale(relpic, VIEW_WIDTH - 20, VIEW_HEIGHT - 20, 1)
        libtcod.image_scale(relpic, (VIEW_WIDTH - 20) * 2, (VIEW_HEIGHT - 20) * 2)
        RelationsMap = RelMap(wawindow, 10, 10, 20, 2, VIEW_WIDTH - 20, VIEW_HEIGHT - 20, newrel[3], relpic, self.civreldict).start()

    def loadBestiaryMain(self):
        global MenuList, MenuSetting, playery, oplayery, mplayery

        libtcod.console_clear(wswindow)
        MenuSetting = 'WABestiaryMain'
        MenuList = []
        
        optionlist = ['All','Sorted...']
        
        self.atlasmenu = Menu(wswindow, 2, 4, optionlist, title = 'Bestiary:', talign = 'center', tx = 9, ty = 2, \
                         MethodList = [('All',Atlas.loadBestiary),('Sorted...',Atlas.loadBestiarySorted)], \
                         BMethodList = [Atlas.loadWorldScreen])
        self.atlasmenu.start()

    def loadBestiarySorted(self):
        global MenuList, MenuSetting, playery, oplayery, mplayery

        libtcod.console_clear(wswindow)
        MenuList = []
        MenuSetting = 'WABestiarySorted'

        spherelist = ['Terrestrial','Aquatic','Aerial','Amphibian','Subterranean']
        biomelist = ['Beach', 'Broadleaf Forest', 'Cacti Forest', 'Cave', 'Coniferous Forest', 'Deciduous Forest', 'Desert', \
                      'Evergreen Forest', 'Glacier', 'Heathland', 'Highland', 'Lake', 'Lakeshore', 'Marshland', 'Mixed Forest', \
                      'Mountain', 'Ocean', 'Plain', 'Pond', 'River', 'River Bank', 'Savannah', 'Shrubland', 'Swamp', 'Tropical Forest', 'Tundra']
        sizelist = ['Tiny','Small','Medium','Large','Huge','Gigantic']

        option = self.atlasmenu.optionlist[mplayery - 1]

        if  option == 'Sorted...':
            optionlist = ['By Sphere...','By Biome...','By Region...','By Nation...','By Size...','Extinct']

            self.atlasmenu = Menu(wswindow, 2, 4, optionlist, title = 'Bestiary:', talign = 'center', tx = 9, ty = 2, \
                                  MethodList = [(True,Atlas.loadBestiarySorted)], BMethodList = [Atlas.loadBestiaryMain])
            self.atlasmenu.start()

        elif option == 'By Sphere...':
            optionlist = spherelist

            self.atlasmenu = Menu(wswindow, 2, 4, optionlist, title = 'Bestiary:', talign = 'center', tx = 9, ty = 2, \
                                  MethodList = [(True,Atlas.loadBestiarySorted)], BMethodList = [Atlas.loadBestiaryMain])
            self.atlasmenu.start()

        elif option == 'By Biome...':
            optionlist = biomelist

            self.atlasmenu = Menu(wswindow, 2, 4, optionlist, title = 'Bestiary:', talign = 'center', tx = 9, ty = 2, \
                                  MethodList = [(True,Atlas.loadBestiarySorted)], BMethodList = [Atlas.loadBestiaryMain])
            self.atlasmenu.start()

        elif option == 'By Size...':
            optionlist = sizelist

            self.atlasmenu = Menu(wswindow, 2, 4, optionlist, title = 'Bestiary:', talign = 'center', tx = 9, ty = 2, \
                                  MethodList = [(True,Atlas.loadBestiarySorted)], BMethodList = [Atlas.loadBestiaryMain])
            self.atlasmenu.start()

        elif option == 'Extinct':
            Atlas.loadBestiary(req = 'Extinct')

        elif option in biomelist + spherelist + sizelist:
            Atlas.loadBestiary(req = option)
        
    def loadBestiary(self, req = None):
        global MenuList, MenuSetting, playery, oplayery, mplayery

        libtcod.console_clear(wswindow)
        MenuSetting = 'WABestiary'
        MenuList = []

        spherelist = ['Terrestrial','Aquatic','Aerial','Amphibian','Subterranean']
        biomelist = ['Beach', 'Broadleaf Forest', 'Cacti Forest', 'Cave', 'Coniferous Forest', 'Deciduous Forest', 'Desert', \
                      'Evergreen Forest', 'Glacier', 'Heathland', 'Highland', 'Lake', 'Lakeshore', 'Marshland', 'Mixed Forest', \
                      'Mountain', 'Ocean', 'Plain', 'Pond', 'River', 'River Bank', 'Savannah', 'Shrubland', 'Swamp', 'Tropical Forest', 'Tundra']
        sizelist = ['Tiny','Small','Medium','Large','Huge','Gigantic']

        optionlist = []
        if not req:
            for creature in sorted(wcreaturedict.iterkeys()):
                if not wcreaturedict[creature]['extinct']:
                    optionlist.append(creature)
        elif req in spherelist:
            for creature in sorted(wcreaturedict.iterkeys()):
                if req == wcreaturedict[creature]['sphere']:
                    if not wcreaturedict[creature]['extinct']:
                        optionlist.append(creature)
        elif req in biomelist:
            for creature in sorted(wcreaturedict.iterkeys()):
                if req in wcreaturedict[creature]['biomes']:
                    if not wcreaturedict[creature]['extinct']:
                        optionlist.append(creature)
        elif req in sizelist:
            for creature in sorted(wcreaturedict.iterkeys()):
                if wcreaturedict[creature]['sizecat'] == (sizelist.index(req) + 1):
                    if not wcreaturedict[creature]['extinct']:
                        optionlist.append(creature)
        elif req == 'Extinct':
            for creature in sorted(wcreaturedict.iterkeys()):
                if wcreaturedict[creature]['extinct']:
                    optionlist.append(creature)

        self.atlasmenu = Menu(wswindow, 2, 4, optionlist, title = 'Bestiary:', talign = 'center', tx = 9, ty = 2, \
                         MethodList = [(True,Atlas.loadCreature)], BMethodList = [Atlas.loadBestiaryMain])
        self.atlasmenu.start()

    def loadCreature(self):
        global MenuList, MenuSetting, playery, oplayery, mplayery, creature

        option = self.atlasmenu.optionlist[mplayery - 1]
        libtcod.console_clear(wswindow)
        MenuSetting = 'WACreature'
        MenuList = []

        creature = wcreaturedict[option]
        libtcod.console_set_default_background(wawindow, libtcod.black)
        libtcod.console_clear(wawindow)

        DrawScroll(wawindow, 9, 9, VIEW_WIDTH - 19, VIEW_HEIGHT - 19)
        libtcod.console_set_default_foreground(wawindow, creature['charcolor'])
        
        charfile = open('.\\image\\txt\\chars.txt','r')
        charlines = []
        for line in charfile:
            charlines.append(line.strip('\n'))
        charfile.close()
        if ord(creature['creaturechar']) in range(65,91):
            charnum = ((ord(creature['creaturechar']) - 65) * 2) + 1
        elif ord(creature['creaturechar']) in range(97,123):
            charnum = (ord(creature['creaturechar']) - 97) * 2
        mcharlines = []
        lline = 0

        for line in charlines[charnum * 11:(charnum + 1) * 11]:
            if line.count(' ') != len(line):
                mcharlines.append(line)
                if len(line) > lline:
                    lline = len(line)

        y = 11
        for line in mcharlines:
            libtcod.console_print_ex(wawindow, 10 + ((VIEW_WIDTH - 19) / 2) - (lline / 2), y, libtcod.BKGND_NONE, libtcod.LEFT, line)
            y += 1

        libtcod.console_set_default_foreground(wawindow, libtcod.white)
        libtcod.console_set_color_control(libtcod.COLCTRL_1,creature['charcolor'],libtcod.black)
        libtcod.console_print_ex(wawindow, 9 + ((VIEW_WIDTH - 19) / 2), 12 + len(mcharlines), libtcod.BKGND_NONE, libtcod.CENTER, \
                                     'The %c%s%c' % (libtcod.COLCTRL_1,creature['name'].capitalize(),libtcod.COLCTRL_STOP))
        libtcod.console_print_rect_ex(wawindow, 9 + ((VIEW_WIDTH - 19) / 2), 14 + len(mcharlines), (VIEW_WIDTH - 32), (VIEW_HEIGHT - 32), \
                                          libtcod.BKGND_NONE, libtcod.CENTER, creature['description'])

        optionlist = ['Description','Information','Combat Stats','Legends']
        self.atlasmenu = Menu(wswindow, 2, 4, optionlist, title = creature['name'] + ':', talign = 'center', tx = 9, ty = 2, \
                              MethodList = [('Combat Stats',Atlas.loadCreatureStats)], BMethodList = [Atlas.loadBestiaryMain])
        self.atlasmenu.start()

    def loadCreatureStats(self):
        libtcod.console_clear(wawindow)
        libtcod.console_set_default_foreground(wawindow, libtcod.white)
        lineadd = 0

        SIZE = creature['size']
        STR = creature['STR'] + int((float(creature['mods']['STR']) / 100.00) * creature['STR'])
        AGI = creature['AGI'] + int((float(creature['mods']['AGI']) / 100.00) * creature['AGI'])
        END = creature['END'] + int((float(creature['mods']['END']) / 100.00) * creature['END'])
        INT = creature['INT'] + int((float(creature['mods']['INT']) / 100.00) * creature['INT'])
        WIT = creature['WIT'] + int((float(creature['mods']['WIT']) / 100.00) * creature['WIT'])
        WIL = creature['WIL'] + int((float(creature['mods']['WIL']) / 100.00) * creature['WIL'])

        BSPD = (10 + (AGI / 2) + (10 / SIZE))
        BDEF = (END / 2) + int((.5 * sqrt(SIZE)))
        BATK = ((STR + AGI) * 2) + int(sqrt(SIZE))
        BAC = creature['CAC']
        BHP = ((WIL + END) * 2) + (SIZE / 4)
        BAP = (WIT + AGI) / 2

        SPD = BSPD + int((float(creature['mods']['SPD']) / 100.00) * BSPD)
        DEF = BDEF + int((float(creature['mods']['DEF']) / 100.00) * BDEF)
        ATK = BATK + int((float(creature['mods']['ATK']) / 100.00) * BATK)
        AC = BAC + int((float(creature['mods']['AC']) / 100.00) * BAC)
        HP = BHP + int((float(creature['mods']['HP']) / 100.00) * BHP)
        AP = BAP + int((float(creature['mods']['AP']) / 100.00) * BAP)

        StatDict = {}
        StatDict['STR'] = [STR,'Strength']
        StatDict['AGI'] = [AGI,'Agility']
        StatDict['END'] = [END,'Endurance']
        StatDict['INT'] = [INT,'Intelligence']
        StatDict['WIT'] = [WIT,'Wits']
        StatDict['WIL'] = [WIL,'Willpower']
        StatDict['SPD'] = [SPD,'Speed']
        StatDict['DEF'] = [DEF,'Defense']
        StatDict['ATK'] = [ATK,'Attack']
        StatDict['AC'] = [AC,'Armor Class']
        StatDict['HP'] = [HP,'Hit Points']
        StatDict['AP'] = [AP,'Action Points']
        
        for stat in StatDict.keys():
            statline = StatDict[stat][1] + ': ' + str(StatDict[stat][0])
            libtcod.console_print_ex(wawindow, 9 + ((VIEW_WIDTH - 19) / 2), 14 + lineadd, libtcod.BKGND_NONE, libtcod.CENTER, statline)
            lineadd += 1

    def exitAtlas(self):
        global DOSCREEN, playery, MenuList
        DOSCREEN = 0
        libtcod.console_set_default_background(0,libtcod.Color(2,0,0))
        libtcod.console_clear(0)
        playery = 1
        MenuList = []
        doIntroSetup()
        del self

####################################
# XIV. Main Game Architecture      #
####################################

class PlayWorld(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.rswitch = False
        self.messagelog = []
        self.lastmessage = None
        self.lastmessagecount = 0
        self.mesglimit = SCREEN_HEIGHT - VIEW_HEIGHT - 4
        self.shadowdict = {}
        self.clouddict = {}
        self.setupdone = False
        self.rinit = False
        self.winit = False
        self.saves = {}
        self.killswitch = False
        self.rdict = {}
        self.windowlock = False
        self.groundview = False
        self.invopen = False
        self.cmopen = False
        self.optopen = False
        self.topwindow = False
        self.loading = False
        self.zconsole = libtcod.console_new(RMAP_WIDTH,RMAP_HEIGHT)
        self.ocity = None
        self.menudrawn = False
        self.runtime = False
        self.hours = 11
        self.minutes = 59
        self.timestr = '11:59 PM'
        self.showclock = False
        self.paused = False
                    
    # Travel Functions

    def floodFill(self,wobstructed = False,captureimage = False):
        global MouseLock, pathlock, MoveLock, moveclouds
        areas = {}
        acount = 0
        if wobstructed:
            MW,MH = RMAP_WIDTH,RMAP_HEIGHT
        else:
            MW,MH = MAP_WIDTH,MAP_HEIGHT
            self.ffobdict = {}
        for x in range(MW):
            for y in range(MH):
                case = True
                if wobstructed:
                    try:
                        self.zgrid[self.curz]['%s,%s' % (x,y)]
                        ztile = True
                    except KeyError:
                        ztile = False
                    if ztile:
                        if self.zgrid[self.curz]['%s,%s' % (x,y)][0] in ['wall','door','window','fence','pillar']:
                            self.wobstructed[self.curz]['%s,%s' % (x,y)] = self.zgrid[self.curz]['%s,%s' % (x,y)][0]
                            try:
                                if self.zgrid[self.curz]['%s,%s' % (x,y)][5] == 'open':
                                    self.wobstructed[self.curz].pop('%s,%s' % (x,y))
                            except IndexError:
                                pass
                            case = False
                    elif self.curz > 0:
                        self.wobstructed[self.curz]['%s,%s' % (x,y)] = 'air'
                        case = False
                    elif type(self.rheightmap['%s,%s' % (x,y)]) == str:
                        case = False
                    elif self.rheightmap['%s,%s' % (x,y)] > self.rdict['%s-%s' % (self.maintype,self.tempzone)]['mlev']:
                        case = False
                else:
                    if wheightdict['%s,%s' % (x,y)] <= wwlev:
                        self.ffobdict['%s,%s' % (x,y)] = 'water'
                        case = False
                    elif wheightdict['%s,%s' % (x,y)] >= wmlev:
                        self.ffobdict['%s,%s' % (x,y)] = 'mountain'
                        case = False
                if case:
                    conareas = []
                    for num in range(-1,2):
                        for num2 in range(-1,2):
                            for area in areas.keys():
                                try:
                                    areas[area]['%s,%s' % (x - num,y - num2)]
                                    if area not in conareas:
                                        conareas.append(area)
                                except KeyError:
                                    pass
                    if len(conareas) > 1:
                        for area in conareas[1:]:
                            areas[conareas[0]].update(areas[area])
                            areas.pop(area)
                        areas[conareas[0]]['%s,%s' % (x,y)] = True
                    elif len(conareas) == 1:
                        areas[conareas[0]]['%s,%s' % (x,y)] = True
                    else:
                        try:
                            nkey = areas.keys()[-1] + 1
                            for key in range(0,areas.keys()[-1] + 1):
                                if not areas.get(key):
                                    nkey = key
                                    break
                            areas[nkey] = {}
                            areas[nkey]['%s,%s' % (x,y)] = True
                        except IndexError:
                            areas[0] = {}
                            areas[0]['%s,%s' % (x,y)] = True
        self.linkedareas[self.curz] = {}
        for area in areas:
            self.linkedareas[self.curz][area] = {}
        if captureimage:
            self.rimage = libtcod.image_from_console(wrwindow)
        return areas

    # Game Menu/Status Screen Functions

    def updateStatus(self):
        global DoHUD, NoRefresh, freeze, MGButtonList, ButtonLock, moveclouds, NoMenus, NoButtons, NoGraphics, Clouds
        NoButtons,NoMenus,NoGraphics = True,True,True
        ButtonLock = True
        lock.acquire()
        NoRefresh = True
        Clouds.paused = True
        libtcod.console_set_default_background(wiwindow, bgcolor2)
        libtcod.console_set_default_background(wswindow, bgcolor)
        libtcod.console_set_default_background(0,bgcolor)
        libtcod.console_set_default_background(0,bgcolor2)
        libtcod.console_set_default_foreground(wswindow,libtcod.white)
        if not self.menudrawn:
            for x in range(17):
                for y in range(29):
                    char = [0 + x,66 + y,255]
                    libtcod.console_print_ex(wswindow,1 + x,16 + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
            self.menudrawn = True
                

        FMGButtonList = map(lambda x: x[3],MGButtonList)
        if 'Inventory' not in FMGButtonList:
            MGButtonList.append([wswindow,1,20,'Inventory','i',0,1,False,False])            
        if 'Skills and Spells' not in FMGButtonList:
            MGButtonList.append([wswindow,1,23,'Skills and Spells','s',0,1,False,False])
        if 'Character' not in FMGButtonList:
            MGButtonList.append([wswindow,1,26,'Character','c',0,1,False,False])
        if 'Journal' not in FMGButtonList:
            MGButtonList.append([wswindow,1,29,'Journal','j',0,1,False,False])
        if 'Constructions' not in FMGButtonList:
            MGButtonList.append([wswindow,1,32,'Constructions','b',0,1,False,False])
        if 'Ground View' not in FMGButtonList:
            MGButtonList.append([wswindow,1,35,'Ground View','g',0,1,False,False])
        if 'Options' not in FMGButtonList:
            MGButtonList.append([wswindow,1,38,'Options','o',0,1,False,False])
        
        # Draw the HUD, HP/Mana/Phase Meters, etc.
        if DoHUD:
            for x in range(15):
                for y in range(5):
                    libtcod.console_print_ex(wswindow,2 + x,2 + y,libtcod.BKGND_NONE,libtcod.LEFT,' ')
            for x in range(15):
                for y in range(5):
                    libtcod.console_print_ex(0,2 + x,4 + y,libtcod.BKGND_NONE,libtcod.LEFT,' ')
            DrawScroll(wswindow,1,1,16,13,1)
            HP = max(self.PCHP - self.PCDamage,0)
            mult = 8 - int(((HP * 1.0) / (self.PCHP)) * 8)
            for x in range(3):
                for y in range(4):
                    char = [0 + x + (3 * mult),54 + y,255]
                    libtcod.console_set_default_foreground(wswindow,libtcod.white)
                    libtcod.console_print_ex(wswindow,3 + x,3 + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
            MP = max(self.PCMP - self.PCManaDrain,0)
            mult = 9 - int(((MP * 1.0) / (self.PCMP)) * 9)
            for x in range(5):
                for y in range(4):
                    if mult < 5:
                        char = [0 + x + (5 * mult),58 + y,255]
                    else:
                        char = [0 + x + (5 * (mult - 5)),62 + y,255]
                    libtcod.console_set_default_foreground(wswindow,libtcod.white)
                    libtcod.console_print_ex(wswindow,7 + x,3 + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
            if self.PCPhase == 100:
                coords = (25,58)
            if self.PCPhase in range(75,100):
                coords = (28,58)
            if self.PCPhase in range(50,75):
                coords = (25,62)
            if self.PCPhase in range(25,50):
                coords = (28,62)
            for x in range(3):
                for y in range(4):
                    if self.PCPhase < 25:
                        pass
                    else:
                        char = [coords[0] + x,coords[1] + y,255]
                        libtcod.console_set_default_foreground(wswindow,libtcod.white)
                        libtcod.console_print_ex(wswindow,13 + x,3 + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
            libtcod.console_set_default_foreground(wswindow,libtcod.white)
            for x in range(15):
                for y in range(2):
                    char = [11 + x,52 + y,255]
                    libtcod.console_print_ex(wswindow,2 + x,7 + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
            libtcod.console_set_default_foreground(wswindow,libtcod.black)
            libtcod.console_print_ex(wswindow,5,10,libtcod.BKGND_NONE,libtcod.RIGHT,str(HP))
            libtcod.console_print_ex(wswindow,10,10,libtcod.BKGND_NONE,libtcod.RIGHT,str(MP))
            libtcod.console_print_ex(wswindow,15,10,libtcod.BKGND_NONE,libtcod.RIGHT,str(self.PCPhase))
            libtcod.console_set_default_foreground(wswindow,libtcod.darker_grey)
            libtcod.console_print_ex(wswindow,3,11,libtcod.BKGND_NONE,libtcod.LEFT,'---  ---  ---')
            libtcod.console_set_default_foreground(wswindow,libtcod.black)
            libtcod.console_print_ex(wswindow,5,12,libtcod.BKGND_NONE,libtcod.RIGHT,str(self.PCHP))
            libtcod.console_print_ex(wswindow,10,12,libtcod.BKGND_NONE,libtcod.RIGHT,str(self.PCMP))
            libtcod.console_print_ex(wswindow,15,12,libtcod.BKGND_NONE,libtcod.RIGHT,'100')
        Clouds.paused = False
        NoButtons,NoMenus,NoGraphics = False,False,False
        ButtonLock = False
        NoRefresh = False
        lock.release()

    # Pause the game.

    def doPause(self):
        global Clouds, pathlock
        if self.runtime:
            libtcod.console_set_default_foreground(GUILayer,libtcod.white)
            for x in range(3):
                for y in range(3):
                    lock.acquire()
                    char = [icon_pause[0] + x,icon_pause[1] + y,255]
                    libtcod.console_print_ex(GUILayer,GUITiles['unpause'][0][0] + x,GUITiles['unpause'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                    lock.release()
            pausesound = playSound('sounds\\wav\\lb.wav')
            self.runtime = False
            Clouds.hover = True
            pathlock = True
            self.paused = True
        else:
            libtcod.console_set_default_foreground(GUILayer,libtcod.white)
            for x in range(3):
                for y in range(3):
                    lock.acquire()
                    char = [icon_unpause[0] + x,icon_unpause[1] + y,255]
                    libtcod.console_print_ex(GUILayer,GUITiles['unpause'][0][0] + x,GUITiles['unpause'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                    lock.release()
            unpausesound = playSound('sounds\\wav\\lbh.wav')
            self.runtime = True
            Clouds.hover = False
            pathlock = False
            self.paused = False

    # GUI Functions

    def doGUIMenu(self,menu = None,page = None):
        global GUIMenu
        if not menu:
            menu = GUIMenu['menu']
        if page or menu != GUIMenu['menu']:
            if page:
                GUIMenu['page'] = page
            else:
                page = GUIMenu['page']
            lock.acquire()
            libtcod.console_set_default_foreground(GUILayer,libtcod.black)
            libtcod.console_set_default_background(GUILayer,scrollcolor2)
            libtcod.console_print_ex(GUILayer,15,4,libtcod.BKGND_SET,libtcod.LEFT,'%02d' % GUIMenu['page'])
            libtcod.console_set_default_foreground(GUILayer,libtcod.white)
            if GUIMenu[menu][page][0]:
                tile = GUIMenu[menu][page][0][0]
            else:
                tile = icon_emptybutton
            for x in range(3):
                for y in range(3):
                    char = [tile[0] + x,tile[1] + y,255]
                    libtcod.console_print_ex(GUILayer,GUITiles['button1'][0][0] + x,GUITiles['button1'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
            if GUIMenu[menu][page][1]:
                tile = GUIMenu[menu][page][1][0]
            else:
                tile = icon_emptybutton
            for x in range(3):
                for y in range(3):
                    char = [tile[0] + x,tile[1] + y,255]
                    libtcod.console_print_ex(GUILayer,GUITiles['button2'][0][0] + x,GUITiles['button2'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
            if GUIMenu[menu][page][2]:
                tile = GUIMenu[menu][page][2][0]
            else:
                tile = icon_emptybutton
            for x in range(3):
                for y in range(3):
                    char = [tile[0] + x,tile[1] + y,255]
                    libtcod.console_print_ex(GUILayer,GUITiles['button3'][0][0] + x,GUITiles['button3'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
            if GUIMenu[menu][page][3]:
                tile = GUIMenu[menu][page][3][0]
            else:
                tile = icon_emptybutton
            for x in range(3):
                for y in range(3):
                    char = [tile[0] + x,tile[1] + y,255]
                    libtcod.console_print_ex(GUILayer,GUITiles['button4'][0][0] + x,GUITiles['button4'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
            if GUIMenu[menu][page][4]:
                tile = GUIMenu[menu][page][4][0]
            else:
                tile = icon_emptybutton
            for x in range(3):
                for y in range(3):
                    char = [tile[0] + x,tile[1] + y,255]
                    libtcod.console_print_ex(GUILayer,GUITiles['button5'][0][0] + x,GUITiles['button5'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
            if GUIMenu[menu][page][5]:
                tile = GUIMenu[menu][page][5][0]
            else:
                tile = icon_emptybutton
            for x in range(3):
                for y in range(3):
                    char = [tile[0] + x,tile[1] + y,255]
                    libtcod.console_print_ex(GUILayer,GUITiles['button6'][0][0] + x,GUITiles['button6'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
            lock.release()
        if menu == GUIMenu['menu']:
            pass
        else:
            clicksound = playSound('sounds\\wav\\click.wav')            
            GUIMenu['menu'] = menu
            libtcod.console_set_default_foreground(GUILayer,libtcod.white)
            if menu == 'task':
                for x in range(3):
                    for y in range(3):
                        lock.acquire()
                        char = [icon_taskh[0] + x,icon_taskh[1] + y,255]
                        libtcod.console_print_ex(GUILayer,GUITiles['task'][0][0] + x,GUITiles['task'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                        lock.release()
                for x in range(3):
                    for y in range(3):
                        lock.acquire()
                        char = [icon_battle[0] + x,icon_battle[1] + y,255]
                        libtcod.console_print_ex(GUILayer,GUITiles['battle'][0][0] + x,GUITiles['battle'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                        lock.release()
                for x in range(3):
                    for y in range(3):
                        lock.acquire()
                        char = [icon_group[0] + x,icon_group[1] + y,255]
                        libtcod.console_print_ex(GUILayer,GUITiles['group'][0][0] + x,GUITiles['group'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                        lock.release()

            elif menu == 'group':
                for x in range(3):
                    for y in range(3):
                        lock.acquire()
                        char = [icon_task[0] + x,icon_task[1] + y,255]
                        libtcod.console_print_ex(GUILayer,GUITiles['task'][0][0] + x,GUITiles['task'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                        lock.release()
                for x in range(3):
                    for y in range(3):
                        lock.acquire()
                        char = [icon_battle[0] + x,icon_battle[1] + y,255]
                        libtcod.console_print_ex(GUILayer,GUITiles['battle'][0][0] + x,GUITiles['battle'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                        lock.release()
                for x in range(3):
                    for y in range(3):
                        lock.acquire()
                        char = [icon_grouph[0] + x,icon_grouph[1] + y,255]
                        libtcod.console_print_ex(GUILayer,GUITiles['group'][0][0] + x,GUITiles['group'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                        lock.release()

            elif menu == 'battle':
                for x in range(3):
                    for y in range(3):
                        lock.acquire()
                        char = [icon_task[0] + x,icon_task[1] + y,255]
                        libtcod.console_print_ex(GUILayer,GUITiles['task'][0][0] + x,GUITiles['task'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                        lock.release()
                for x in range(3):
                    for y in range(3):
                        lock.acquire()
                        char = [icon_battleh[0] + x,icon_battleh[1] + y,255]
                        libtcod.console_print_ex(GUILayer,GUITiles['battle'][0][0] + x,GUITiles['battle'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                        lock.release()
                for x in range(3):
                    for y in range(3):
                        lock.acquire()
                        char = [icon_group[0] + x,icon_group[1] + y,255]
                        libtcod.console_print_ex(GUILayer,GUITiles['group'][0][0] + x,GUITiles['group'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                        lock.release()
                        
    # Message Display Functions

    def addMesg(self,message,col = libtcod.white):
        global MLogBar
        MLogBar.binc = 0
        MLogBar.inc = 0
        message = textWrap(message)[0]
        mesglen = textWrap(message)[1]
        if self.lastmessage == message:
            self.messagelog.pop(0)
            self.lastmessagecount += 1
            message = message + ' (x%s)' % self.lastmessagecount
            addinc = False
        else:
            addinc = True
            self.lastmessage = message
            self.lastmessagecount = 1
            try:
                self.mesgnum += mesglen
            except AttributeError:
                self.mesgnum = mesglen
        self.messagelog.insert(0,[message,col])
        if self.mesgnum > self.mesglimit - 1 and addinc:
            MLogBar.max += mesglen
        self.dispMesgLog()

    def dispMesgLog(self):
        global MLogBar
        libtcod.console_set_default_background(wiwindow, bgcolor2)
        libtcod.console_clear(wiwindow)
        MLogBar.reDraw()
        mesgcount = 0
        lbcount = 0
        for oldmessage in self.messagelog[MLogBar.inc:]:
            lbcount += oldmessage[0].count('\n')
            mesgcount += 1
            if (lbcount + mesgcount) < self.mesglimit + 3:
                oldmessage = textWrap(oldmessage)[0]
                libtcod.console_set_default_foreground(wiwindow, oldmessage[1])
                libtcod.console_print_ex(wiwindow, VIEW_WIDTH / 2, mesgcount, libtcod.BKGND_NONE, libtcod.CENTER, oldmessage[0])
                mesgcount += oldmessage[0].count('\n')
            else:
                break

    # Map Generation - Main Terrain Types

    def DeciduousForestMap(self):
        rmap = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap2 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.noise_set_type(mapnoise, libtcod.NOISE_PERLIN)
        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                f = [3.5 * x / (RMAP_WIDTH - 4),
                     3.5 * y / (RMAP_HEIGHT - 4)]
                value = libtcod.noise_get_turbulence(mapnoise, f, 3)
                libtcod.heightmap_set_value(rmap, x, y, value)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap2, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap2, rmap, 0.5)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        minmax = list(libtcod.heightmap_get_minmax(rmap))
        return (rmap,minmax)

    def MixedForestMap(self):
        rmap = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap2 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.noise_set_type(mapnoise, libtcod.NOISE_PERLIN)
        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                f = [3.5 * x / (RMAP_WIDTH - 4),
                     3.5 * y / (RMAP_HEIGHT - 4)]
                value = libtcod.noise_get_turbulence(mapnoise, f, 3)
                libtcod.heightmap_set_value(rmap, x, y, value)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap2, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap2, rmap, 0.5)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        minmax = list(libtcod.heightmap_get_minmax(rmap))
        return (rmap,minmax)

    def BroadleafForestMap(self):
        rmap = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap2 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.noise_set_type(mapnoise, libtcod.NOISE_PERLIN)
        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                f = [3.5 * x / (RMAP_WIDTH - 4),
                     3.5 * y / (RMAP_HEIGHT - 4)]
                value = libtcod.noise_get_turbulence(mapnoise, f, 3)
                libtcod.heightmap_set_value(rmap, x, y, value)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap2, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap2, rmap, 0.5)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        minmax = list(libtcod.heightmap_get_minmax(rmap))
        return (rmap,minmax)

    def ConiferousForestMap(self):
        rmap = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap2 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.noise_set_type(mapnoise, libtcod.NOISE_PERLIN)
        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                f = [3.5 * x / (RMAP_WIDTH - 4),
                     3.5 * y / (RMAP_HEIGHT - 4)]
                value = libtcod.noise_get_turbulence(mapnoise, f, 3)
                libtcod.heightmap_set_value(rmap, x, y, value)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap2, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap2, rmap, 0.5)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        minmax = list(libtcod.heightmap_get_minmax(rmap))
        return (rmap,minmax)

    def EvergreenForestMap(self):
        rmap = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap2 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.noise_set_type(mapnoise, libtcod.NOISE_PERLIN)
        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                f = [3.5 * x / (RMAP_WIDTH - 4),
                     3.5 * y / (RMAP_HEIGHT - 4)]
                value = libtcod.noise_get_turbulence(mapnoise, f, 3)
                libtcod.heightmap_set_value(rmap, x, y, value)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap2, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap2, rmap, 0.5)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        minmax = list(libtcod.heightmap_get_minmax(rmap))
        return (rmap,minmax)

    def TropicalForestMap(self):
        rmap = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap2 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap3 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        libtcod.heightmap_add_voronoi(rmap3, randrange(500,800), 4, [0.6,0.7,0.8,0.9])
        libtcod.heightmap_scale(rmap3,-0.5)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.noise_set_type(mapnoise, libtcod.NOISE_PERLIN)
        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                f = [3.5 * x / (RMAP_WIDTH - 4),
                     3.5 * y / (RMAP_HEIGHT - 4)]
                value = libtcod.noise_get_turbulence(mapnoise, f, 3)
                libtcod.heightmap_set_value(rmap, x, y, value)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap2, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap2, rmap, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap3, rmap, 0.5)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        minmax = list(libtcod.heightmap_get_minmax(rmap))
        return (rmap,minmax)

    def ShrublandMap(self):
        rmap = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap2 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.noise_set_type(mapnoise, libtcod.NOISE_PERLIN)
        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                f = [3.5 * x / (RMAP_WIDTH - 4),
                     3.5 * y / (RMAP_HEIGHT - 4)]
                value = libtcod.noise_get_turbulence(mapnoise, f, 3)
                libtcod.heightmap_set_value(rmap, x, y, value)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap2, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap2, rmap, 0.5)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        minmax = list(libtcod.heightmap_get_minmax(rmap))
        return (rmap,minmax)

    def HeathlandMap(self):
        rmap = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap2 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.noise_set_type(mapnoise, libtcod.NOISE_PERLIN)
        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                f = [3.5 * x / (RMAP_WIDTH - 4),
                     3.5 * y / (RMAP_HEIGHT - 4)]
                value = libtcod.noise_get_turbulence(mapnoise, f, 3)
                libtcod.heightmap_set_value(rmap, x, y, value)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap2, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap2, rmap, 0.5)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        minmax = list(libtcod.heightmap_get_minmax(rmap))
        return (rmap,minmax)

    def SwampMap(self):
        rmap = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap2 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap3 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap4 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        libtcod.heightmap_add_voronoi(rmap3, randrange(500,800), 4, [0.6,0.7,0.8,0.9])
        libtcod.heightmap_scale(rmap3,-0.5)
        libtcod.heightmap_add_voronoi(rmap4, randrange(2200,4400), 4, [0.6,0.7,0.8,0.9])
        libtcod.heightmap_scale(rmap4,-0.5)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.noise_set_type(mapnoise, libtcod.NOISE_PERLIN)
        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                f = [3.5 * x / (RMAP_WIDTH - 4),
                     3.5 * y / (RMAP_HEIGHT - 4)]
                value = libtcod.noise_get_turbulence(mapnoise, f, 3)
                libtcod.heightmap_set_value(rmap, x, y, value)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap2, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap2, rmap, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap3, rmap, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap4, rmap, 0.5)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        minmax = list(libtcod.heightmap_get_minmax(rmap))
        return (rmap,minmax)

    def MarshlandMap(self):
        rmap = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap2 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap3 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap4 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        libtcod.heightmap_add_voronoi(rmap3, randrange(500,800), 4, [0.6,0.7,0.8,0.9])
        libtcod.heightmap_scale(rmap3,-0.5)
        libtcod.heightmap_add_voronoi(rmap4, randrange(2200,4400), 4, [0.6,0.7,0.8,0.9])
        libtcod.heightmap_scale(rmap4,-0.5)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.noise_set_type(mapnoise, libtcod.NOISE_PERLIN)
        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                f = [3.5 * x / (RMAP_WIDTH - 4),
                     3.5 * y / (RMAP_HEIGHT - 4)]
                value = libtcod.noise_get_turbulence(mapnoise, f, 3)
                libtcod.heightmap_set_value(rmap, x, y, value)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap2, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap2, rmap, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap3, rmap, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap4, rmap, 0.5)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        minmax = list(libtcod.heightmap_get_minmax(rmap))
        return (rmap,minmax)

    def DesertMap(self):
        rmap = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        mapnoise = libtcod.noise_new(3)
        libtcod.noise_set_type(mapnoise, libtcod.NOISE_PERLIN)
        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                f = [3.5 * x / (RMAP_WIDTH - 4),
                     3.5 * y / (RMAP_HEIGHT - 4)]
                value = libtcod.noise_get_turbulence(mapnoise, f, 3)
                libtcod.heightmap_set_value(rmap, x, y, value)
        minmax = list(libtcod.heightmap_get_minmax(rmap))
        return (rmap,minmax)

    def HighlandMap(self):
        rmap = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap2 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        libtcod.heightmap_add_voronoi(rmap2, randrange(500,800), 4, [0.6,0.7,0.8,0.9])
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap2, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap2, rmap, 0.3)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        minmax = list(libtcod.heightmap_get_minmax(rmap))
        return (rmap,minmax)        

    def PlainMap(self):
        rmap = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        rmap2 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.noise_set_type(mapnoise, libtcod.NOISE_PERLIN)
        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                f = [3.5 * x / (RMAP_WIDTH - 4),
                     3.5 * y / (RMAP_HEIGHT - 4)]
                value = libtcod.noise_get_turbulence(mapnoise, f, 3)
                libtcod.heightmap_set_value(rmap, x, y, value)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap2, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        libtcod.heightmap_lerp_hm(rmap, rmap2, rmap, 0.5)
        mapnoise = libtcod.noise_new(randrange(3,5))
        libtcod.heightmap_add_fbm(rmap, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
        minmax = list(libtcod.heightmap_get_minmax(rmap))
        return (rmap,minmax)

    # Map Generation - Sub Terrain Types

    def SubCactiForest(self,rmap):
        pass

    def SubPond(self,rmap):
        pass

    # Map Generation - Minor Algorithms
        
    def rdictSetup(self):

        # Some various lists to help with my faulty memory.

        # Main terrain types:
        ## 'Deciduous Forest','Shrubland','Desert','Heathland','Broadleaf Forest', 
        ## 'Mixed Forest','Coniferous Forest','Evergreen Forest','Swamp', 'Plain', 'Highland','Mountain',
        ## 'Marshland','Tundra','Glacier','Tropical Forest','Savannah','Ocean','Lake'

        # Shrub types:
        ## Generic:
        ### smallyellow1, smallyellow2, smallwhite1, smallgreen1, smallgreen2, smallgreen3, midgreen1,
        ### hugegreen1, hugegreen2, hugeyellow1
        ## Flowering/Berry:
        ### largeberry1, largepurpleflower1, midpinkberry1, largepinkflower1
        ## Primarily tropical:
        ### largetropical1, largetropical2 (bright orange), spikyflower1
        ## Best for dirt/dead areas:
        ### deadtree1, deadtree2, bentsapling1, twistedyellow1
        ## Fungus:
        ### mushroom1, mushroom2, mushroom3, mushroom4, mushroom5
        ## Cacti/Desert:
        ### tinycactus1, fatcactus1, largecactus1, tinycactus2, desertflower1
        ## Tuber/random:
        ### midtuber1, smalltuber1

        # Log types:
        ## Logs - plain:
        ### largelog1, largelog2, midlog1, midlog2, midlog3
        ## Logs - mossy:
        ### largelog3, largelog4
        ## Stumps:
        ### stump1

        # Tree types:
        ## Deciduous:
        ### smallgreen1, smallgreen2, smallyellow1, smallyellow2, smallred, poplar1
        ### largegreen1, largegreen2, largered1, largeyellow1, largewillow1
        ## Coniferous:
        ### smallneedle1, patchpine1, patchfir1, smallfir1, smallcedar1
        ### largecedar1, largeneedle1, largepine1
        ## Tropical:
        ### smallpalm1, smallpalm2, smallpalm3, largepalm1, largepalm2
        
        # Desert
        
        curdict = {}
        curdict['keyidx'] = [0,100,200]
        curdict['keycols'] = [libtcod.Color(216,186,89), libtcod.Color(216,193,116), libtcod.Color(223,205,144)]
        curdict['dkeyidx'] = [0,100,200]
        curdict['dkeycols'] = [libtcod.Color(216,186,89), libtcod.Color(216,193,116), libtcod.Color(223,205,144)]
        curdict['wkeyidx'] = [0,10,40,60]
        curdict['wkeycols'] = [libtcod.Color(23,102,145), libtcod.Color(23,142,187), libtcod.Color(46,192,205), \
                               libtcod.Color(117,147,97)]
        curdict['wlev'] = -1
        curdict['mlev'] = 201
        curdict['mshade'] = [False,180,180,180]
        curdict['treeperc'] = [201,-1,201]
        curdict['tspace'] = [-10,10]
        curdict['treetypes'] = [('Coniferous',1.0)]
        curdict['Coniferous'] = {4: ['smallcedar1']}
        curdict['shrubtypes'] = [('tinycactus1',0.1),('tinycactus2',0.1),('fatcactus1',0.1),('largecactus1',0.2),('desertflower1',0.05),('midtuber1',0.05),('deadtree1',0.02), \
                                 ('deadtree2',0.02),('bentsapling1',0.05),('twistedyellow1',0.05),('smallyellow1',0.05),('smallyellow2',0.05),('smallgreen2',0.05),('smallgreen3',0.05), \
                                 ('smalltuber1',0.03),('spikyflower1',0.03)]
        curdict['dirtshrubtypes'] = [('tinycactus1',0.1),('tinycactus2',0.1),('fatcactus1',0.1),('largecactus1',0.2),('desertflower1',0.05),('midtuber1',0.05),('deadtree1',0.02), \
                                 ('deadtree2',0.02),('bentsapling1',0.05),('twistedyellow1',0.05),('smallyellow1',0.05),('smallyellow2',0.05),('smallgreen2',0.05),('smallgreen3',0.05), \
                                 ('smalltuber1',0.03),('spikyflower1',0.03)]
        curdict['watershrubtypes'] = [('smallyellow1',0.05),('smallyellow2',0.06),('smallgreen1',0.07),('smallgreen2',0.07), \
                                      ('smallgreen3',0.05), ('midgreen1',0.05),('hugegreen1',0.05),('hugegreen2',0.05),('hugeyellow1',0.05), \
                                      ('largeberry1',0.05),('midpinkberry1',0.15),('largepurpleflower1',0.15),('largepinkflower1',0.15)]
        curdict['ferntype'] = None
        curdict['dirtperc'] = 200
        curdict['textperc'] = [-1,200]
        curdict['textshade'] = [-1,200,0.4,4,libtcod.Color(101,90,20),True]
        curdict['scrubperc'] = [190,9,200]
        curdict['soilcol'] = [80,64,46]
        curdict['rockcol'] = [163,164,146]
        curdict['boulderfreq'] = 10000
        curdict['bouldertypes'] = ['smallboulder2','smallboulder4']
        curdict['leafchance'] = [(True,0.0),(False,1.0)]
        curdict['logfreq'] = 4800
        curdict['logtypes'] = ['midlog2','midlog3']
        self.rdict['Desert-Temperate'] = curdict
        self.rdict['Desert-Tropical'] = curdict

        # Forest - Deciduous

        curdict = {}
        curdict['keyidx'] = [0, 2, 4, 5, 7, 62, 102, 189, 190, 192, 200]
        curdict['keycols'] = [libtcod.Color(0,20,60), libtcod.Color(3,111,165), libtcod.Color(37,146,201), \
                              libtcod.Color(143,201,255), libtcod.Color(27,92,18), libtcod.Color(33,94,53), \
                              libtcod.Color(64,98,64), libtcod.Color(79,138,51), libtcod.Color(121,137,80), \
                              libtcod.Color(129,120,105), libtcod.Color(163,164,146)]
        curdict['wkeyidx'] = [0,10,40,60]
        curdict['wkeycols'] = [libtcod.Color(23,102,145), libtcod.Color(23,142,187), libtcod.Color(46,192,205), \
                               libtcod.Color(117,147,97)]
        curdict['dkeyidx'] = [0, 12, 28, 500]
        curdict['dkeycols'] = [libtcod.Color(245,249,192), libtcod.Color(253,209,159), libtcod.Color(196,177,98), libtcod.Color(241,199,149)]
        curdict['wlev'] = 12
        curdict['mlev'] = 188
        curdict['mshade'] = [True,180,180,180]
        curdict['treeperc'] = [110,14,179]
        curdict['tspace'] = [-5,5]
        curdict['treetypes'] = [('Deciduous',1.0)]
        curdict['Deciduous'] = {4: ['smallgreen1','smallgreen2','smallyellow1','smallyellow2','smallred1','poplar1'],
                                5: ['largegreen1','largegreen2','largered1','largeyellow1']}
        curdict['textperc'] = [0,187]
        curdict['textshade'] = [12,200,0.4,3,libtcod.Color(0,55,0),False]
        curdict['scrubperc'] = [25,14,185]
        curdict['shrubtypes'] = [('smallyellow1',0.04),('smallyellow2',0.04),('smallgreen1',0.06),('smallgreen2',0.06), \
                                 ('smallgreen3',0.04), ('midgreen1',0.04),('hugegreen1',0.04),('hugegreen2',0.04),('hugeyellow1',0.04), \
                                 ('largeberry1',0.04),('midpinkberry1',0.04), ('bentsapling1',0.04),('twistedyellow1',0.04),('mushroom1',0.04), \
                                 ('mushroom2',0.04),('mushroom3',0.04),('mushroom4',0.04),('mushroom5',0.04),('fern',0.24)]
        curdict['watershrubtypes'] = [('smallyellow1',0.05),('smallyellow2',0.06),('smallgreen1',0.07),('smallgreen2',0.07), \
                                      ('smallgreen3',0.05), ('midgreen1',0.05),('hugegreen1',0.05),('hugegreen2',0.05),('hugeyellow1',0.05), \
                                      ('largeberry1',0.05),('midpinkberry1',0.15),('largepurpleflower1',0.15),('largepinkflower1',0.15)]
        curdict['dirtshrubtypes'] = [('deadtree1',0.1),('deadtree2',0.1),('bentsapling1',0.2),('twistedyellow1',0.2),('midtuber1',0.1),('smalltuber1',0.1),('fern',0.2)]
        curdict['ferntype'] = 'basicfern'
        curdict['bankweeds'] = True
        curdict['rweedperc'] = [48,56]
        curdict['fernperc'] = 2
        curdict['dirtperc'] = 170
        curdict['soilcol'] = [80,64,46]
        curdict['rockcol'] = [163,164,146]
        curdict['boulderfreq'] = 4000
        curdict['bouldertypes'] = ['largeboulder1','smallboulder1','smallboulder2','smallboulder3','smallboulder4']
        curdict['leafchance'] = [(True,.7),(False,.3)]
        curdict['logfreq'] = 700
        curdict['logtypes'] = ['largelog1','largelog2','largelog3','largelog4','midlog1','midlog2','stump1']
        self.rdict['Deciduous Forest-Temperate'] = curdict
        self.rdict['Deciduous Forest-Tropical'] = curdict

        # Forest - Broadleaf

        curdict = {}
        curdict['keyidx'] = [0, 2, 4, 5, 7, 62, 102, 189, 190, 192, 200]
        curdict['keycols'] = [libtcod.Color(0,20,60), libtcod.Color(3,111,165), libtcod.Color(37,146,201), \
                              libtcod.Color(143,201,255), libtcod.Color(27,92,18), libtcod.Color(33,94,53), \
                              libtcod.Color(64,98,64), libtcod.Color(79,138,51), libtcod.Color(121,137,80), \
                              libtcod.Color(129,120,105), libtcod.Color(163,164,146)]
        curdict['wkeyidx'] = [0,10,40,60]
        curdict['wkeycols'] = [libtcod.Color(23,102,145), libtcod.Color(23,142,187), libtcod.Color(46,192,205), \
                               libtcod.Color(117,147,97)]
        curdict['dkeyidx'] = [0, 12, 28, 500]
        curdict['dkeycols'] = [libtcod.Color(245,249,192), libtcod.Color(253,209,159), libtcod.Color(196,177,98), libtcod.Color(241,199,149)]
        curdict['wlev'] = 12
        curdict['mlev'] = 188
        curdict['mshade'] = [True,180,180,180]
        curdict['treeperc'] = [110,14,179]
        curdict['tspace'] = [-5,5]
        curdict['treetypes'] = [('Deciduous',1.0)]
        curdict['Deciduous'] = {4: ['smallgreen1','smallgreen2','smallyellow1','smallyellow2','smallred1','poplar1'],
                                5: ['largegreen1','largegreen2','largered1','largeyellow1']}
        curdict['textperc'] = [0,187]
        curdict['textshade'] = [12,200,0.4,3,libtcod.Color(0,55,0),False]
        curdict['scrubperc'] = [25,14,185]
        curdict['shrubtypes'] = [('smallyellow1',0.04),('smallyellow2',0.04),('smallgreen1',0.06),('smallgreen2',0.06), \
                                 ('smallgreen3',0.04), ('midgreen1',0.04),('hugegreen1',0.04),('hugegreen2',0.04),('hugeyellow1',0.04), \
                                 ('largeberry1',0.04),('midpinkberry1',0.04), ('bentsapling1',0.04),('twistedyellow1',0.04),('mushroom1',0.04), \
                                 ('mushroom2',0.04),('mushroom3',0.04),('mushroom4',0.04),('mushroom5',0.04),('fern',0.24)]
        curdict['watershrubtypes'] = [('smallyellow1',0.05),('smallyellow2',0.06),('smallgreen1',0.07),('smallgreen2',0.07), \
                                      ('smallgreen3',0.05), ('midgreen1',0.05),('hugegreen1',0.05),('hugegreen2',0.05),('hugeyellow1',0.05), \
                                      ('largeberry1',0.05),('midpinkberry1',0.15),('largepurpleflower1',0.15),('largepinkflower1',0.15)]
        curdict['dirtshrubtypes'] = [('deadtree1',0.1),('deadtree2',0.1),('bentsapling1',0.2),('twistedyellow1',0.2),('midtuber1',0.1),('smalltuber1',0.1),('fern',0.2)]
        curdict['ferntype'] = 'basicfern'
        curdict['bankweeds'] = True
        curdict['rweedperc'] = [48,56]
        curdict['fernperc'] = 2
        curdict['dirtperc'] = 170
        curdict['soilcol'] = [80,64,46]
        curdict['rockcol'] = [163,164,146]
        curdict['boulderfreq'] = 4000
        curdict['bouldertypes'] = ['largeboulder1','smallboulder1','smallboulder2','smallboulder3','smallboulder4']
        curdict['leafchance'] = [(True,.7),(False,.3)]
        curdict['logfreq'] = 700
        curdict['logtypes'] = ['largelog1','largelog2','largelog3','largelog4','midlog1','midlog2','stump1']
        self.rdict['Broadleaf Forest-Temperate'] = curdict
        self.rdict['Broadleaf Forest-Tropical'] = curdict
        
        # Forest - Mixed Forest

        curdict = {}
        curdict['keyidx'] = [0, 2, 4, 5, 7, 62, 102, 189, 190, 192, 200]
        curdict['keycols'] = [libtcod.Color(0,20,60), libtcod.Color(3,111,165), libtcod.Color(37,146,201), \
                              libtcod.Color(143,201,255), libtcod.Color(27,92,18), libtcod.Color(33,94,53), \
                              libtcod.Color(64,98,64), libtcod.Color(79,138,51), libtcod.Color(121,137,80), \
                              libtcod.Color(129,120,105), libtcod.Color(163,164,146)]
        curdict['wkeyidx'] = [0,10,40,60]
        curdict['wkeycols'] = [libtcod.Color(23,102,145), libtcod.Color(23,142,187), libtcod.Color(46,192,205), \
                               libtcod.Color(117,147,97)]
        curdict['dkeyidx'] = [0, 12, 28, 500]
        curdict['dkeycols'] = [libtcod.Color(245,249,192), libtcod.Color(253,209,159), libtcod.Color(196,177,98), libtcod.Color(241,199,149)]
        curdict['wlev'] = 12
        curdict['mlev'] = 188
        curdict['mshade'] = [True,180,180,180]
        curdict['treeperc'] = [110,14,179]
        curdict['tspace'] = [-5,5]
        curdict['treetypes'] = [('Deciduous',0.6),('Coniferous',0.4)]
        curdict['Deciduous'] = {4: ['smallgreen1','smallgreen2','smallyellow1','smallyellow2','smallred1','poplar1'],
                                5: ['largegreen1','largegreen2','largered1','largeyellow1']}
        curdict['Coniferous'] = {4: ['smallneedle1','patchpine1','patchfir1','smallfir1','smallcedar1'],5: ['largecedar1','largeneedle1','largepine1']}
        curdict['textperc'] = [0,187]
        curdict['textshade'] = [12,200,0.4,3,libtcod.Color(0,55,0),False]
        curdict['scrubperc'] = [25,14,185]
        curdict['shrubtypes'] = [('smallyellow1',0.04),('smallyellow2',0.04),('smallgreen1',0.06),('smallgreen2',0.06), \
                                 ('smallgreen3',0.04), ('midgreen1',0.04),('hugegreen1',0.04),('hugegreen2',0.04),('hugeyellow1',0.04), \
                                 ('largeberry1',0.04),('midpinkberry1',0.04), ('bentsapling1',0.04),('twistedyellow1',0.04),('mushroom1',0.04), \
                                 ('mushroom2',0.04),('mushroom3',0.04),('mushroom4',0.04),('mushroom5',0.04),('fern',0.24)]
        curdict['watershrubtypes'] = [('smallyellow1',0.05),('smallyellow2',0.06),('smallgreen1',0.07),('smallgreen2',0.07), \
                                      ('smallgreen3',0.05), ('midgreen1',0.05),('hugegreen1',0.05),('hugegreen2',0.05),('hugeyellow1',0.05), \
                                      ('largeberry1',0.05),('midpinkberry1',0.15),('largepurpleflower1',0.15),('largepinkflower1',0.15)]
        curdict['dirtshrubtypes'] = [('deadtree1',0.1),('deadtree2',0.1),('bentsapling1',0.2),('twistedyellow1',0.2),('midtuber1',0.1),('smalltuber1',0.1),('fern',0.2)]
        curdict['ferntype'] = 'basicfern'
        curdict['bankweeds'] = True
        curdict['rweedperc'] = [48,56]
        curdict['fernperc'] = 2
        curdict['dirtperc'] = 170
        curdict['soilcol'] = [80,64,46]
        curdict['rockcol'] = [163,164,146]
        curdict['boulderfreq'] = 4000
        curdict['bouldertypes'] = ['largeboulder1','smallboulder1','smallboulder2','smallboulder3','smallboulder4']
        curdict['leafchance'] = [(True,.7),(False,.3)]
        curdict['logfreq'] = 700
        curdict['logtypes'] = ['largelog1','largelog2','largelog3','largelog4','midlog1','midlog2','stump1']
        self.rdict['Mixed Forest-Temperate'] = curdict

        # Forest - Coniferous

        curdict = {}
        curdict['keyidx'] = [0, 2, 4, 5, 7, 62, 102, 186, 188, 192, 200]
        curdict['keycols'] = [libtcod.Color(69,118,31), libtcod.Color(73,125,36), libtcod.Color(76,134,43), \
                              libtcod.Color(85,145,45), libtcod.Color(107,161,58), libtcod.Color(115,168,63), \
                              libtcod.Color(122,171,70), libtcod.Color(126,152,85), libtcod.Color(121,137,80), \
                              libtcod.Color(129,120,105), libtcod.Color(163,164,146)]
        curdict['wkeyidx'] = [0,10,40,60]
        curdict['wkeycols'] = [libtcod.Color(23,102,145), libtcod.Color(23,142,187), libtcod.Color(46,192,205), \
                               libtcod.Color(117,147,97)]
        curdict['dkeyidx'] = [0, 12, 28, 500]
        curdict['dkeycols'] = [libtcod.Color(245,249,192), libtcod.Color(253,209,159), libtcod.Color(196,177,98), libtcod.Color(241,199,149)]
        curdict['wlev'] = 12
        curdict['mlev'] = 188
        curdict['mshade'] = [True,180,180,180]
        curdict['treeperc'] = [140,14,179]
        curdict['tspace'] = [-5,5]
        curdict['treetypes'] = [('Deciduous',0.05),('Coniferous',0.95)]
        curdict['Deciduous'] = {4: ['smallgreen1','smallgreen2','smallyellow1','smallyellow2','smallred1','poplar1'],
                                5: ['largegreen1','largegreen2','largered1','largeyellow1']}
        curdict['Coniferous'] = {4: ['smallneedle1','patchpine1','patchfir1','smallfir1','smallcedar1'],5: ['largecedar1','largeneedle1','largepine1']}
        curdict['textperc'] = [0,187]
        curdict['textshade'] = [12,200,0.4,3,libtcod.Color(0,55,0),False]
        curdict['scrubperc'] = [25,14,185]
        curdict['shrubtypes'] = [('smallyellow1',0.04),('smallyellow2',0.04),('smallgreen1',0.06),('smallgreen2',0.06), \
                                 ('smallgreen3',0.04), ('midgreen1',0.04),('hugegreen1',0.04),('hugegreen2',0.04),('hugeyellow1',0.04), \
                                 ('largeberry1',0.04),('midpinkberry1',0.04), ('bentsapling1',0.04),('twistedyellow1',0.04),('mushroom1',0.04), \
                                 ('mushroom2',0.04),('mushroom3',0.04),('mushroom4',0.04),('mushroom5',0.04),('fern',0.24)]
        curdict['dirtshrubtypes'] = [('deadtree1',0.1),('deadtree2',0.1),('bentsapling1',0.2),('twistedyellow1',0.2),('midtuber1',0.1),('smalltuber1',0.1),('fern',0.2)]
        curdict['watershrubtypes'] = [('smallyellow1',0.05),('smallyellow2',0.06),('smallgreen1',0.07),('smallgreen2',0.07), \
                                      ('smallgreen3',0.05), ('midgreen1',0.05),('hugegreen1',0.05),('hugegreen2',0.05),('hugeyellow1',0.05), \
                                      ('largeberry1',0.05),('midpinkberry1',0.15),('largepurpleflower1',0.15),('largepinkflower1',0.15)]
        curdict['ferntype'] = 'basicfern'
        curdict['bankweeds'] = True
        curdict['rweedperc'] = [48,56]
        curdict['fernperc'] = 2
        curdict['dirtperc'] = 170
        curdict['soilcol'] = [80,64,46]
        curdict['rockcol'] = [163,164,146]
        curdict['bouldertypes'] = ['largeboulder1','smallboulder1','smallboulder2','smallboulder3','smallboulder4']
        curdict['boulderfreq'] = 4000
        curdict['leafchance'] = [(True,.7),(False,.3)]
        curdict['logfreq'] = 700
        curdict['logtypes'] = ['largelog1','largelog2','largelog3','largelog4','midlog1','midlog2','stump1']
        self.rdict['Coniferous Forest-Temperate'] = curdict

        # Forest - Evergreen

        curdict = {}
        curdict['keyidx'] = [0, 2, 4, 5, 7, 62, 102, 186, 188, 192, 200]
        curdict['keycols'] = [libtcod.Color(69,118,31), libtcod.Color(73,125,36), libtcod.Color(76,134,43), \
                              libtcod.Color(85,145,45), libtcod.Color(107,161,58), libtcod.Color(115,168,63), \
                              libtcod.Color(122,171,70), libtcod.Color(126,152,85), libtcod.Color(121,137,80), \
                              libtcod.Color(129,120,105), libtcod.Color(163,164,146)]
        curdict['wkeyidx'] = [0,10,40,60]
        curdict['wkeycols'] = [libtcod.Color(23,102,145), libtcod.Color(23,142,187), libtcod.Color(46,192,205), \
                               libtcod.Color(117,147,97)]
        curdict['dkeyidx'] = [0, 12, 28, 500]
        curdict['dkeycols'] = [libtcod.Color(245,249,192), libtcod.Color(253,209,159), libtcod.Color(196,177,98), libtcod.Color(241,199,149)]
        curdict['wlev'] = 12
        curdict['mlev'] = 188
        curdict['mshade'] = [True,180,180,180]
        curdict['treeperc'] = [140,14,179]
        curdict['tspace'] = [-5,5]
        curdict['treetypes'] = [('Deciduous',0.05),('Coniferous',0.95)]
        curdict['Deciduous'] = {4: ['smallgreen1','smallgreen2','smallyellow1','smallyellow2','smallred1','poplar1'],
                                5: ['largegreen1','largegreen2','largered1','largeyellow1']}
        curdict['Coniferous'] = {4: ['smallneedle1','patchpine1','patchfir1','smallfir1','smallcedar1'],5: ['largecedar1','largeneedle1','largepine1']}
        curdict['textperc'] = [0,187]
        curdict['textshade'] = [12,200,0.4,3,libtcod.Color(0,55,0),False]
        curdict['scrubperc'] = [25,14,185]
        curdict['shrubtypes'] = [('smallyellow1',0.04),('smallyellow2',0.04),('smallgreen1',0.06),('smallgreen2',0.06), \
                                 ('smallgreen3',0.04), ('midgreen1',0.04),('hugegreen1',0.04),('hugegreen2',0.04),('hugeyellow1',0.04), \
                                 ('largeberry1',0.04),('midpinkberry1',0.04), ('bentsapling1',0.04),('twistedyellow1',0.04),('mushroom1',0.04), \
                                 ('mushroom2',0.04),('mushroom3',0.04),('mushroom4',0.04),('mushroom5',0.04),('fern',0.24)]
        curdict['dirtshrubtypes'] = [('deadtree1',0.1),('deadtree2',0.1),('bentsapling1',0.2),('twistedyellow1',0.2),('midtuber1',0.1),('smalltuber1',0.1),('fern',0.2)]
        curdict['watershrubtypes'] = [('smallyellow1',0.05),('smallyellow2',0.06),('smallgreen1',0.07),('smallgreen2',0.07), \
                                      ('smallgreen3',0.05), ('midgreen1',0.05),('hugegreen1',0.05),('hugegreen2',0.05),('hugeyellow1',0.05), \
                                      ('largeberry1',0.05),('midpinkberry1',0.15),('largepurpleflower1',0.15),('largepinkflower1',0.15)]
        curdict['ferntype'] = 'basicfern'
        curdict['bankweeds'] = True
        curdict['rweedperc'] = [48,56]
        curdict['fernperc'] = 2
        curdict['dirtperc'] = 170
        curdict['soilcol'] = [80,64,46]
        curdict['rockcol'] = [163,164,146]
        curdict['bouldertypes'] = ['largeboulder1','smallboulder1','smallboulder2','smallboulder3','smallboulder4']
        curdict['boulderfreq'] = 4000
        curdict['leafchance'] = [(True,.7),(False,.3)]
        curdict['logfreq'] = 700
        curdict['logtypes'] = ['largelog1','largelog2','largelog3','largelog4','midlog1','midlog2','stump1']
        self.rdict['Evergreen Forest-Temperate'] = curdict

        # Forest - Tropical

        curdict = {}
        curdict['keyidx'] = [0, 2, 4, 5, 7, 62, 102, 189, 190, 192, 200]
        curdict['keycols'] = [libtcod.Color(0,20,60), libtcod.Color(3,111,165), libtcod.Color(37,146,201), \
                              libtcod.Color(143,201,255), libtcod.Color(27,92,18), libtcod.Color(33,94,53), \
                              libtcod.Color(64,98,64), libtcod.Color(79,138,51), libtcod.Color(121,137,80), \
                              libtcod.Color(129,120,105), libtcod.Color(163,164,146)]
        curdict['wkeyidx'] = [0,10,40,60]
        curdict['wkeycols'] = [libtcod.Color(23,102,145), libtcod.Color(23,142,187), libtcod.Color(46,192,205), \
                               libtcod.Color(117,147,97)]
        tcols = [libtcod.Color(6,47,1), libtcod.Color(21,73,15), libtcod.Color(29,88,23)]
        for col in range(len(curdict['keycols'])):
            colfrac = (len(curdict['keycols']) * 1.0) / (len(tcols) * 1.0)
            colnum = int((col * 1.0) / (colfrac * 1.0))
            newcol = libtcod.color_lerp(curdict['keycols'][col],tcols[colnum],0.4)
            curdict['keycols'][col] = newcol
        curdict['dkeyidx'] = [0, 12, 28, 500]
        curdict['dkeycols'] = [libtcod.Color(245,249,192), libtcod.Color(253,209,159), libtcod.Color(196,177,98), libtcod.Color(241,199,149)]
        curdict['wlev'] = 8
        curdict['mlev'] = 188
        curdict['mshade'] = [True,180,180,180]
        curdict['treeperc'] = [130,10,175]
        curdict['tspace'] = [-5,5]
        curdict['treetypes'] = [('Deciduous',0.5),('Tropical',0.5)]
        curdict['Deciduous'] = {4: ['smallgreen1','smallgreen2','smallyellow1','smallyellow2','smallred1','poplar1'],
                                5: ['largegreen1','largegreen2','largered1','largeyellow1']}
        curdict['Tropical'] = {4: ['smallpalm1','smallpalm2','smallpalm3'],5: ['largepalm1','largepalm2']}
        curdict['copsechance'] = 500
        curdict['copses'] = ['tropicalcopse1','tropicalcopse2']
        curdict['textperc'] = [0,187]
        curdict['textshade'] = [8,200,0.4,3,libtcod.Color(0,55,0),False]
        curdict['scrubperc'] = [11,8,185]
        curdict['shrubtypes'] = [('smallyellow1',0.02),('spikyflower1',0.09),('smallgreen1',0.06), \
                                 ('smallgreen3',0.07), ('midgreen1',0.07),('hugegreen1',0.04),('hugegreen2',0.04),('hugeyellow1',0.04), \
                                 ('largeberry1',0.07),('midpinkberry1',0.07), ('largetropical1',0.07),('largetropical2',0.04),('mushroom1',0.01), \
                                 ('mushroom2',0.01),('mushroom3',0.01),('mushroom4',0.01),('mushroom5',0.01),('fern',0.27)]
        curdict['dirtshrubtypes'] = [('deadtree1',0.1),('deadtree2',0.1),('bentsapling1',0.2),('twistedyellow1',0.2),('midtuber1',0.1),('smalltuber1',0.1),('fern',0.2)]
        curdict['watershrubtypes'] = [('largetropical1',0.05),('largetropical2',0.06),('spikyflower1',0.07),('smallgreen2',0.07), \
                                      ('smallgreen3',0.05), ('midgreen1',0.05),('hugegreen1',0.05),('hugegreen2',0.05),('hugeyellow1',0.05), \
                                      ('largeberry1',0.05),('midpinkberry1',0.15),('largepurpleflower1',0.15),('largepinkflower1',0.15)]
        curdict['ferntype'] = 'basicfern'
        curdict['bankweeds'] = True
        curdict['bankweedperc'] = [42,57]
        curdict['rweedperc'] = [13,42]
        curdict['fernperc'] = 2
        curdict['dirtperc'] = 170
        curdict['soilcol'] = [38,27,19]
        curdict['rockcol'] = [163,164,146]
        curdict['boulderfreq'] = 4000
        curdict['bouldertypes'] = ['largeboulder1','smallboulder1','smallboulder2','smallboulder3','smallboulder4']
        curdict['leafchance'] = [(True,.6),(False,.4)]
        curdict['logfreq'] = 700
        curdict['logtypes'] = ['largelog1','largelog2','largelog3','largelog4','midlog1','midlog2','stump1']
        self.rdict['Tropical Forest-Tropical'] = curdict

        # Shrubland

        curdict = {}
        curdict['keyidx'] = [0, 2, 4, 5, 7, 62, 102, 186, 188, 192, 200]
        curdict['keycols'] = [libtcod.Color(69,118,31), libtcod.Color(73,125,36), libtcod.Color(76,134,43), \
                              libtcod.Color(85,145,45), libtcod.Color(107,161,58), libtcod.Color(115,168,63), \
                              libtcod.Color(122,171,70), libtcod.Color(126,152,85), libtcod.Color(121,137,80), \
                              libtcod.Color(129,120,105), libtcod.Color(163,164,146)]
        curdict['wkeyidx'] = [0,10,40,60]
        curdict['wkeycols'] = [libtcod.Color(23,102,145), libtcod.Color(23,142,187), libtcod.Color(46,192,205), \
                               libtcod.Color(117,147,97)]
        curdict['dkeyidx'] = [0, 12, 28, 500]
        curdict['dkeycols'] = [libtcod.Color(245,249,192), libtcod.Color(253,209,159), libtcod.Color(196,177,98), libtcod.Color(241,199,149)]
        curdict['wlev'] = 12
        curdict['mlev'] = 188
        curdict['mshade'] = [True,180,180,180]
        curdict['treeperc'] = [193,14,185]
        curdict['tspace'] = [-10,10]
        curdict['treetypes'] = [('Deciduous',0.05),('Coniferous',0.95)]
        curdict['Deciduous'] = {4: ['smallgreen1','smallgreen2','smallyellow1','smallyellow2','smallred1','poplar1'],
                                5: ['largegreen1','largegreen2','largered1','largeyellow1']}
        curdict['Coniferous'] = {4: ['smallneedle1','patchpine1','patchfir1','smallfir1','smallcedar1'],5: ['largecedar1','largeneedle1','largepine1']}
        curdict['textperc'] = [0,187]
        curdict['textshade'] = [12,200,0.4,3,libtcod.Color(0,55,0),False]
        curdict['scrubperc'] = [22,14,185]
        curdict['shrubtypes'] = [('smallyellow1',0.06),('smallyellow2',0.06),('smallgreen1',0.06),('midgreen1',0.1),('hugegreen1',0.07), \
                                 ('hugegreen2',0.09),('hugeyellow1',0.07),('largeberry1',0.04),('midpinkberry1',0.04), ('bentsapling1',0.04), \
                                 ('twistedyellow1',0.08),('mushroom1',0.01),('mushroom2',0.01),('mushroom3',0.01),('mushroom4',0.01),('mushroom5',0.01),('fern',0.24)]
        curdict['dirtshrubtypes'] = [('deadtree1',0.1),('deadtree2',0.1),('bentsapling1',0.2),('twistedyellow1',0.2),('midtuber1',0.1),('smalltuber1',0.1),('fern',0.2)]
        curdict['watershrubtypes'] = [('smallyellow1',0.05),('smallyellow2',0.06),('smallgreen1',0.07),('smallgreen2',0.07), \
                                      ('smallgreen3',0.05), ('midgreen1',0.05),('hugegreen1',0.05),('hugegreen2',0.05),('hugeyellow1',0.05), \
                                      ('largeberry1',0.05),('midpinkberry1',0.15),('largepurpleflower1',0.15),('largepinkflower1',0.15)]
        curdict['ferntype'] = 'basicfern'
        curdict['bankweeds'] = True
        curdict['rweedperc'] = [48,56]
        curdict['fernperc'] = 2
        curdict['dirtperc'] = 170
        curdict['soilcol'] = [80,64,46]
        curdict['rockcol'] = [163,164,146]
        curdict['boulderfreq'] = 4000
        curdict['bouldertypes'] = ['largeboulder1','smallboulder1','smallboulder2','smallboulder3','smallboulder4']
        curdict['leafchance'] = [(True,.7),(False,.3)]
        curdict['logfreq'] = 1500
        curdict['logtypes'] = ['largelog1','largelog2','largelog3','largelog4','midlog1','midlog2','stump1']
        self.rdict['Shrubland-Temperate'] = curdict
        self.rdict['Shrubland-Tropical'] = curdict

        # Heathland

        curdict = {}
        curdict['keyidx'] = [0, 2, 4, 5, 7, 62, 102, 189, 190, 192, 200]
        curdict['keycols'] = [libtcod.Color(34,69,45), libtcod.Color(38,118,100), libtcod.Color(56,140,122), \
                              libtcod.Color(114,173,150), libtcod.Color(67,126,38), libtcod.Color(74,131,58), \
                              libtcod.Color(93,134,67), libtcod.Color(102,145,68), libtcod.Color(121,137,80), \
                              libtcod.Color(129,120,105), libtcod.Color(163,164,146)]
        desertcols = [libtcod.Color(216,186,89), libtcod.Color(216,193,116), libtcod.Color(223,205,144)]
        for col in range(len(curdict['keycols'])):
            colfrac = (len(curdict['keycols']) * 1.0) / (len(desertcols) * 1.0)
            colnum = int((col * 1.0) / (colfrac * 1.0))
            newcol = libtcod.color_lerp(curdict['keycols'][col],desertcols[colnum],0.6)
            curdict['keycols'][col] = newcol
        curdict['wkeyidx'] = [0,10,40,60]
        curdict['wkeycols'] = [libtcod.Color(23,102,145), libtcod.Color(23,142,187), libtcod.Color(46,192,205), \
                               libtcod.Color(117,147,97)]
        curdict['dkeyidx'] = [0, 12, 28, 500]
        curdict['dkeycols'] = [libtcod.Color(245,249,192), libtcod.Color(253,209,159), libtcod.Color(196,177,98), libtcod.Color(241,199,149)]
        curdict['wlev'] = 6
        curdict['mlev'] = 188
        curdict['mshade'] = [True,180,180,180]
        curdict['treeperc'] = [193,8,185]
        curdict['tspace'] = [-10,10]
        curdict['treetypes'] = [('Deciduous',0.05),('Coniferous',0.95)]
        curdict['Deciduous'] = {4: ['smallgreen1','smallgreen2','smallyellow1','smallyellow2','smallred1','poplar1'],
                                5: ['largegreen1','largegreen2','largered1','largeyellow1']}
        curdict['Coniferous'] = {4: ['smallneedle1','patchpine1','patchfir1','smallfir1','smallcedar1'],5: ['largecedar1','largeneedle1','largepine1']}
        curdict['textperc'] = [0,187]
        curdict['textshade'] = [6,200,0.4,3,libtcod.Color(0,55,0),False]
        curdict['scrubperc'] = [22,8,185]
        curdict['shrubtypes'] = [('smallyellow1',0.06),('smallyellow2',0.06),('smallgreen1',0.06),('midgreen1',0.1),('hugegreen1',0.07), \
                                 ('hugegreen2',0.09),('hugeyellow1',0.07),('largeberry1',0.04),('midpinkberry1',0.04), ('bentsapling1',0.04), \
                                 ('twistedyellow1',0.08),('mushroom1',0.01),('mushroom2',0.01),('mushroom3',0.01),('mushroom4',0.01),('mushroom5',0.01),('fern',0.24)]
        curdict['dirtshrubtypes'] = [('deadtree1',0.1),('deadtree2',0.1),('bentsapling1',0.2),('twistedyellow1',0.2),('midtuber1',0.1),('smalltuber1',0.1),('fern',0.2)]
        curdict['watershrubtypes'] = [('smallyellow1',0.05),('smallyellow2',0.06),('smallgreen1',0.07),('smallgreen2',0.07), \
                                      ('smallgreen3',0.05), ('midgreen1',0.05),('hugegreen1',0.05),('hugegreen2',0.05),('hugeyellow1',0.05), \
                                      ('largeberry1',0.05),('midpinkberry1',0.15),('largepurpleflower1',0.15),('largepinkflower1',0.15)]
        curdict['ferntype'] = 'basicfern'
        curdict['bankweeds'] = True
        curdict['rweedperc'] = [48,56]
        curdict['fernperc'] = 2
        curdict['dirtperc'] = 170
        curdict['soilcol'] = [156,153,105]
        curdict['rockcol'] = [163,164,146]
        curdict['boulderfreq'] = 4000
        curdict['bouldertypes'] = ['largeboulder1','smallboulder1','smallboulder2','smallboulder3','smallboulder4']
        curdict['leafchance'] = [(True,.7),(False,.3)]
        curdict['logfreq'] = 1500
        curdict['logtypes'] = ['largelog1','largelog2','largelog3','largelog4','midlog1','midlog2','stump1']
        self.rdict['Heathland-Temperate'] = curdict
        self.rdict['Heathland-Tropical'] = curdict

        # Marshland

        curdict = {}
        curdict['keyidx'] = [0, 2, 4, 5, 7, 62, 102, 186, 188, 192, 200]
        curdict['keycols'] = [libtcod.Color(69,118,31), libtcod.Color(73,125,36), libtcod.Color(76,134,43), \
                              libtcod.Color(85,145,45), libtcod.Color(107,161,58), libtcod.Color(115,168,63), \
                              libtcod.Color(122,171,70), libtcod.Color(126,152,85), libtcod.Color(121,137,80), \
                              libtcod.Color(129,120,105), libtcod.Color(163,164,146)]
        curdict['wkeyidx'] = [0,10,40,60]
        curdict['wkeycols'] = [libtcod.Color(23,102,145), libtcod.Color(23,142,187), libtcod.Color(46,192,205), \
                               libtcod.Color(117,147,97)]
        tcols = [libtcod.Color(117,122,94), libtcod.Color(128,138,61), libtcod.Color(95,127,76)]
        for col in range(len(curdict['keycols'])):
            colfrac = (len(curdict['keycols']) * 1.0) / (len(tcols) * 1.0)
            colnum = int((col * 1.0) / (colfrac * 1.0))
            newcol = libtcod.color_lerp(curdict['keycols'][col],tcols[colnum],0.7)
            curdict['keycols'][col] = newcol
        wcols = [libtcod.Color(59,108,76), libtcod.Color(100,161,128), libtcod.Color(93,123,146)]
        for col in range(len(curdict['wkeycols'])):
            colfrac = (len(curdict['wkeycols']) * 1.0) / (len(wcols) * 1.0)
            colnum = int((col * 1.0) / (colfrac * 1.0))
            newcol = libtcod.color_lerp(curdict['wkeycols'][col],wcols[colnum],0.8)
            curdict['wkeycols'][col] = newcol
        curdict['dkeyidx'] = [0, 12, 28, 500]
        curdict['dkeycols'] = [libtcod.Color(245,249,192), libtcod.Color(253,209,159), libtcod.Color(196,177,98), libtcod.Color(241,199,149)]
        curdict['wlev'] = 17
        curdict['mlev'] = 188
        curdict['mshade'] = [True,180,180,180]
        curdict['treeperc'] = [183,19,175]
        curdict['radperc'] = [(4,.3),(5,.7)]
        curdict['tspace'] = [-8,8]
        curdict['treetypes'] = [('Deciduous',1.0)]
        curdict['Deciduous'] = {4: ['smallgreen1','smallgreen2','smallyellow1','smallyellow2','poplar1','poplar1'],
                                5: ['largegreen1','largegreen2','largeyellow1','largewillow1','largewillow1','largewillow1']}
        curdict['textperc'] = [0,187]
        curdict['textshade'] = [8,200,0.4,3,libtcod.Color(0,55,0),False]
        curdict['scrubperc'] = [16,8,185]
        curdict['shrubtypes'] = [('smallyellow1',0.04),('smallyellow2',0.03),('smallgreen1',0.03),('midgreen1',0.07),('hugegreen1',0.07), \
                                 ('hugegreen2',0.04),('hugeyellow1',0.07),('largeberry1',0.04),('midpinkberry1',0.04), ('bentsapling1',0.04), \
                                 ('twistedyellow1',0.03),('mushroom1',0.02),('mushroom2',0.02),('mushroom3',0.02),('mushroom4',0.02),('mushroom5',0.02),('fern',0.24), \
                                 ('deadtree1',0.05),('deadtree2',0.05),('midtuber1',0.03),('smalltuber1',0.03)]
        curdict['dirtshrubtypes'] = [('deadtree1',0.1),('deadtree2',0.1),('bentsapling1',0.2),('twistedyellow1',0.2),('midtuber1',0.1),('smalltuber1',0.1),('fern',0.2)]
        curdict['watershrubtypes'] = [('smallyellow1',0.04),('smallyellow2',0.03),('smallgreen1',0.03),('midgreen1',0.07),('hugegreen1',0.07), \
                                 ('hugegreen2',0.04),('hugeyellow1',0.07),('largeberry1',0.04),('midpinkberry1',0.04), ('bentsapling1',0.04), \
                                 ('twistedyellow1',0.03),('mushroom1',0.02),('mushroom2',0.02),('mushroom3',0.02),('mushroom4',0.02),('mushroom5',0.02),('fern',0.24), \
                                 ('deadtree1',0.05),('deadtree2',0.05),('midtuber1',0.03),('smalltuber1',0.03)]
        curdict['ferntype'] = 'basicfern'
        curdict['bankweeds'] = True
        curdict['bankweedperc'] = [42,57]
        curdict['rweedperc'] = [13,42]
        curdict['fernperc'] = 2
        curdict['dirtperc'] = 190
        curdict['grasscol'] = libtcod.brass
        curdict['soilcol'] = [38,27,19]
        curdict['rockcol'] = [163,164,146]
        curdict['boulderfreq'] = 4000
        curdict['bouldertypes'] = ['largeboulder1','smallboulder1','smallboulder2','smallboulder3','smallboulder4']
        curdict['leafchance'] = [(True,.6),(False,.4)]
        curdict['logfreq'] = 400
        curdict['logtypes'] = ['largelog1','largelog2','largelog3','largelog4','midlog1','midlog2','stump1']
        self.rdict['Marshland-Temperate'] = curdict

        # Swamp

        curdict = {}
        curdict['keyidx'] = [0, 2, 4, 5, 7, 62, 102, 189, 190, 192, 200]
        curdict['keycols'] = [libtcod.Color(0,20,60), libtcod.Color(3,111,165), libtcod.Color(37,146,201), \
                              libtcod.Color(143,201,255), libtcod.Color(27,92,18), libtcod.Color(33,94,53), \
                              libtcod.Color(64,98,64), libtcod.Color(79,138,51), libtcod.Color(121,137,80), \
                              libtcod.Color(129,120,105), libtcod.Color(163,164,146)]
        curdict['wkeyidx'] = [0,10,40,60]
        curdict['wkeycols'] = [libtcod.Color(23,102,145), libtcod.Color(23,142,187), libtcod.Color(46,192,205), \
                               libtcod.Color(117,147,97)]
        tcols = [libtcod.Color(117,122,94), libtcod.Color(128,138,61), libtcod.Color(95,127,76)]
        for col in range(len(curdict['keycols'])):
            colfrac = (len(curdict['keycols']) * 1.0) / (len(tcols) * 1.0)
            colnum = int((col * 1.0) / (colfrac * 1.0))
            newcol = libtcod.color_lerp(curdict['keycols'][col],tcols[colnum],0.7)
            curdict['keycols'][col] = newcol
        wcols = [libtcod.Color(59,108,76), libtcod.Color(100,161,128), libtcod.Color(93,123,146)]
        for col in range(len(curdict['wkeycols'])):
            colfrac = (len(curdict['wkeycols']) * 1.0) / (len(wcols) * 1.0)
            colnum = int((col * 1.0) / (colfrac * 1.0))
            newcol = libtcod.color_lerp(curdict['wkeycols'][col],wcols[colnum],0.8)
            curdict['wkeycols'][col] = newcol
        curdict['dkeyidx'] = [0, 12, 28, 500]
        curdict['dkeycols'] = [libtcod.Color(245,249,192), libtcod.Color(253,209,159), libtcod.Color(196,177,98), libtcod.Color(241,199,149)]
        curdict['wlev'] = 20
        curdict['mlev'] = 188
        curdict['mshade'] = [True,180,180,180]
        curdict['treeperc'] = [130,22,175]
        curdict['radperc'] = [(4,.3),(5,.7)]
        curdict['tspace'] = [-8,8]
        curdict['treetypes'] = [('Deciduous',1.0)]
        curdict['Deciduous'] = {4: ['smallgreen1','smallgreen2','smallyellow1','smallyellow2','poplar1','poplar1'],
                                5: ['largegreen1','largegreen2','largeyellow1','largewillow1','largewillow1','largewillow1']}
        curdict['textperc'] = [0,187]
        curdict['textshade'] = [8,200,0.4,3,libtcod.Color(0,55,0),False]
        curdict['scrubperc'] = [16,8,185]
        curdict['shrubtypes'] = [('smallyellow1',0.04),('smallyellow2',0.03),('smallgreen1',0.03),('midgreen1',0.07),('hugegreen1',0.07), \
                                 ('hugegreen2',0.04),('hugeyellow1',0.07),('largeberry1',0.04),('midpinkberry1',0.04), ('bentsapling1',0.04), \
                                 ('twistedyellow1',0.03),('mushroom1',0.02),('mushroom2',0.02),('mushroom3',0.02),('mushroom4',0.02),('mushroom5',0.02),('fern',0.24), \
                                 ('deadtree1',0.05),('deadtree2',0.05),('midtuber1',0.03),('smalltuber1',0.03)]
        curdict['dirtshrubtypes'] = [('deadtree1',0.1),('deadtree2',0.1),('bentsapling1',0.2),('twistedyellow1',0.2),('midtuber1',0.1),('smalltuber1',0.1),('fern',0.2)]
        curdict['watershrubtypes'] = [('smallyellow1',0.04),('smallyellow2',0.03),('smallgreen1',0.03),('midgreen1',0.07),('hugegreen1',0.07), \
                                 ('hugegreen2',0.04),('hugeyellow1',0.07),('largeberry1',0.04),('midpinkberry1',0.04), ('bentsapling1',0.04), \
                                 ('twistedyellow1',0.03),('mushroom1',0.02),('mushroom2',0.02),('mushroom3',0.02),('mushroom4',0.02),('mushroom5',0.02),('fern',0.24), \
                                 ('deadtree1',0.05),('deadtree2',0.05),('midtuber1',0.03),('smalltuber1',0.03)]
        curdict['ferntype'] = 'basicfern'
        curdict['bankweeds'] = True
        curdict['bankweedperc'] = [42,57]
        curdict['rweedperc'] = [13,42]
        curdict['fernperc'] = 2
        curdict['dirtperc'] = 190
        curdict['grasscol'] = libtcod.brass
        curdict['soilcol'] = [38,27,19]
        curdict['rockcol'] = [163,164,146]
        curdict['boulderfreq'] = 4000
        curdict['bouldertypes'] = ['largeboulder1','smallboulder1','smallboulder2','smallboulder3','smallboulder4']
        curdict['leafchance'] = [(True,.6),(False,.4)]
        curdict['logfreq'] = 400
        curdict['logtypes'] = ['largelog1','largelog2','largelog3','largelog4','midlog1','midlog2','stump1']
        self.rdict['Swamp-Temperate'] = curdict

        # Highland
        curdict = {}
        curdict['keyidx'] = [0, 2, 4, 5, 7, 62, 102, 186, 188, 192, 200]
        curdict['keycols'] = [libtcod.Color(69,118,31), libtcod.Color(73,125,36), libtcod.Color(76,134,43), \
                              libtcod.Color(85,145,45), libtcod.Color(107,161,58), libtcod.Color(115,168,63), \
                              libtcod.Color(122,171,70), libtcod.Color(126,152,85), libtcod.Color(121,137,80), \
                              libtcod.Color(129,120,105), libtcod.Color(163,164,146)]
        curdict['wkeyidx'] = [0,10,40,60]
        curdict['wkeycols'] = [libtcod.Color(23,102,145), libtcod.Color(23,142,187), libtcod.Color(46,192,205), \
                               libtcod.Color(117,147,97)]
        curdict['dkeyidx'] = [0, 12, 28, 500]
        curdict['dkeycols'] = [libtcod.Color(245,249,192), libtcod.Color(253,209,159), libtcod.Color(196,177,98), libtcod.Color(241,199,149)]
        curdict['wlev'] = -1
        curdict['mlev'] = 187
        curdict['mshade'] = [True,180,180,180]
        curdict['treeperc'] = [185,0,179]
        curdict['tspace'] = [-10,10]
        curdict['treetypes'] = [('Deciduous',0.3),('Coniferous',0.7)]
        curdict['Deciduous'] = {4: ['smallgreen1','smallgreen2','smallyellow1','smallyellow2','smallred1','poplar1'],
                                5: ['largegreen1','largegreen2','largered1','largeyellow1']}
        curdict['Coniferous'] = {4: ['smallneedle1', 'patchpine1', 'patchfir1', 'smallfir1', 'smallcedar1'],5: ['largecedar1','largeneedle1','largepine1']}
        curdict['textperc'] = [0,187]
        curdict['textshade'] = [0,200,0.5,3,libtcod.Color(0,55,0),True]
        curdict['scrubperc'] = [35,0,184]
        curdict['shrubtypes'] = [('smallyellow1',0.04),('smallyellow2',0.04),('smallgreen1',0.06),('smallgreen2',0.06), \
                                 ('smallgreen3',0.04), ('midgreen1',0.04),('hugegreen1',0.04),('hugegreen2',0.04),('hugeyellow1',0.04), \
                                 ('largeberry1',0.04),('midpinkberry1',0.04), ('bentsapling1',0.04),('twistedyellow1',0.04),('mushroom1',0.04), \
                                 ('mushroom2',0.04),('mushroom3',0.04),('mushroom4',0.04),('mushroom5',0.04),('fern',0.24)]
        curdict['watershrubtypes'] = [('smallyellow1',0.05),('smallyellow2',0.05),('smallgreen1',0.05),('smallgreen2',0.05), \
                                      ('smallgreen3',0.05), ('midgreen1',0.06),('hugegreen1',0.07),('hugegreen2',0.07),('hugeyellow1',0.05), \
                                      ('largeberry1',0.05),('midpinkberry1',0.15),('largepurpleflower1',0.15),('largepinkflower1',0.15)]
        curdict['dirtshrubtypes'] = [('smallyellow1',0.04),('smallyellow2',0.04),('smallgreen1',0.08),('smallgreen2',0.04), \
                                     ('smallgreen3',0.08), ('midgreen1',0.08),('hugegreen1',0.08),('hugegreen2',0.08),('hugeyellow1',0.04), \
                                     ('deadtree1',0.08),('deadtree2',0.08),('bentsapling1',0.08),('twistedyellow1',0.04),('midtuber1',0.08),('smalltuber1',0.08)]
        curdict['ferntype'] = 'basicfern'
        curdict['bankweeds'] = True
        curdict['rweedperc'] = [48,56]
        curdict['fernperc'] = 2
        curdict['dirtperc'] = 155
        curdict['soilcol'] = [92,91,69]
        curdict['rockcol'] = [163,164,146]
        curdict['boulderfreq'] = 1000
        curdict['bouldertypes'] = ['largeboulder1','smallboulder1','smallboulder2','smallboulder3','smallboulder4']
        curdict['leafchance'] = [(True,0.0),(False,1.0)]
        curdict['logfreq'] = 1500
        curdict['logtypes'] = ['largelog1','largelog2','midlog2','stump1']
        self.rdict['Highland-Temperate'] = curdict
        self.rdict['Highland-Tropical'] = curdict

        curdict = {}
        curdict['keyidx'] = [0, 2, 4, 5, 8, 25, 102, 188, 189, 191, 200]
        curdict['keycols'] = [libtcod.Color(0,20,60), libtcod.Color(3,111,165), libtcod.Color(37,146,201), \
                              libtcod.Color(143,201,255), libtcod.Color(255,255,255), libtcod.Color(232,232,232), \
                              libtcod.Color(245,245,245), libtcod.Color(255,255,255), libtcod.Color(163,164,146), \
                              libtcod.Color(129,120,105), libtcod.Color(255,255,255)]
        curdict['wkeyidx'] = [0,10,40,60]
        curdict['wkeycols'] = [libtcod.Color(189,217,239), libtcod.Color(156,195,218), libtcod.Color(151,190,206), \
                               libtcod.Color(99,167,196)]
        curdict['wlev'] = -1
        curdict['mlev'] = 187
        curdict['mshade'] = [True,180,180,180]
        curdict['treeperc'] = [185,0,179]
        curdict['treetypes'] = [('Coniferous',1.0)]
        curdict['Coniferous'] = {4: ['snowcedar','snowpine','smallsnoweg'],5: ['largesnoweg','largesnoweg2']}
        curdict['textperc'] = [0,188]
        curdict['textshade'] = [0,200,0.4,3,libtcod.Color(25,25,25),True]
        curdict['scrubperc'] = [35,0,184]
        curdict['soilcol'] = [92,91,69]
        curdict['rockcol'] = [163,164,146]
        curdict['boulderfreq'] = 1000
        curdict['leafchance'] = [(True,0.0),(False,1.0)]
        self.rdict['Highland-Arctic'] = curdict

        # Plains
        curdict = {}
        curdict['keyidx'] = [0, 2, 4, 5, 7, 62, 102, 189, 190, 192, 200]
        curdict['keycols'] = [libtcod.Color(0,20,60), libtcod.Color(3,111,165), libtcod.Color(37,146,201), \
                              libtcod.Color(143,201,255), libtcod.Color(27,92,18), libtcod.Color(33,94,53), \
                              libtcod.Color(64,98,64), libtcod.Color(79,138,51), libtcod.Color(121,137,80), \
                              libtcod.Color(129,120,105), libtcod.Color(163,164,146)]
        curdict['wkeyidx'] = [0,10,40,60]
        curdict['wkeycols'] = [libtcod.Color(23,102,145), libtcod.Color(23,142,187), libtcod.Color(46,192,205), \
                               libtcod.Color(117,147,97)]
        curdict['dkeyidx'] = [0, 12, 28, 500]
        curdict['dkeycols'] = [libtcod.Color(245,249,192), libtcod.Color(253,209,159), libtcod.Color(196,177,98), libtcod.Color(241,199,149)]
        
        curdict['wlev'] = 12
        curdict['mlev'] = 188
        curdict['mshade'] = [True,180,180,180]
        curdict['treeperc'] = [190,14,185]
        curdict['tspace'] = [-10,10]
        curdict['treetypes'] = [('Deciduous',0.8),('Coniferous',0.2)]
        curdict['Deciduous'] = {4: ['smallgreen1','smallgreen2','smallyellow1','smallyellow2','smallred1','poplar1'],
                                5: ['largegreen1','largegreen2','largered1','largeyellow1']}
        curdict['Coniferous'] = {4: ['smallneedle1', 'patchpine1', 'patchfir1', 'smallfir1', 'smallcedar1'],5: ['largecedar1','largeneedle1','largepine1']}
        curdict['textperc'] = [12,188]
        curdict['textshade'] = [12,200,0.4,3,libtcod.Color(0,55,0),False]
        curdict['scrubperc'] = [42,14,185]
        curdict['shrubtypes'] = [('smallyellow1',0.04),('smallyellow2',0.04),('smallgreen1',0.06),('midgreen1',0.1),('hugegreen1',0.07), \
                                 ('hugegreen2',0.09),('hugeyellow1',0.07),('largeberry1',0.04),('midpinkberry1',0.06), ('bentsapling1',0.06), \
                                 ('twistedyellow1',0.08),('mushroom1',0.01),('mushroom2',0.01),('mushroom3',0.01),('mushroom4',0.01),('mushroom5',0.01),('fern',0.24)]
        curdict['watershrubtypes'] = [('smallyellow1',0.05),('smallyellow2',0.05),('smallgreen1',0.05),('smallgreen2',0.05), \
                                      ('smallgreen3',0.05), ('midgreen1',0.06),('hugegreen1',0.07),('hugegreen2',0.07),('hugeyellow1',0.05), \
                                      ('largeberry1',0.05),('midpinkberry1',0.15),('largepurpleflower1',0.15),('largepinkflower1',0.15)]
        curdict['dirtshrubtypes'] = [('smallyellow1',0.04),('smallyellow2',0.04),('smallgreen2',0.12), ('midgreen1',0.08),('hugegreen1',0.08), \
                                     ('hugegreen2',0.12),('hugeyellow1',0.08),('deadtree1',0.08),('deadtree2',0.08),('bentsapling1',0.08), \
                                     ('twistedyellow1',0.04),('midtuber1',0.08),('smalltuber1',0.08)]
        curdict['ferntype'] = 'basicfern'
        curdict['bankweeds'] = True
        curdict['rweedperc'] = [48,56]
        curdict['fernperc'] = 2
        curdict['dirtperc'] = 170
        curdict['soilcol'] = [80,64,46]
        curdict['rockcol'] = [163,164,146]
        curdict['boulderfreq'] = 4000
        curdict['bouldertypes'] = ['largeboulder1','smallboulder1','smallboulder2','smallboulder3','smallboulder4']
        curdict['leafchance'] = [(True,.4),(False,.6)]
        curdict['logfreq'] = 1500
        curdict['logtypes'] = ['largelog1','largelog2','largelog3','largelog4','midlog1','midlog2','stump1']
        self.rdict['Plain-Temperate'] = curdict
        self.rdict['Plain-Tropical'] = curdict

        curdict = {}
        curdict['keyidx'] = [0, 2, 4, 5, 8, 25, 102, 188, 189, 191, 200]
        curdict['keycols'] = [libtcod.Color(0,20,60), libtcod.Color(3,111,165), libtcod.Color(37,146,201), \
                              libtcod.Color(143,201,255), libtcod.Color(255,255,255), libtcod.Color(232,232,232), \
                              libtcod.Color(245,245,245), libtcod.Color(255,255,255), libtcod.Color(163,164,146), \
                              libtcod.Color(129,120,105), libtcod.Color(255,255,255)]
        curdict['wkeyidx'] = [0,10,40,60]
        curdict['wkeycols'] = [libtcod.Color(189,217,239), libtcod.Color(156,195,218), libtcod.Color(151,190,206), \
                               libtcod.Color(99,167,196)]
        curdict['wlev'] = 7
        curdict['mlev'] = 188
        curdict['mshade'] = [True,180,180,180]
        curdict['treeperc'] = [190,9,185]
        curdict['treetypes'] = [('Coniferous',1.0)]
        curdict['Coniferous'] = {4: ['snowcedar','snowpine','smallsnoweg'],5: ['largesnoweg','largesnoweg2']}
        curdict['textperc'] = [6,188]
        curdict['textshade'] = [6,200,0.4,3,libtcod.Color(185,219,228),True]
        curdict['scrubperc'] = [55,9,185]
        curdict['soilcol'] = [80,64,46]
        curdict['rockcol'] = [163,164,146]
        curdict['boulderfreq'] = 4000
        curdict['leafchance'] = [(True,0.0),(False,1.0)]
        curdict['logfreq'] = 0
        curdict['logtypes'] = [None]
        self.rdict['Plain-Arctic'] = curdict

    def doRegion(self, rtypes = None):
        global MouseLock, MoveLock, pathlock, PCX, PCY, Clouds, hpcswitch, moveclouds, DoLoadScreen
        if not self.regiondict.get('%s,%s' % (self.curregion[0],self.curregion[1])):
            if not rtypes:
                rtypes = wbiomedict['%s,%s' % (self.curregion[0],self.curregion[1])]
            MouseLock,MoveLock = True,True
            Clouds.killswitch = True
            hpcswitch = False
            PCX,PCY = (RMAP_WIDTH / 2) - 1,(RMAP_HEIGHT / 2)
            GameWorld.window = wrwindow
            GameWorld.windowswitch = True
            adjustScreen()
            self.addMesg('Generating map, one moment...',col = libtcod.light_orange)
            libtcod.console_set_default_background(LoadScreen,libtcod.magenta)
            libtcod.console_clear(LoadScreen)
            DoLoadScreen = True
            GameWorld.rswitch = True
            self.genMap(rtypes)
            time.sleep(1.0)
            q.put('genproc-terrain')
            q.put('genproc-trees')
            q.put('genproc-scrub')
            q.put('genproc-misc')
            while not q.empty():
                time.sleep(0.1)
                MoveLock,MouseLock = True,True
            moveclouds = False
            Clouds = CloudNoise(wrwindow,rheightmap)
            Clouds.start()
            time.sleep(0.5)
            DoLoadScreen = False
            self.rinit = True
            hpcswitch = True
            MouseLock,MoveLock = False,False
        else:
            MouseLock,MoveLock = True,True
            Clouds.killswitch = True
            hpcswitch = False
            PCX,PCY = (RMAP_WIDTH / 2) - 1,(RMAP_HEIGHT / 2)
            libtcod.console_set_default_background(wrwindow, libtcod.black)
            libtcod.console_clear(wrwindow)
            GameWorld.window = wrwindow
            GameWorld.windowswitch = True
            adjustScreen()
            GameWorld.rswitch = True
            self.addMesg('Loading map...',col = libtcod.light_orange)
            moveclouds = False
            self.loadMap(self.curregion)
            time.sleep(0.5)
            self.rinit = True
            hpcswitch = True
            MouseLock,MoveLock = False,False
            
    def cmpTiles(self,t1,t2):
        if isinstance(self.rheightmap['%s,%s' % (t1[0],t1[1])],int) and isinstance(self.rheightmap['%s,%s' % (t2[0],t2[1])],str):
            return True
        elif isinstance(self.rheightmap['%s,%s' % (t1[0],t1[1])],str) and isinstance(self.rheightmap['%s,%s' % (t2[0],t2[1])],int):
            return False
        elif self.rheightmap['%s,%s' % (t1[0],t1[1])] > self.rheightmap['%s,%s' % (t2[0],t2[1])]:
            return True
        else:
            return False
        
    def digRiver(self):
        global PCX,PCY
        ntiles,stiles,etiles,wtiles = [],[],[],[]
        for x in range(20,RMAP_WIDTH - 20):
            ntiles.append((x,0))
            stiles.append((x,RMAP_HEIGHT - 1))
        for y in range(20,RMAP_HEIGHT - 20):
            wtiles.append((0,y))
            etiles.append((RMAP_WIDTH - 1,y))
        edgetiles = {}
        edgetiles['e'] = etiles
        edgetiles['w'] = wtiles
        edgetiles['n'] = ntiles
        edgetiles['s'] = stiles
        rivdirs = wrivdirdict['%s,%s' % (self.curregion[0],self.curregion[1])][0]
        tributes = wrivdirdict['%s,%s' % (self.curregion[0],self.curregion[1])][1]

        # Create non-pathable areas to lend some randomness to the directions rivers move in (instead of an ugly, totally straight line).
        rivobdict = {}
        for x in range(RMAP_WIDTH):
            for y in range(RMAP_HEIGHT):
                if randrange(4) == 1:
                    rivobdict['%s,%s' % (x,y)] = 'blocked'

        # Now merge it with the actual dictionary of obstructions so we don't end up with something goofy happening.

        rivobdict = dict(rivobdict.items() + self.wobstructed.items())
        for key in rivobdict.keys():
            if rivobdict[key] == 'mountain':
                rivobdict.pop(key)
        rtiledict = {}
        # If this is the source or mouth of the river...
        if len(rivdirs) == 1:
            dir1 = edgetiles[rivdirs[0]]
            posdirs = ['n','e','s','w']
            posdirs.remove(rivdirs[0])
            randdir = choice(posdirs)
            dir2 = edgetiles[randdir]
            pathlen = 0
            while pathlen < 60:
                p1 = choice(dir1)
                p2 = choice(dir2)
                mainpath = Pathfinder(rivobdict,self.flood,p1[0],p1[1],p2[0],p2[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
                mainpath.start()
                while mainpath.pathgoing:
                    time.sleep(0.1)
                    if mainpath.path == False:
                        mainpath.pathgoing = False
                while mainpath.path == False:
                    p1 = choice(dir1)
                    p2 = choice(dir2)
                    mainpath = Pathfinder(rivobdict,self.flood,p1[0],p1[1],p2[0],p2[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
                    mainpath.start()
                    while mainpath.pathgoing:
                        time.sleep(0.1)
                        if mainpath.path == False:
                            mainpath.pathgoing = False
                pathlen = len(mainpath.path)
            for pathtile in mainpath.path:
                try:
                    self.oltiledict['%s,%s' % (pathtile[0],pathtile[1])]
                    mainpath.path.remove(pathtile)
                except KeyError:
                    pass
            # Get the point which is 1/2 through the path and select it as our fork point.
            halfpoint = len(mainpath.path) / 2
            mainpath.path = mainpath.path[:halfpoint]
            mainend = mainpath.path[-1]

            # Now we're going to dig the river itself...
            if tributes > 2:
                width = 10.0
                wmin,wmax = 8,13
            else:
                width = 7.0
                wmin,wmax = 6,9
            xvar = 0
            yvar = 0
            for tile in mainpath.path:
                randnum = randrange(-5,6)
                wmod = (randnum * 0.1) * choice([-1.0,1.0])
                width = max(min(wmax,width + wmod),wmin)
                wint = int(width)
                for num in range(-wint,wint + 1):
                    for num2 in range(-wint,wint + 1):
                        a = pow(num, 2)
                        b = pow(num2, 2)
                        d = sqrt(a + b)
                        if d < wint:
                            if -1 < tile[0] + num < RMAP_WIDTH and -1 < tile[1] + num2 < RMAP_HEIGHT:
                                distperc = (abs(num) + abs(num2)) / (wint * 1.0) # Larger = farther from center.
                                distperc = min(max(distperc,0),1)
                                if rtiledict.get('%s,%s' % (tile[0] + num,tile[1] + num2)):
                                    if rtiledict['%s,%s' % (tile[0] + num,tile[1] + num2)] < distperc:
                                        continue
                                oheight = self.rheightmap['%s,%s' % (tile[0] + num,tile[1] + num2)]
                                ohtype = type(oheight)
                                if ohtype == int:
                                    distperc = max(0,distperc - 0.231)
                                    oheight += 60
                                else:
                                    oheight = int(oheight.strip('w'))
                                newheight = int(oheight * distperc)
                                if newheight < 60:
                                    rtiledict['%s,%s' % (tile[0] + num,tile[1] + num2)] = distperc
                                    col = self.wcolmap[newheight]
                                    newheight = 'w%s' % newheight
                                else:
                                    col = self.colmap[newheight]
                                libtcod.console_set_char_background(wrwindow, tile[0] + num, tile[1] + num2, col, libtcod.BKGND_SET)
                                self.rterraindict['%s,%s' % (tile[0] + num,tile[1] + num2)] = col
                                self.rheightmap['%s,%s' % (tile[0] + num,tile[1] + num2)] = newheight
                                if type(newheight) == str:
                                    self.wobstructed[self.curz]['%s,%s' % (tile[0] + num,tile[1] + num2)] = 'water'
            
            numsplits = randrange(2,7)
            # And now create paths for each small source.
            for split in range(numsplits):
                splitend = (randrange(MAP_WIDTH),randrange(MAP_HEIGHT))
                dist = sqrt(pow(splitend[0] - mainend[0],2) + pow(splitend[1] - mainend[1],2))
                splitpath = Pathfinder(rivobdict,self.flood,splitend[0],splitend[1],mainend[0],mainend[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
                splitpath.start()
                while splitpath.pathgoing:
                    time.sleep(0.1)
                    if splitpath.path == False:
                        splitpath.pathgoing = False
                while dist > len(mainpath.path) or (not splitpath.path):
                    splitend = (randrange(MAP_WIDTH),randrange(MAP_HEIGHT))          
                    dist = sqrt(pow(splitend[0] - mainend[0],2) + pow(splitend[1] - mainend[1],2))
                    splitpath = Pathfinder(rivobdict,self.flood,splitend[0],splitend[1],mainend[0],mainend[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
                    splitpath.start()
                    while splitpath.pathgoing:
                        if splitpath.path == False:
                            splitpath.pathgoing = False
                        time.sleep(0.1)
                for pathtile in splitpath.path:
                    try:
                        self.oltiledict['%s,%s' % (pathtile[0],pathtile[1])]
                        splitpath.path.remove(pathtile)
                    except KeyError:
                        pass
                width = 2.0
                wmin,wmax = 2,5
                splitlen = len(splitpath.path) * 1.0
                for tile in splitpath.path:
                    dist = sqrt(pow(splitend[0] - mainend[0],2) + pow(splitend[1] - mainend[1],2)) * 1.0
                    splitperc = dist / splitlen
                    randnum = randrange(-5,6)
                    wmod = (randnum * 0.1) * choice([-1.0,1.0])
                    width = max(min(wmax,width + wmod),wmin)
                    wint = int(width)
                    for num in range(-wint,wint + 1):
                        for num2 in range(-wint,wint + 1):
                            a = pow(num, 2)
                            b = pow(num2, 2)
                            d = sqrt(a + b)
                            if d < wint:
                                if -1 < tile[0] + num < RMAP_WIDTH and -1 < tile[1] + num2 < RMAP_HEIGHT:
                                    distperc = (abs(num) + abs(num2)) / (wint * 1.0) # Larger = farther from center.
                                    distperc = min(max(distperc,0),1)
                                    if rtiledict.get('%s,%s' % (tile[0] + num,tile[1] + num2)):
                                        if rtiledict['%s,%s' % (tile[0] + num,tile[1] + num2)] < distperc:
                                            continue
                                    oheight = self.rheightmap['%s,%s' % (tile[0] + num,tile[1] + num2)]
                                    ohtype = type(oheight)
                                    if ohtype == int:
                                        distperc = max(0,distperc - 0.231)
                                        oheight += 60
                                    else:
                                        oheight = int(oheight.strip('w'))
                                    newheight = int(oheight * distperc)
                                    if newheight < 60:
                                        rtiledict['%s,%s' % (tile[0] + num,tile[1] + num2)] = distperc
                                        col = self.wcolmap[newheight]
                                        newheight = 'w%s' % newheight
                                    else:
                                        col = self.colmap[newheight]
                                    libtcod.console_set_char_background(wrwindow, tile[0] + num, tile[1] + num2, col, libtcod.BKGND_SET)
                                    self.rterraindict['%s,%s' % (tile[0] + num,tile[1] + num2)] = col
                                    self.rheightmap['%s,%s' % (tile[0] + num,tile[1] + num2)] = newheight
                                    if type(newheight) == str:
                                        self.wobstructed[self.curz]['%s,%s' % (tile[0] + num,tile[1] + num2)] = 'water'
                
        else:            
            # Otherwise, if this is just a segment of the river...
            if len(rivdirs) == 2:
                dir1 = edgetiles[rivdirs[0]]
                dir2 = edgetiles[rivdirs[1]]
            else:
                if 'e' in rivdirs and 'w' in rivdirs:
                    dir1 = edgetiles['e']
                    dir2 = edgetiles['w']
                    rivdirs.remove('e')
                    rivdirs.remove('w')
                else:
                    dir1 = edgetiles['n']
                    dir2 = edgetiles['s']
                    rivdirs.remove('n')
                    rivdirs.remove('s')
            p1 = choice(dir1)
            p2 = choice(dir2)
            path = Pathfinder(rivobdict,self.flood,p1[0],p1[1],p2[0],p2[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
            path.start()
            while path.pathgoing:
                time.sleep(0.1)
                if path.path == False:
                    path.pathgoing = False
            while path.path == False:
                p1 = choice(dir1)
                p2 = choice(dir2)
                path = Pathfinder(rivobdict,self.flood,p1[0],p1[1],p2[0],p2[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
                path.start()
                while path.pathgoing:
                    time.sleep(0.1)
                    if path.path == False:
                        path.pathgoing = False
            for pathtile in copy.copy(path.path):
                try:
                    self.oltiledict['%s,%s' % (pathtile[0],pathtile[1])]
                    path.path.remove(pathtile)
                except KeyError:
                    pass
            rivpathdict = {}
            if tributes > 2:
                width = 10.0
                wmin,wmax = 8,13
            else:
                width = 5.0
                wmin,wmax = 6,9
            xvar = 0
            yvar = 0
            for tile in path.path:
                randnum = randrange(-5,6)
                wmod = (randnum * 0.1) * choice([-1.0,1.0])
                width = max(min(wmax,width + wmod),wmin)
                wint = int(width)
                for num in range(-wint,wint + 1):
                    for num2 in range(-wint,wint + 1):
                        a = pow(num, 2)
                        b = pow(num2, 2)
                        d = sqrt(a + b)
                        if d < wint:
                            if -1 < tile[0] + num < RMAP_WIDTH and -1 < tile[1] + num2 < RMAP_HEIGHT:
                                distperc = (abs(num) + abs(num2)) / (wint * 1.0) # Larger = farther from center.
                                distperc = min(max(distperc,0),1)
                                if rtiledict.get('%s,%s' % (tile[0] + num,tile[1] + num2)):
                                    if rtiledict['%s,%s' % (tile[0] + num,tile[1] + num2)] < distperc:
                                        continue
                                oheight = self.rheightmap['%s,%s' % (tile[0] + num,tile[1] + num2)]
                                ohtype = type(oheight)
                                if ohtype == int:
                                    distperc = max(0,distperc - 0.231)
                                    oheight += 60
                                else:
                                    oheight = int(oheight.strip('w'))
                                newheight = int(oheight * distperc)
                                if newheight < 60:
                                    rtiledict['%s,%s' % (tile[0] + num,tile[1] + num2)] = distperc
                                    col = self.wcolmap[newheight]
                                    newheight = 'w%s' % newheight
                                else:
                                    col = self.colmap[newheight]
                                libtcod.console_set_char_background(wrwindow, tile[0] + num, tile[1] + num2, col, libtcod.BKGND_SET)
                                self.rterraindict['%s,%s' % (tile[0] + num,tile[1] + num2)] = col
                                self.rheightmap['%s,%s' % (tile[0] + num,tile[1] + num2)] = newheight
                                if type(newheight) == str:
                                    self.wobstructed[self.curz]['%s,%s' % (tile[0] + num,tile[1] + num2)] = 'water'

            # Is this the intersection of two rivers?
            if len(rivdirs) == 1:
                jointile = choice(rtiledict.keys())
                jointile = [int(jointile.split(',')[0]),int(jointile.split(',')[1])]
                dir3 = edgetiles[rivdirs[0]]
                if rivdirs[0] == 'n':
                    dirchange = [0,-1]
                elif rivdirs[0] == 's':
                    dirchange = [0,1]
                elif rivdirs[0] == 'e':
                    dirchange = [1,0]
                elif rivdirs[0] == 'w':
                    dirchange = [-1,0]
                tributes = wrivdirdict['%s,%s' % (self.curregion[0] + dirchange[0],self.curregion[1] + dirchange[1])][1]
                if tributes > 2:
                    width = 10.0
                    wmin,wmax = 7,15
                else:
                    width = 5.0
                    wmin,wmax = 4,9
                etile = choice(dir3)
                path = Pathfinder(rivobdict,self.flood,jointile[0],jointile[1],etile[0],etile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
                path.start()
                while path.pathgoing:
                    time.sleep(0.1)
                    if path.path == False:
                        path.pathgoing = False
                while path.path == False:
                    jointile = choice(rtiledict.keys())
                    jointile = [int(jointile.split(',')[0]),int(jointile.split(',')[1])]
                    etile = choice(dir3)
                    path = Pathfinder(rivobdict,self.flood,jointile[0],jointile[1],etile[0],etile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
                    path.start()
                    while path.pathgoing:
                        time.sleep(0.1)
                        if path.path == False:
                            path.pathgoing = False
                for pathtile in path.path:
                    try:
                        self.oltiledict['%s,%s' % (pathtile[0],pathtile[1])]
                        path.path.remove(pathtile)
                    except KeyError:
                        pass
                for tile in path.path:
                    randnum = randrange(-5,6)
                    wmod = (randnum * 0.1) * choice([-1.0,1.0])
                    width = max(min(wmax,width + wmod),wmin)
                    wint = int(width)
                    for num in range(-wint,wint + 1):
                        for num2 in range(-wint,wint + 1):
                            a = pow(num, 2)
                            b = pow(num2, 2)
                            d = sqrt(a + b)
                            if d < wint:
                                if -1 < tile[0] + num < RMAP_WIDTH and -1 < tile[1] + num2 < RMAP_HEIGHT:
                                    distperc = (abs(num) + abs(num2)) / (wint * 1.0) # Larger = farther from center.
                                    distperc = min(max(distperc + (randrange(-2,3) * 0.01),0),1)
                                    if rtiledict.get('%s,%s' % (tile[0] + num,tile[1] + num2)):
                                        if rtiledict['%s,%s' % (tile[0] + num,tile[1] + num2)] < distperc:
                                            continue
                                    oheight = self.rheightmap['%s,%s' % (tile[0] + num,tile[1] + num2)]
                                    ohtype = type(oheight)
                                    if ohtype == int:
                                        distperc = max(0,distperc - 0.231)
                                        oheight += 60
                                    else:
                                        oheight = int(oheight.strip('w'))
                                    newheight = int(oheight * distperc)
                                    if newheight < 60:
                                        rtiledict['%s,%s' % (tile[0] + num,tile[1] + num2)] = distperc
                                        col = self.wcolmap[newheight]
                                        newheight = 'w%s' % newheight
                                    else:
                                        col = self.colmap[newheight]
                                    libtcod.console_set_char_background(wrwindow, tile[0] + num, tile[1] + num2, col, libtcod.BKGND_SET)
                                    self.rterraindict['%s,%s' % (tile[0] + num,tile[1] + num2)] = col
                                    self.rheightmap['%s,%s' % (tile[0] + num,tile[1] + num2)] = newheight
                                    if type(newheight) == str:
                                        self.wobstructed[self.curz]['%s,%s' % (tile[0] + num,tile[1] + num2)] = 'water'

        # Normalize height values.

        for tile in rtiledict.keys():
            tile = [int(tile.split(',')[0]),int(tile.split(',')[1])]
            for num in range(-1,2):
                for num2 in range(-1,2):
                    try:
                        if isinstance(rheightmap['%s,%s' % (tile[0] + num,tile[1] + num2)],str):
                            oheight = self.rheightmap['%s,%s' % (tile[0],tile[1])]
                            oheight = int(oheight.strip('w'))
                            theight = self.rheightmap['%s,%s' % (tile[0] + num,tile[1] + num2)]
                            theight = int(theight.strip('w'))
                            if theight > oheight:
                                newheight = (oheight + theight) / 2
                                col = self.wcolmap[newheight]
                                newheight = 'w%s' % newheight
                                self.rheightmap['%s,%s' % (tile[0],tile[1])] = newheight
                                self.rterraindict['%s,%s' % (tile[0],tile[1])] = col
                    except KeyError:
                        pass
                    

        for tile in rtiledict.keys():
            tile = [int(tile.split(',')[0]),int(tile.split(',')[1])]
            if randrange(50) == 1:
                boulderchar = choice(rboulderchars)
                self.boulderdict['%s,%s' % (tile[0],tile[1])] = boulderchar
                libtcod.console_set_default_foreground(wrwindow,libtcod.white)
                libtcod.console_print_ex(wrwindow,tile[0],tile[1],libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(boulderchar)))
            else:
                height = self.rheightmap['%s,%s' % (tile[0],tile[1])]
                if type(height) == str:
                    height = int(height.strip('w'))
                if height > 55:
                    char = choice(rweedschars)
                    libtcod.console_set_default_foreground(wrwindow,libtcod.white)
                    libtcod.console_print_ex(wrwindow,tile[0],tile[1],libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
        self.rtiledict = rtiledict
        
    # def __init__(self,wobstructed,areas,x,y,x2,y2,actor = 'PC',domove = True,notify = True)

    def doShoreLine(self):
        global PCX,PCY
        ntiles,stiles,etiles,wtiles = [],[],[],[]
        for x in range(RMAP_WIDTH):
            ntiles.append((x,0))
            stiles.append((x,RMAP_HEIGHT - 1))
        for y in range(RMAP_HEIGHT):
            wtiles.append((0,y))
            etiles.append((RMAP_WIDTH - 1,y))
        edgetiles = {}
        edgetiles['e'] = etiles
        edgetiles['w'] = wtiles
        edgetiles['n'] = ntiles
        edgetiles['s'] = stiles
        wdirs = []

        # Create non-pathable areas to lend some randomness to the shores (instead of an ugly, totally straight line).
        shobdict = {}
        shobdicts = {}
        shobdictn = {}
        shobdicte = {}
        shobdictw = {}
        shobdictnw = {}
        shobdictne = {}
        shobdictsw = {}
        shobdictse = {}
        for x in range(RMAP_WIDTH):
            for y in range(RMAP_HEIGHT):
                if randrange(2) == 1:
                    shobdict['%s,%s' % (x,y)] = 'blocked'
                if x in range(5) or x in range(RMAP_WIDTH - 6,RMAP_WIDTH):
                    shobdictn['%s,%s' % (x,y)] = 'blocked'
                    shobdicts['%s,%s' % (x,y)] = 'blocked'
                if y in range(5) or y in range(RMAP_HEIGHT - 6,RMAP_HEIGHT):
                    shobdicte['%s,%s' % (x,y)] = 'blocked'
                    shobdictw['%s,%s' % (x,y)] = 'blocked'
                if x in range(RMAP_WIDTH / 4) and y in range(RMAP_HEIGHT / 4):
                    shobdictnw['%s,%s' % (x,y)] = 'blocked'
                if x in range((RMAP_WIDTH / 4) * 3,RMAP_WIDTH) and y in range(RMAP_HEIGHT / 4):
                    shobdictne['%s,%s' % (x,y)] = 'blocked'                    
                if x in range(RMAP_WIDTH / 4) and y in range((RMAP_HEIGHT / 4) * 3,RMAP_HEIGHT):
                    shobdictsw['%s,%s' % (x,y)] = 'blocked'     
                if x in range((RMAP_WIDTH / 4) * 3,RMAP_WIDTH) and y in range((RMAP_HEIGHT / 4) * 3,RMAP_HEIGHT):
                    shobdictse['%s,%s' % (x,y)] = 'blocked'     
        # Now merge it with the actual dictionary of obstructions so we don't end up with something goofy happening.

        shobdict = dict(shobdict.items() + self.wobstructed.items())

        if 'o' in wfeaturedict['%s,%s' % (self.curregion[0],self.curregion[1] - 1)] or \
           'l' in wfeaturedict['%s,%s' % (self.curregion[0],self.curregion[1] - 1)]:
            wdirs.append('n')
        if 'o' in wfeaturedict['%s,%s' % (self.curregion[0],self.curregion[1] + 1)] or \
           'l' in wfeaturedict['%s,%s' % (self.curregion[0],self.curregion[1] + 1)]:
            wdirs.append('s')
        if 'o' in wfeaturedict['%s,%s' % (self.curregion[0] + 1,self.curregion[1])] or \
           'l' in wfeaturedict['%s,%s' % (self.curregion[0] + 1,self.curregion[1])]:
            wdirs.append('e')
        if 'o' in wfeaturedict['%s,%s' % (self.curregion[0] - 1,self.curregion[1])] or \
           'l' in wfeaturedict['%s,%s' % (self.curregion[0] - 1,self.curregion[1])]:
            wdirs.append('w')
        if 'o' in wfeaturedict['%s,%s' % (self.curregion[0] - 1,self.curregion[1] - 1)] or \
           'l' in wfeaturedict['%s,%s' % (self.curregion[0] - 1,self.curregion[1] - 1)]:
            wdirs.append('nw')
        if 'o' in wfeaturedict['%s,%s' % (self.curregion[0] + 1,self.curregion[1] - 1)] or \
           'l' in wfeaturedict['%s,%s' % (self.curregion[0] + 1,self.curregion[1] - 1)]:
            wdirs.append('ne')
        if 'o' in wfeaturedict['%s,%s' % (self.curregion[0] - 1,self.curregion[1] + 1)] or \
           'l' in wfeaturedict['%s,%s' % (self.curregion[0] - 1,self.curregion[1] + 1)]:
            wdirs.append('sw')
        if 'o' in wfeaturedict['%s,%s' % (self.curregion[0] + 1,self.curregion[1] + 1)] or \
           'l' in wfeaturedict['%s,%s' % (self.curregion[0] + 1,self.curregion[1] + 1)]:
            wdirs.append('se')
        if 'n' in wdirs:
            mshobdict = dict(shobdict.items() + shobdicte.items() + shobdictw.items())
            etile = random.choice(edgetiles['e'][0:(len(edgetiles['e']) / 4)])
            wtile = random.choice(edgetiles['w'][0:(len(edgetiles['w']) / 4)])
            while mshobdict.get('%s,%s' % (etile[0],etile[1])) or mshobdict.get('%s,%s' % (wtile[0],wtile[1])):
                etile = random.choice(edgetiles['e'][0:(len(edgetiles['e']) / 4)])
                wtile = random.choice(edgetiles['w'][0:(len(edgetiles['w']) / 4)])                
            path = Pathfinder(mshobdict,self.flood,etile[0],etile[1],wtile[0],wtile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
            path.start()            
            while path.pathgoing:
                time.sleep(0.1)
                if path.path == False:
                    path.pathgoing = False
            while path.path == False:
                etile = random.choice(edgetiles['e'][0:(len(edgetiles['e']) / 4)])
                wtile = random.choice(edgetiles['w'][0:(len(edgetiles['w']) / 4)])
                path = Pathfinder(mshobdict,self.flood,etile[0],etile[1],wtile[0],wtile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
                path.start()
                while path.pathgoing:
                    time.sleep(0.1)
                    if path.path == False:
                        path.pathgoing = False
            for pathtile in path.path:
                for tile in range(pathtile[1] + 1):
                    tile = [pathtile[0],tile]
                    try:
                        distperc = float(tile[1]) / float(pathtile[1])
                    except ZeroDivisionError:
                        distperc = 1.0
                    height = int(60 * distperc)
                    wheight = 'w%s' % height
                    try:
                        oheight = self.rheightmap['%s,%s' % (tile[0],tile[1])]
                        oheight = int(oheight.strip('w'))
                        if oheight < height:
                            height = oheight
                            wheight = 'w%s' % height
                    except AttributeError:
                        pass
                    try:
                        oheight = self.rheightmap['%s,%s' % (tile[0],tile[1] + 1)]
                        oheight = int(oheight.strip('w'))
                        if oheight < height:
                            height = oheight
                            wheight = 'w%s' % height
                    except AttributeError:
                        pass
                    col = self.wcolmap[height]
                    libtcod.console_set_char_background(wrwindow, tile[0], tile[1], col, libtcod.BKGND_SET)
                    self.rterraindict['%s,%s' % (tile[0],tile[1])] = col
                    self.rheightmap['%s,%s' % (tile[0],tile[1])] = wheight
                    self.wobstructed[self.curz]['%s,%s' % (tile[0],tile[1])] = 'water'
                    self.oltiledict['%s,%s' % (tile[0],tile[1])] = True
                self.shoretiles['%s,%s,' % (pathtile[0],pathtile[1])] = True
        if 's' in wdirs:
            mshobdict = dict(shobdict.items() + shobdicte.items() + shobdictw.items())
            etile = random.choice(edgetiles['e'][(len(edgetiles['e']) / 4) * 3:])
            wtile = random.choice(edgetiles['w'][(len(edgetiles['w']) / 4) * 3:])
            while mshobdict.get('%s,%s' % (etile[0],etile[1])) or mshobdict.get('%s,%s' % (wtile[0],wtile[1])):
                etile = random.choice(edgetiles['e'][(len(edgetiles['e']) / 4) * 3:])
                wtile = random.choice(edgetiles['w'][(len(edgetiles['w']) / 4) * 3:]) 
            path = Pathfinder(mshobdict,self.flood,etile[0],etile[1],wtile[0],wtile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
            path.start()            
            while path.pathgoing:
                time.sleep(0.1)
                if path.path == False:
                    path.pathgoing = False
            while path.path == False:
                etile = random.choice(edgetiles['e'][(len(edgetiles['e']) / 4) * 3:])
                wtile = random.choice(edgetiles['w'][(len(edgetiles['w']) / 4) * 3:])
                path = Pathfinder(mshobdict,self.flood,etile[0],etile[1],wtile[0],wtile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
                path.start()
                while path.pathgoing:
                    time.sleep(0.1)
                    if path.path == False:
                        path.pathgoing = False
            for pathtile in path.path:
                for tile in range(pathtile[1],RMAP_HEIGHT):
                    tile = [pathtile[0],tile]
                    try:
                        distperc = float(RMAP_HEIGHT - tile[1]) / float(RMAP_HEIGHT - pathtile[1])
                    except ZeroDivisionError:
                        distperc = 1.0
                    height = int(60 * distperc)
                    wheight = 'w%s' % height
                    try:
                        oheight = self.rheightmap['%s,%s' % (tile[0],tile[1])]
                        oheight = int(oheight.strip('w'))
                        if oheight < height:
                            height = oheight
                            wheight = 'w%s' % height
                    except AttributeError:
                        pass
                    try:
                        oheight = self.rheightmap['%s,%s' % (tile[0],tile[1] - 1)]
                        oheight = int(oheight.strip('w'))
                        if oheight < height:
                            height = oheight
                            wheight = 'w%s' % height
                    except AttributeError:
                        pass
                    col = self.wcolmap[height]
                    libtcod.console_set_char_background(wrwindow, tile[0], tile[1], col, libtcod.BKGND_SET)
                    self.rterraindict['%s,%s' % (tile[0],tile[1])] = col
                    self.rheightmap['%s,%s' % (tile[0],tile[1])] = wheight
                    self.wobstructed[self.curz]['%s,%s' % (tile[0],tile[1])] = 'water'
                    self.oltiledict['%s,%s' % (tile[0],tile[1])] = True
                self.shoretiles['%s,%s,' % (pathtile[0],pathtile[1])] = True
        if 'w' in wdirs:
            mshobdict = dict(shobdict.items() + shobdictn.items() + shobdicts.items())
            ntile = random.choice(edgetiles['n'][0:(len(edgetiles['n']) / 4)])
            stile = random.choice(edgetiles['s'][0:(len(edgetiles['s']) / 4)])
            while mshobdict.get('%s,%s' % (ntile[0],ntile[1])) or mshobdict.get('%s,%s' % (stile[0],stile[1])):
                ntile = random.choice(edgetiles['n'][0:(len(edgetiles['n']) / 4)])
                stile = random.choice(edgetiles['s'][0:(len(edgetiles['s']) / 4)])
            path = Pathfinder(mshobdict,self.flood,ntile[0],ntile[1],stile[0],stile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
            path.start()            
            while path.pathgoing:
                time.sleep(0.1)
                if path.path == False:
                    path.pathgoing = False
            while path.path == False:
                ntile = random.choice(edgetiles['n'][0:(len(edgetiles['n']) / 4)])
                stile = random.choice(edgetiles['s'][0:(len(edgetiles['s']) / 4)])
                path = Pathfinder(mshobdict,self.flood,ntile[0],ntile[1],stile[0],stile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
                path.start()
                while path.pathgoing:
                    time.sleep(0.1)
                    if path.path == False:
                        path.pathgoing = False
            for pathtile in path.path:
                for tile in range(pathtile[0]):
                    tile = [tile,pathtile[1]]
                    try:
                        distperc = float(tile[0]) / float(pathtile[0])
                    except ZeroDivisionError:
                        distperc = 1.0
                    height = int(60 * distperc)
                    wheight = 'w%s' % height
                    try:
                        oheight = self.rheightmap['%s,%s' % (tile[0],tile[1])]
                        oheight = int(oheight.strip('w'))
                        if oheight < height:
                            height = oheight
                            wheight = 'w%s' % height
                    except AttributeError:
                        pass
                    try:
                        oheight = self.rheightmap['%s,%s' % (tile[0] + 1,tile[1])]
                        oheight = int(oheight.strip('w'))
                        if oheight < height:
                            height = oheight
                            wheight = 'w%s' % height
                    except AttributeError:
                        pass
                    col = self.wcolmap[height]
                    libtcod.console_set_char_background(wrwindow, tile[0], tile[1], col, libtcod.BKGND_SET)
                    self.rterraindict['%s,%s' % (tile[0],tile[1])] = col
                    self.rheightmap['%s,%s' % (tile[0],tile[1])] = wheight
                    self.wobstructed[self.curz]['%s,%s' % (tile[0],tile[1])] = 'water'
                    self.oltiledict['%s,%s' % (tile[0],tile[1])] = True
                self.shoretiles['%s,%s,' % (pathtile[0],pathtile[1])] = True
        if 'e' in wdirs:
            mshobdict = dict(shobdict.items() + shobdictn.items() + shobdicts.items())
            ntile = random.choice(edgetiles['n'][(len(edgetiles['n']) / 4) * 3:])
            stile = random.choice(edgetiles['s'][(len(edgetiles['s']) / 4) * 3:])
            while mshobdict.get('%s,%s' % (ntile[0],ntile[1])) or mshobdict.get('%s,%s' % (stile[0],stile[1])):
                ntile = random.choice(edgetiles['n'][(len(edgetiles['n']) / 4) * 3:])
                stile = random.choice(edgetiles['s'][(len(edgetiles['s']) / 4) * 3:])
            path = Pathfinder(mshobdict,self.flood,ntile[0],ntile[1],stile[0],stile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
            path.start()            
            while path.pathgoing:
                time.sleep(0.1)
                if path.path == False:
                    path.pathgoing = False
            while path.path == False:
                ntile = random.choice(edgetiles['n'][(len(edgetiles['n']) / 4) * 3:])
                stile = random.choice(edgetiles['s'][(len(edgetiles['s']) / 4) * 3:])
                path = Pathfinder(mshobdict,self.flood,ntile[0],ntile[1],stile[0],stile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
                path.start()
                while path.pathgoing:
                    time.sleep(0.1)
                    if path.path == False:
                        path.pathgoing = False
            for pathtile in path.path:
                for tile in range(pathtile[0],RMAP_WIDTH):
                    tile = [tile,pathtile[1]]
                    try:
                        distperc = float(RMAP_WIDTH - tile[0]) / float(RMAP_WIDTH - pathtile[0])
                    except ZeroDivisionError:
                        distperc = 1.0
                    height = int(60 * distperc)
                    wheight = 'w%s' % height
                    try:
                        oheight = self.rheightmap['%s,%s' % (tile[0],tile[1])]
                        oheight = int(oheight.strip('w'))
                        if oheight < height:
                            height = oheight
                            wheight = 'w%s' % height
                    except AttributeError:
                        pass
                    try:
                        oheight = self.rheightmap['%s,%s' % (tile[0] - 1,tile[1])]
                        oheight = int(oheight.strip('w'))
                        if oheight < height:
                            height = oheight
                            wheight = 'w%s' % height
                    except AttributeError:
                        pass
                    col = self.wcolmap[height]
                    libtcod.console_set_char_background(wrwindow, tile[0], tile[1], col, libtcod.BKGND_SET)
                    self.rterraindict['%s,%s' % (tile[0],tile[1])] = col
                    self.rheightmap['%s,%s' % (tile[0],tile[1])] = wheight
                    self.wobstructed[self.curz]['%s,%s' % (tile[0],tile[1])] = 'water'
                    self.oltiledict['%s,%s' % (tile[0],tile[1])] = True
                self.shoretiles['%s,%s,' % (pathtile[0],pathtile[1])] = True
        if ('nw' in wdirs and 'n' in wdirs and 'w' in wdirs) or \
           ('nw' in wdirs and not ('n' in wdirs or 'w' in wdirs)):
            mshobdict = dict(shobdict.items() + shobdictnw.items())
            ntile = random.choice(edgetiles['n'][0:(len(edgetiles['n']) / 2)])
            wtile = random.choice(edgetiles['w'][0:(len(edgetiles['w']) / 2)])
            while mshobdict.get('%s,%s' % (ntile[0],ntile[1])) or mshobdict.get('%s,%s' % (wtile[0],wtile[1])):
                ntile = random.choice(edgetiles['n'][0:(len(edgetiles['n']) / 2)])
                wtile = random.choice(edgetiles['w'][0:(len(edgetiles['w']) / 2)])
            path = Pathfinder(mshobdict,self.flood,ntile[0],ntile[1],wtile[0],wtile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
            path.start()
            while path.pathgoing:
                time.sleep(0.1)
                if path.path == False:
                    path.pathgoing = False
            while path.path == False:
                ntile = random.choice(edgetiles['n'][0:(len(edgetiles['n']) / 2)])
                wtile = random.choice(edgetiles['w'][0:(len(edgetiles['w']) / 2)])
                path = Pathfinder(mshobdict,self.flood,ntile[0],ntile[1],wtile[0],wtile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
                path.start()
                while path.pathgoing:
                    time.sleep(0.1)
                    if path.path == False:
                        path.pathgoing = False
            for pathtile in path.path:
                for tile in range(pathtile[0]):
                    tile = [tile,pathtile[1]]
                    try:
                        dpercx = float(tile[0]) / float(ntile[0])
                        dpercy = float(tile[1]) / float(wtile[1])
                        distperc = (dpercx + dpercy) * 0.75
                    except ZeroDivisionError:
                        distperc = 1.0
                    distperc = max(min(distperc,1.0),0.0)
                    height = int(60 * distperc)
                    wheight = 'w%s' % height
                    try:
                        oheight = self.rheightmap['%s,%s' % (tile[0],tile[1])]
                        oheight = int(oheight.strip('w'))
                        if oheight < height:
                            height = oheight
                            wheight = 'w%s' % height
                    except AttributeError:
                        pass
                    try:
                        oheight = self.rheightmap['%s,%s' % (tile[0] + 1,tile[1] + 1)]
                        oheight = int(oheight.strip('w'))
                        if oheight < height:
                            height = oheight
                            wheight = 'w%s' % height
                    except AttributeError:
                        pass
                    col = self.wcolmap[height]
                    libtcod.console_set_char_background(wrwindow, tile[0], tile[1], col, libtcod.BKGND_SET)
                    self.rterraindict['%s,%s' % (tile[0],tile[1])] = col
                    self.rheightmap['%s,%s' % (tile[0],tile[1])] = wheight
                    self.wobstructed[self.curz]['%s,%s' % (tile[0],tile[1])] = 'water'
                    self.oltiledict['%s,%s' % (tile[0],tile[1])] = True
                self.shoretiles['%s,%s,' % (pathtile[0],pathtile[1])] = True
        if ('ne' in wdirs and 'n' in wdirs and 'e' in wdirs) or \
           ('ne' in wdirs and not ('n' in wdirs or 'e' in wdirs)):
            mshobdict = dict(shobdict.items() + shobdictne.items())
            ntile = random.choice(edgetiles['n'][0:(len(edgetiles['n']) / 2)])
            etile = random.choice(edgetiles['e'][(len(edgetiles['e']) / 2):])
            while mshobdict.get('%s,%s' % (ntile[0],ntile[1])) or mshobdict.get('%s,%s' % (etile[0],etile[1])):
                ntile = random.choice(edgetiles['n'][0:(len(edgetiles['n']) / 2)])
                etile = random.choice(edgetiles['e'][(len(edgetiles['e']) / 2):])
            path = Pathfinder(mshobdict,self.flood,ntile[0],ntile[1],etile[0],etile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
            path.start()
            while path.pathgoing:
                time.sleep(0.1)
                if path.path == False:
                    path.pathgoing = False
            while path.path == False:
                ntile = random.choice(edgetiles['n'][0:(len(edgetiles['n']) / 2)])
                etile = random.choice(edgetiles['e'][(len(edgetiles['e']) / 2):])
                path = Pathfinder(mshobdict,self.flood,ntile[0],ntile[1],etile[0],etile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
                path.start()
                while path.pathgoing:
                    time.sleep(0.1)
                    if path.path == False:
                        path.pathgoing = False
            for pathtile in path.path:
                for tile in range(pathtile[0],RMAP_WIDTH):
                    tile = [tile,pathtile[1]]
                    try:
                        dpercx = float(RMAP_WIDTH - tile[0]) / float(RMAP_WIDTH - ntile[0])
                        dpercy = float(tile[1]) / float(etile[1])
                        distperc = (dpercx + dpercy) * 0.75
                    except ZeroDivisionError:
                        distperc = 1.0
                    distperc = max(min(distperc,1.0),0.0)
                    height = int(60 * distperc)
                    wheight = 'w%s' % height
                    try:
                        oheight = self.rheightmap['%s,%s' % (tile[0],tile[1])]
                        oheight = int(oheight.strip('w'))
                        if oheight < height:
                            height = oheight
                            wheight = 'w%s' % height
                    except AttributeError:
                        pass
                    try:
                        oheight = self.rheightmap['%s,%s' % (tile[0] - 1,tile[1] + 1)]
                        oheight = int(oheight.strip('w'))
                        if oheight < height:
                            height = oheight
                            wheight = 'w%s' % height
                    except AttributeError:
                        pass
                    col = self.wcolmap[height]
                    libtcod.console_set_char_background(wrwindow, tile[0], tile[1], col, libtcod.BKGND_SET)
                    self.rterraindict['%s,%s' % (tile[0],tile[1])] = col
                    self.rheightmap['%s,%s' % (tile[0],tile[1])] = wheight
                    self.wobstructed[self.curz]['%s,%s' % (tile[0],tile[1])] = 'water'
                    self.oltiledict['%s,%s' % (tile[0],tile[1])] = True
                self.shoretiles['%s,%s,' % (pathtile[0],pathtile[1])] = True
        if ('sw' in wdirs and 's' in wdirs and 'w' in wdirs) or \
           ('sw' in wdirs and not ('s' in wdirs or 'w' in wdirs)):
            mshobdict = dict(shobdict.items() + shobdictsw.items())
            stile = random.choice(edgetiles['s'][0:(len(edgetiles['s']) / 2)])
            wtile = random.choice(edgetiles['w'][(len(edgetiles['w']) / 2):])
            while mshobdict.get('%s,%s' % (stile[0],stile[1])) or mshobdict.get('%s,%s' % (wtile[0],wtile[1])):
                stile = random.choice(edgetiles['s'][0:(len(edgetiles['s']) / 2)])
                wtile = random.choice(edgetiles['w'][(len(edgetiles['w']) / 2):])
            path = Pathfinder(mshobdict,self.flood,stile[0],stile[1],wtile[0],wtile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
            path.start()
            while path.pathgoing:
                time.sleep(0.1)
                if path.path == False:
                    path.pathgoing = False
            while path.path == False:
                stile = random.choice(edgetiles['s'][0:(len(edgetiles['s']) / 2)])
                wtile = random.choice(edgetiles['w'][(len(edgetiles['w']) / 2):])
                path = Pathfinder(mshobdict,self.flood,stile[0],stile[1],wtile[0],wtile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
                path.start()
                while path.pathgoing:
                    time.sleep(0.1)
                    if path.path == False:
                        path.pathgoing = False
            for pathtile in path.path:
                for tile in range(pathtile[0]):
                    tile = [tile,pathtile[1]]
                    try:
                        dpercx = float(tile[0]) / float(stile[0])
                        dpercy = float(RMAP_HEIGHT - tile[1]) / float(RMAP_HEIGHT - wtile[1])
                        distperc = (dpercx + dpercy) * 0.75
                    except ZeroDivisionError:
                        distperc = 1.0
                    distperc = max(min(distperc,1.0),0.0)
                    height = int(60 * distperc)
                    wheight = 'w%s' % height
                    try:
                        oheight = self.rheightmap['%s,%s' % (tile[0],tile[1])]
                        oheight = int(oheight.strip('w'))
                        if oheight < height:
                            height = oheight
                            wheight = 'w%s' % height
                    except AttributeError:
                        pass
                    try:
                        oheight = self.rheightmap['%s,%s' % (tile[0] + 1,tile[1] - 1)]
                        oheight = int(oheight.strip('w'))
                        if oheight < height:
                            height = oheight
                            wheight = 'w%s' % height
                    except AttributeError:
                        pass
                    col = self.wcolmap[height]
                    libtcod.console_set_char_background(wrwindow, tile[0], tile[1], col, libtcod.BKGND_SET)
                    self.rterraindict['%s,%s' % (tile[0],tile[1])] = col
                    self.rheightmap['%s,%s' % (tile[0],tile[1])] = wheight
                    self.wobstructed[self.curz]['%s,%s' % (tile[0],tile[1])] = 'water'
                    self.oltiledict['%s,%s' % (tile[0],tile[1])] = True
                self.shoretiles['%s,%s,' % (pathtile[0],pathtile[1])] = True
        if ('se' in wdirs and 's' in wdirs and 'e' in wdirs) or \
           ('se' in wdirs and not ('s' in wdirs or 'e' in wdirs)):
            mshobdict = dict(shobdict.items() + shobdictse.items())
            stile = random.choice(edgetiles['s'][(len(edgetiles['s']) / 2):])
            etile = random.choice(edgetiles['e'][(len(edgetiles['e']) / 2):])
            while mshobdict.get('%s,%s' % (stile[0],stile[1])) or mshobdict.get('%s,%s' % (etile[0],etile[1])):
                stile = random.choice(edgetiles['s'][(len(edgetiles['s']) / 2):])
                etile = random.choice(edgetiles['e'][(len(edgetiles['e']) / 2):])
            path = Pathfinder(mshobdict,self.flood,stile[0],stile[1],etile[0],etile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
            path.start()
            while path.pathgoing:
                time.sleep(0.1)
                if path.path == False:
                    path.pathgoing = False
            while path.path == False:
                stile = random.choice(edgetiles['s'][(len(edgetiles['s']) / 2):])
                etile = random.choice(edgetiles['e'][(len(edgetiles['e']) / 2):])
                path = Pathfinder(mshobdict,self.flood,stile[0],stile[1],etile[0],etile[1],actor = 'River',domove = False,notify = False,skipareas = True,canswim = True)
                path.start()
                while path.pathgoing:
                    time.sleep(0.1)
                    if path.path == False:
                        path.pathgoing = False
            for pathtile in path.path:
                for tile in range(pathtile[0],RMAP_WIDTH):
                    tile = [tile,pathtile[1]]
                    try:
                        dpercx = float(RMAP_WIDTH - tile[0]) / float(RMAP_WIDTH - stile[0])
                        dpercy = float(RMAP_HEIGHT - tile[1]) / float(RMAP_HEIGHT - etile[1])
                        distperc = (dpercx + dpercy) * 0.75
                    except ZeroDivisionError:
                        distperc = 1.0
                    distperc = max(min(distperc,1.0),0.0)
                    height = int(60 * distperc)
                    wheight = 'w%s' % height
                    try:
                        oheight = self.rheightmap['%s,%s' % (tile[0],tile[1])]
                        oheight = int(oheight.strip('w'))
                        if oheight < height:
                            height = oheight
                            wheight = 'w%s' % height
                    except AttributeError:
                        pass
                    try:
                        oheight = self.rheightmap['%s,%s' % (tile[0] - 1,tile[1] - 1)]
                        oheight = int(oheight.strip('w'))
                        if oheight < height:
                            height = oheight
                            wheight = 'w%s' % height
                    except AttributeError:
                        pass
                    col = self.wcolmap[height]
                    libtcod.console_set_char_background(wrwindow, tile[0], tile[1], col, libtcod.BKGND_SET)
                    self.rterraindict['%s,%s' % (tile[0],tile[1])] = col
                    self.rheightmap['%s,%s' % (tile[0],tile[1])] = wheight
                    self.wobstructed[self.curz]['%s,%s' % (tile[0],tile[1])] = 'water'
                    self.oltiledict['%s,%s' % (tile[0],tile[1])] = True
                self.shoretiles['%s,%s,' % (pathtile[0],pathtile[1])] = True
                
    def doTexture(self,rmap):
        hlist = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['textperc']
        slist = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['textshade']
        self.tallgrassdict = {}
        rtextdict = {}
        self.dirtdict = {}
        
        # Texturize mountains/rock outcroppings.


        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                if isinstance(self.rheightmap['%s,%s' % (x,y)],int):
                    if self.rheightmap['%s,%s' % (x,y)] >= hlist[1]:
                        mshade = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['mshade']
                        if mshade[0]:
                            if self.tempzone == 'Arctic':
                                mcol = libtcod.color_lerp(libtcod.console_get_char_foreground(wrwindow, x, y), libtcod.white, 0.5)
                            else:
                                cn1 = mshade[1]
                                cn2 = mshade[2]
                                cn3 = mshade[3]
                                mcol = libtcod.Color(cn1,cn2,cn3)
                            libtcod.console_set_default_foreground(wrwindow, libtcod.white)
                            if self.rheightmap['%s,%s' % (x,y)] >= hlist[1] + 5:
                                char = choice(mountaincharshigh)
                            else:
                                char = choice(mountaincharslow)
                            libtcod.console_print_ex(wrwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                            rtextdict['%s,%s' % (x,y)] = [char,mcol]

        # Shade mountains, rock outcroppings, and rolling hills.

        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                if slist[1] > self.rheightmap['%s,%s' % (x,y)] > slist[0] and isinstance(self.rheightmap['%s,%s' % (x,y)],int):
                    sperc = 0.0
                    for num in range(0,slist[3] + 1):
                        for num2 in range(-slist[3],1):
                            if self.cmpTiles([min(x + num,RMAP_WIDTH - 1),max(y + num2,0)],[x,y]):
                                if self.rheightmap['%s,%s' % (min(x + num,RMAP_WIDTH - 1),max(y + num2,0))] >= hlist[1]:
                                    sperc += 0.1
                                else:
                                    sperc += 0.05
                    col = libtcod.color_lerp(self.rterraindict['%s,%s' % (x,y)],slist[4],sperc * slist[2])
                    try:
                        rtextdict['%s,%s' % (x,y)]
                        col2 = libtcod.color_lerp(rtextdict['%s,%s' % (x,y)][1],slist[4],sperc * slist[2])
                    except KeyError:
                        col2 = libtcod.color_lerp(libtcod.console_get_char_foreground(wrwindow, x, y),slist[4],sperc * slist[2])
                    libtcod.console_set_char_background(wrwindow, x, y, col, libtcod.BKGND_SET)
                    libtcod.console_set_char_foreground(wrwindow, x, y, col2)
                    self.rterraindict['%s,%s' % (x,y)] = col
                    try:
                        rtextdict['%s,%s' % (x,y)][1] = col2
                    except KeyError:
                        pass
                    if slist[5] or self.rheightmap['%s,%s' % (x,y)] >= hlist[1]:
                        shadow = self.shadowdict['%s,%s' % (x,y)]
                        shadow[0] += sperc * slist[2]
                        self.shadowdict['%s,%s' % (x,y)] = shadow

        # Texturize water.
        
        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                if isinstance(self.rheightmap['%s,%s' % (x,y)],str):
                    if self.tempzone == 'Arctic':
                        bcol = self.rterraindict['%s,%s' % (x,y)]
                        fcol = libtcod.color_lerp(bcol, libtcod.white, .75)
                    else:
                        wadjust = libtcod.Color(10,20,30)
                        bcol = self.rterraindict['%s,%s' % (x,y)]
                        fcol = bcol + wadjust
                    char = choice(waterchars)
                    try:
                        self.boulderdict['%s,%s' % (x,y)]
                        char = self.boulderdict['%s,%s' % (x,y)]
                        fcol = libtcod.white
                        bcol = libtcod.color_lerp(self.rterraindict['%s,%s' % (x,y)],libtcod.black,0.2)
                    except KeyError:
                        pass
                    height = int(self.rheightmap['%s,%s' % (x,y)].strip('w'))
                    if self.rdict['%s-%s' % (self.maintype,self.tempzone)].get('bankweeds'):
                        oltile = False
                        try:
                            self.oltiledict['%s,%s' % (x,y)]
                            oltile = True
                        except KeyError:
                            pass
                        if not oltile:
                            if not self.rdict['%s-%s' % (self.maintype,self.tempzone)].get('bankweedperc'):
                                bankweedperc = [55,57]
                            else:
                                bankweedperc = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['bankweedperc']
                            if height > randrange(bankweedperc[0],bankweedperc[1]):
                                char = choice(bankweedchars)
                                fcol = libtcod.white
                            elif height > randrange(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['rweedperc'][0], \
                                                           self.rdict['%s-%s' % (self.maintype,self.tempzone)]['rweedperc'][1]):
                                char = choice(rweedschars)
                                fcol = libtcod.white
                    libtcod.console_set_default_foreground(wrwindow, fcol)
                    libtcod.console_set_default_background(wrwindow, bcol)
                    libtcod.console_print_ex(wrwindow, x, y, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                    rtextdict['%s,%s' % (x,y)] = [char,fcol]

        # Texturize grass/dirt.

        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                if rheightmap['%s,%s' % (x,y)] in range(hlist[0] + 1,hlist[1]):
                    if self.tempzone == 'Arctic':
                        bcol = self.rterraindict['%s,%s' % (x,y)]
                        fcol = libtcod.color_lerp(bcol, libtcod.white, .75)
                        libtcod.console_set_default_foreground(wrwindow, fcol)
                        char = choice(snowchars)
                    elif self.maintype == 'Desert' and self.tempzone in ['Temperate','Tropical']:
                        bcol = self.rterraindict['%s,%s' % (x,y)]
                        fcol = libtcod.color_lerp(bcol,libtcod.white,randrange(60,100) * 0.01)
                        libtcod.console_set_default_foreground(wrwindow,fcol)
                        char = choice(desertchars)
                        self.dirtdict['%s,%s' % (x,y)] = True
                    else:
                        midpoint = (hlist[1] + hlist[0]) / 2
                        quarterpoint = (hlist[0] + midpoint) / 2
                        threeeighthspoint = (midpoint + quarterpoint) / 2
                        waternear = False
                        neg = randrange(-10,-5)
                        pos = randrange(5,10)
                        for num in range(neg,pos):
                            for num2 in range(neg,pos):
                                try:
                                    if type(rheightmap['%s,%s' % (x + num,y + num2)]) == str:
                                        waternear = True
                                except KeyError:
                                    pass
                        if rheightmap['%s,%s' % (x,y)] > threeeighthspoint and not waternear:
                            fcol = libtcod.white
                            if self.rdict['%s-%s' % (self.maintype,self.tempzone)].get('grasscol'):
                                fcol = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['grasscol']
                            libtcod.console_set_default_foreground(wrwindow, fcol)
                            char = choice(grasschars)
                        elif threeeighthspoint > rheightmap['%s,%s' % (x,y)] > quarterpoint and not waternear:
                            bcol = self.rterraindict['%s,%s' % (x,y)]
                            fcol = libtcod.color_lerp(bcol,libtcod.white,.75)
                            if self.rdict['%s-%s' % (self.maintype,self.tempzone)].get('grasscol'):
                                fcol = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['grasscol']
                            libtcod.console_set_default_foreground(wrwindow, fcol)
                            char = choice(midgrasschars)
                            self.tallgrassdict['%s,%s' % (x,y)] = True
                        else:
                            fcol = libtcod.white
                            if self.rdict['%s-%s' % (self.maintype,self.tempzone)].get('grasscol'):
                                fcol = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['grasscol']
                            libtcod.console_set_default_foreground(wrwindow,fcol)
                            char = choice(tallgrasschars)
                            self.tallgrassdict['%s,%s' % (x,y)] = True
                    if self.tempzone != 'Arctic':
                        for num in range(-4,5):
                            for num2 in range(-4,5):
                                try:
                                    if type(self.rheightmap['%s,%s' % (x + num,y + num2)]) == str:
                                        if randrange(15) == 1:
                                            fcol = libtcod.white
                                            libtcod.console_set_default_foreground(wrwindow,fcol)
                                            char = choice(thickgrasschars)
                                except KeyError:
                                    pass
                    if self.rdict['%s-%s' % (self.maintype,self.tempzone)].get('grasscol'):
                        libtcod.console_set_default_background(wrwindow,self.rdict['%s-%s' % (self.maintype,self.tempzone)]['grasscol'])
                        libtcod.console_print_ex(wrwindow, x, y, libtcod.BKGND_ALPHA(0.4), libtcod.LEFT, chr(DoChar(char)))
                        newbgcol = libtcod.color_lerp(self.rterraindict['%s,%s' % (x,y)],self.rdict['%s-%s' % (self.maintype,self.tempzone)]['grasscol'],0.4)
                        self.rterraindict['%s,%s' % (x,y)] = newbgcol
                    else:
                        libtcod.console_print_ex(wrwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                    rtextdict['%s,%s' % (x,y)] = [char,fcol]
                    
        # Create bare patches of dirt.

        if self.rdict['%s-%s' % (self.maintype,self.tempzone)].get('dirtperc'):
            dmap = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
            dmap2 = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
            mapnoise = libtcod.noise_new(randrange(3,5))
            libtcod.noise_set_type(mapnoise, libtcod.NOISE_PERLIN)
            for y in range(RMAP_HEIGHT):
                for x in range(RMAP_WIDTH):
                    f = [3.5 * x / (RMAP_WIDTH - 4),
                         3.5 * y / (RMAP_HEIGHT - 4)]
                    value = libtcod.noise_get_turbulence(mapnoise, f, 3)
                    libtcod.heightmap_set_value(dmap, x, y, value)
            mapnoise = libtcod.noise_new(randrange(3,5))
            libtcod.heightmap_add_fbm(dmap2, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
            libtcod.heightmap_lerp_hm(dmap, dmap2, dmap, 0.5)
            libtcod.heightmap_lerp_hm(dmap, rmap, dmap, 0.3)
            mapnoise = libtcod.noise_new(randrange(3,5))
            libtcod.heightmap_add_fbm(dmap, mapnoise, 1.5, 1.5, 1.2, 1.2, 40, 0.5, 0.5)
            minmax = list(libtcod.heightmap_get_minmax(dmap))
            dirtperc = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['dirtperc']
            for x in range(RMAP_WIDTH):
                for y in range(RMAP_HEIGHT):
                    altitude = libtcod.heightmap_get_value(dmap, x, y)
                    altrange = minmax[1] - minmax[0]
                    dperc = int(((minmax[1] - altitude) / altrange) * 200)
                    if rheightmap['%s,%s' % (x,y)] in range(hlist[0] + 1,hlist[1]) and \
                       dperc > dirtperc:
                        dcol = self.dcolmap[dperc]
                        dalpha = ((201 - dperc) * 1.0) / ((200 - dirtperc) * 1.0)
                        obcol = self.rterraindict['%s,%s' % (x,y)]
                        bcol = libtcod.color_lerp(dcol,obcol,dalpha)
                        fcol = libtcod.color_lerp(libtcod.white,bcol,0.5)
                        char = choice(dirtchars)
                        libtcod.console_set_default_foreground(wrwindow,fcol)
                        libtcod.console_print_ex(wrwindow,x,y,libtcod.BKGND_SET,libtcod.LEFT,chr(DoChar(char)))
                        rtextdict['%s,%s' % (x,y)] = [char,fcol]
                        self.rterraindict['%s,%s' % (x,y)] = bcol
                        self.dirtdict['%s,%s' % (x,y)] = True

        # Add beaches.
        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                alphperc = 0.0
                oltile = False
                for num in range(-3,4):
                    for num2 in range(-3,4):
                        posx = min(max(x - num,0),RMAP_WIDTH - 1)
                        posy = min(max(y - num2,0),RMAP_HEIGHT - 1)
                        if isinstance(rheightmap['%s,%s' % (x,y)],int) and isinstance(rheightmap['%s,%s' % (posx,posy)],str):
                            alphperc += 0.1
                            alphperc = min(alphperc,1.0)
                        try:
                            self.oltiledict['%s,%s' % (x + num,y + num2)]
                            oltile = True
                        except KeyError:
                            pass
                if self.tempzone == 'Arctic':
                    col = libtcod.Color(134,188,210) + libtcod.Color(randrange(0,5),randrange(0,5),randrange(0,5))
                else:
                    col = libtcod.Color(253,209,159) + libtcod.Color(randrange(0,5),randrange(0,5),randrange(0,5))
                if self.rdict['%s-%s' % (self.maintype,self.tempzone)].get('bankweeds') and alphperc > 0.5 and not \
                   oltile:
                    if randrange(3) == 1:
                        char = choice(bankweedchars)
                        bcol = libtcod.color_lerp(self.rterraindict['%s,%s' % (x,y)], col, alphperc)
                        col = libtcod.white
                        libtcod.console_set_char_background(wrwindow, x, y, bcol, libtcod.BKGND_SET)
                        self.rterraindict['%s,%s' % (x,y)] = bcol
                        libtcod.console_set_default_foreground(wrwindow,col)
                        libtcod.console_print_ex(wrwindow,x,y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                        rtextdict['%s,%s' % (x,y)] = [char,col]
                    else:
                        self.dirtdict['%s,%s' % (x + num,y + num2)] = True 
                        char = choice(beachchars + shorechars + dirtchars)
                        bcol = libtcod.color_lerp(self.rterraindict['%s,%s' % (x,y)], col, alphperc)
                        col = libtcod.white
                        libtcod.console_set_char_background(wrwindow, x, y, bcol, libtcod.BKGND_SET)
                        self.rterraindict['%s,%s' % (x,y)] = bcol
                        libtcod.console_set_default_foreground(wrwindow,col)
                        libtcod.console_print_ex(wrwindow,x,y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                        rtextdict['%s,%s' % (x,y)] = [char,col]                        
                else:
                    bcol = libtcod.color_lerp(self.rterraindict['%s,%s' % (x,y)], col, alphperc)
                    libtcod.console_set_char_background(wrwindow, x, y, bcol, libtcod.BKGND_SET)
                    self.rterraindict['%s,%s' % (x,y)] = bcol            

        self.beachtiles = {}
        n = random.randrange(-18,-6)
        n2 = random.randrange(7,19)
        for key in self.shoretiles.keys():
            x = int(key.split(',')[0])
            y = int(key.split(',')[1])
            n = min(max(n + (random.randrange(-5,6) * 0.1),-25),-6)
            n2 = min(max(n2 + (random.randrange(-5,6) * 0.1),6),25)
            for num in range(int(n),int(n2)):
                for num2 in range(int(n),int(n2)):
                    try:
                        if isinstance(self.rheightmap['%s,%s' % (x + num,y + num2)],int):
                            totaldist = (sqrt(pow(n,2) + pow(n2,2))) * .75
                            alphperc = max(1.0 - (sqrt(pow(num,2) + pow(num2,2)) / totaldist),0.1)
                            if self.tempzone == 'Arctic':
                                col = libtcod.Color(134,188,210) + libtcod.Color(randrange(0,5),randrange(0,5),randrange(0,5))
                            else:
                                col = libtcod.Color(253,209,159) + libtcod.Color(randrange(0,5),randrange(0,5),randrange(0,5))
                            fcol = libtcod.color_lerp(self.rterraindict['%s,%s' % (x + num,y + num2)],libtcod.white,alphperc)
                            try:
                                if self.beachtiles['%s,%s' % (x + num,y + num2)] > alphperc:
                                    continue
                            except KeyError:
                                pass
                            self.beachtiles['%s,%s' % (x + num,y + num2)] = alphperc
                            if alphperc > 0.4:
                                char = random.choice(shorechars + beachchars)
                            else:
                                char = random.choice(dirtchars + tallgrasschars)
                            libtcod.console_set_default_foreground(wrwindow,fcol)
                            libtcod.console_set_default_background(wrwindow,col)
                            libtcod.console_print_ex(wrwindow,x + num,y + num2,libtcod.BKGND_ALPHA(alphperc),libtcod.LEFT,chr(DoChar(char)))
                            rtextdict['%s,%s' % (x + num,y + num2)] = [char,col]
##                                self.rterraindict['%s,%s' % (x + num,y + num2)] = bcol
                            self.dirtdict['%s,%s' % (x + num,y + num2)] = True                            
                    except KeyError:
                        pass

        self.rtextdict = rtextdict

    def doCopses(self):
        hperc = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['treeperc']
        self.treedict = {}
        self.copsedict = {}
        self.leafgrounddict = {}
        self.ldict = {}
        treelist = []
        if self.rdict['%s-%s' % (self.maintype,self.tempzone)].get('copses'):
            copsechance = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['copsechance']
            for y in range(RMAP_HEIGHT):
                for x in range(RMAP_WIDTH):
                    if randrange(copsechance) == 1:
                        copsetype = choice(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['copses'])
                        copseentry = self.terdict['copse']['copse'][copsetype]
                        copse = [copseentry['XLOC'],copseentry['YLOC'],copseentry['WIDTH'],copseentry['HEIGHT'],copseentry['TYPE'][0]]
                        blocked = False
                        for cx in range(copse[2]):
                            for cy in range(copse[3]):
                                try:
                                    self.rheightmap['%s,%s' % (x + cx,y + cy)]
                                except KeyError:
                                    continue
                                if libtcod.image_get_pixel(fontinfo,(copse[0] + cx) * finfomod, \
                                                           (copse[1] + cy) * finfomod) == libtcod.Color(125,255,255):
                                    continue
                                if not (hperc[1] < self.rheightmap['%s,%s' % (x + cx,y + cy)] < hperc[2]):
                                    blocked = True
                                if self.wobstructed[self.curz].get('%s,%s' % (x + cx,y + cy)):
                                    blocked = True
                                if self.ldict.get('%s,%s' % (x + cx,y + cy)):
                                    blocked = True
                                if self.dirtdict.get('%s,%s' % (x + cx,y + cy)):
                                    blocked = True
                                    
                        if blocked:
                            continue
                        copselist = []
                        treetype = copse[4]
                        for cx in range(copse[2]):
                            for cy in range(copse[3]):
                                try:
                                    self.rheightmap['%s,%s' % (x + cx,y + cy)]
                                except KeyError:
                                    continue
                                if libtcod.image_get_pixel(fontinfo,(copse[0] + cx) * finfomod, \
                                                           (copse[1] + cy) * finfomod) == libtcod.Color(125,255,255):
                                    continue
                                if libtcod.image_get_pixel(fontinfo,(copse[0] + cx) * finfomod, \
                                                           (copse[1] + cy) * finfomod) == libtcod.Color(200,0,200):                    
                                    self.wobstructed[self.curz]['%s,%s' % (x + cx,y + cy)] = 'copse'
                                    tchar = choice(trunkchars)
                                    rlist = []
                                    if randrange(2) == 1:
                                        rlist.append('n')
                                    if randrange(2) == 1:
                                        rlist.append('e')                                
                                    if randrange(2) == 1:
                                        rlist.append('w')
                                    if randrange(2) == 1:
                                        rlist.append('s')
                                    if treetype == 'Tropical':
                                        rlist = []
                                    self.treedict['%s,%s' % (x + cx,y + cy)] = [[x + cx,y + cy,'N/A',treetype,tchar,False,rlist]]
                                    treelist.append((x + cx,y + cy))
                                copselist.append((x + cx,y + cy))
                        copsecenter = (x + (copse[2] / 2),y + (copse[3] / 2))
                        for copsetile in copselist:
                            self.copsedict['%s,%s' % (copsetile[0],copsetile[1])] = [copsecenter,copselist]
                        for cx in range(copse[2]):
                            for cy in range(copse[3]):
                                try:
                                    self.rheightmap['%s,%s' % (x + cx,y + cy)]
                                except KeyError:
                                    continue
                                if libtcod.image_get_pixel(fontinfo,(copse[0] + cx) * finfomod, \
                                                           (copse[1] + cy) * finfomod) == libtcod.Color(125,255,255):
                                    continue
                                self.tallgrassdict['%s,%s' %  (x + cx,y + cy)] = True
                                tcol = self.rterraindict['%s,%s' % (x + cx,y + cy)]
                                leafcol = libtcod.white
                                for tree in treelist:
                                    self.treedict['%s,%s' % (tree[0],tree[1])] += [[x + cx,y + cy,tcol,leafcol]]
                                char = [copse[0] + cx,copse[1] + cy,255]
                                self.translayer[self.curz]['%s,%s' % (x + cx,y + cy)] = [tcol,leafcol,char,treetype]
                                self.ldict['%s,%s' % (x + cx,y + cy)] = (x,y)                                
                                libtcod.console_set_default_foreground(wrwindow, leafcol)
                                libtcod.console_print_ex(wrwindow, x + cx, y + cy, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))

    def doConiferous(self,subtype):
        tree = self.terdict['tree']['coniferous'][subtype]
        varnum = (self.x + self.y) % tree['VARIATIONS']
        self.treecenter = tree['GRASS'][varnum]
        self.talltreecenter = tree['TALLGRASS'][varnum]
        self.leaftreecenter = tree['LEAF'][varnum]
        self.dirttreecenter = tree['DIRT'][varnum]
        self.watertreecenter = tree['WATER'][varnum]
        treerad,x,y,num,num2 = self.treerad,self.x,self.y,self.num,self.num2
        if libtcod.image_get_pixel(fontinfo,(self.treecenter[0] + self.num) * finfomod,(self.treecenter[1] + self.num2) * finfomod) == libtcod.Color(125,255,255):
            return False
        self.tcol = self.rterraindict['%s,%s' % (self.x + self.num,self.y + self.num2)]
        if type(self.rheightmap['%s,%s' % (self.x + self.num,self.y + self.num2)]) == str and not self.tempzone == 'Arctic':
            self.treecenter = self.watertreecenter
            self.tcol = self.rterraindict['%s,%s' % (self.x + self.num,self.y + self.num2)]
            self.tcol = libtcod.color_lerp(self.tcol,libtcod.black,0.3)
            self.rterraindict['%s,%s' % (self.x + self.num,self.y + self.num2)] = self.tcol
            libtcod.console_set_char_background(wrwindow,self.x + self.num,self.y + self.num2,libtcod.BKGND_SET,self.tcol)
        if self.doleaves and self.leaftreecenter and not self.dirtdict.get('%s,%s' % (self.x + self.num,self.y + self.num2)):
            self.treecenter = self.leaftreecenter
            self.leafgrounddict['%s,%s' % (self.x + self.num,self.y + self.num2)] = True
            char = choice(leafchars)
            self.rtextdict['%s,%s' % (self.x + self.num,self.y + self.num2)] = [char,libtcod.white]
        elif self.tallgrassdict.get('%s,%s' % (self.x + self.num,self.y + self.num2)) and self.talltreecenter:
            self.treecenter = self.talltreecenter
        elif self.dirtdict.get('%s,%s' % (self.x + self.num,self.y + self.num2)):
            self.treecenter = self.dirttreecenter
        char = [self.treecenter[0] + self.num,self.treecenter[1] + self.num2,255]
        leafcol = libtcod.color_lerp(self.rterraindict['%s,%s' % (self.x + self.num,self.y + self.num2)],libtcod.white,0.75)
        if self.dirtdict.get('%s,%s' % (self.x +self.num,self.y + self.num2)):
            leafcol = self.rtextdict['%s,%s' % (self.x + self.num,self.y + self.num2)][1]
        return [char,leafcol,self.tcol,]

    def doDeciduous(self,subtype):
        tree = self.terdict['tree']['deciduous'][subtype]
        varnum = (self.x + self.y) % tree['VARIATIONS']
        self.treecenter = tree['GRASS'][varnum]
        self.talltreecenter = tree['TALLGRASS'][varnum]
        self.leaftreecenter = tree['LEAF'][varnum]
        self.dirttreecenter = tree['DIRT'][varnum]
        self.watertreecenter = tree['WATER'][varnum]
        treerad,x,y,num,num2 = self.treerad,self.x,self.y,self.num,self.num2
        if libtcod.image_get_pixel(fontinfo,(self.treecenter[0] + self.num) * finfomod,(self.treecenter[1] + self.num2) * finfomod) == libtcod.Color(125,255,255):
            return False
        self.tcol = self.rterraindict['%s,%s' % (self.x + self.num,self.y + self.num2)]
        if type(self.rheightmap['%s,%s' % (self.x + self.num,self.y + self.num2)]) == str and not self.tempzone == 'Arctic':
            self.treecenter = self.watertreecenter
            self.tcol = self.rterraindict['%s,%s' % (self.x + self.num,self.y + self.num2)]
            self.tcol = libtcod.color_lerp(self.tcol,libtcod.black,0.3)
            self.rterraindict['%s,%s' % (self.x + self.num,self.y + self.num2)] = self.tcol
            libtcod.console_set_char_background(wrwindow,self.x + self.num,self.y + self.num2,libtcod.BKGND_SET,self.tcol)
        if self.doleaves and self.leaftreecenter and not self.dirtdict.get('%s,%s' % (self.x + self.num,self.y + self.num2)):
            self.treecenter = self.leaftreecenter
            self.leafgrounddict['%s,%s' % (self.x + self.num,self.y + self.num2)] = True
            char = choice(leafchars)
            self.rtextdict['%s,%s' % (self.x + self.num,self.y + self.num2)] = [char,libtcod.white]
        elif self.tallgrassdict.get('%s,%s' % (self.x + self.num,self.y + self.num2)) and self.talltreecenter:
            self.treecenter = self.talltreecenter
        elif self.dirtdict.get('%s,%s' % (self.x + self.num,self.y + self.num2)):
            self.treecenter = self.dirttreecenter
        char = [self.treecenter[0] + self.num,self.treecenter[1] + self.num2,255]
        leafcol = libtcod.color_lerp(self.rterraindict['%s,%s' % (self.x + self.num,self.y + self.num2)],libtcod.white,0.75)
        return [char,leafcol,self.tcol]

    def doTropical(self,subtype):
        tree = self.terdict['tree']['tropical'][subtype]
        varnum = (self.x + self.y) % tree['VARIATIONS']
        self.treecenter = tree['GRASS'][varnum]
        self.talltreecenter = tree['TALLGRASS'][varnum]
        self.leaftreecenter = tree['LEAF'][varnum]
        self.dirttreecenter = tree['DIRT'][varnum]
        self.watertreecenter = tree['WATER'][varnum]
        treerad,x,y,num,num2 = self.treerad,self.x,self.y,self.num,self.num2
        if libtcod.image_get_pixel(fontinfo,(self.treecenter[0] + self.num) * finfomod,(self.treecenter[1] + self.num2) * finfomod) == libtcod.Color(125,255,255):
            return False
        self.tcol = self.rterraindict['%s,%s' % (self.x + self.num,self.y + self.num2)]
        if type(self.rheightmap['%s,%s' % (self.x + self.num,self.y + self.num2)]) == str:
            self.treecenter = self.watertreecenter
            self.tcol = self.rterraindict['%s,%s' % (self.x + self.num,self.y + self.num2)]
            self.tcol = libtcod.color_lerp(self.tcol,libtcod.black,0.3)
            self.rterraindict['%s,%s' % (self.x + self.num,self.y + self.num2)] = self.tcol
            libtcod.console_set_char_background(wrwindow,self.x + self.num,self.y + self.num2,libtcod.BKGND_SET,self.tcol)
        if self.doleaves and self.leaftreecenter and not self.dirtdict.get('%s,%s' % (self.x + self.num,self.y + self.num2)):
            self.treecenter = self.leaftreecenter
            self.leafgrounddict['%s,%s' % (self.x + self.num,self.y + self.num2)] = True
            char = choice(leafchars)
            self.rtextdict['%s,%s' % (self.x + self.num,self.y + self.num2)] = [char,libtcod.white]
        elif self.tallgrassdict.get('%s,%s' % (self.x + self.num,self.y + self.num2)) and self.talltreecenter:
            self.treecenter = self.talltreecenter
        elif self.dirtdict.get('%s,%s' % (self.x + self.num,self.y + self.num2)):
            self.treecenter = self.dirttreecenter
        char = [self.treecenter[0] + self.num,self.treecenter[1] + self.num2,255]
        leafcol = libtcod.white
        return [char,leafcol,self.tcol]                          

    def doTrees(self):
        hperc = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['treeperc']
        tspace = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['tspace']

        rainfall = 4
        treemap = libtcod.heightmap_new(RMAP_WIDTH,RMAP_HEIGHT)
        libtcod.heightmap_add_voronoi(treemap, randrange(100,300), 4, [0.2,0.4,0.5,0.6])
        libtcod.heightmap_rain_erosion(treemap, RMAP_WIDTH * 142 * rainfall, 0.05, 0.5)   
        tminmax = list(libtcod.heightmap_get_minmax(treemap))
        taltrange = tminmax[1] - tminmax[0]

        for y in range(RMAP_HEIGHT):
            for x in range(RMAP_WIDTH):
                # Draw trees.
                tdensity = libtcod.heightmap_get_value(treemap, x, y)
                tperc = int(((tminmax[1] - tdensity) / taltrange) * 200) - 1
                if tperc > hperc[0]:
                    if (hperc[1] < self.rheightmap['%s,%s' % (x,y)] < hperc[2]) and \
                       isinstance(self.rheightmap['%s,%s' % (x,y)],int):
                        try:
                           self.dirtdict['%s,%s' % (x,y)]
                           tchance = 61
                        except KeyError:
                            tchance = 21
                        if randrange(1,tchance) == 1:
                            tswitch = True
                            try:
                                self.treerad = wchoice(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['radperc'])
                            except KeyError:
                                self.treerad = wchoice([(4,.7),(5,.3)])
                            for num in range(tspace[0],tspace[1]):
                                for num2 in range(tspace[0],tspace[1]):
                                    try:
                                        if self.wobstructed[self.curz]['%s,%s' % (x + num,y + num2)] == 'copse':
                                            tswitch = False
                                            continue
                                    except KeyError:
                                        pass
                                    try:
                                        self.ldict['%s,%s' % (x + num,y + num2)]
                                        tswitch = False
                                    except KeyError:
                                        pass
                                    try:
                                        self.beachtiles['%s,%s' % (x + num,y + num2)]
                                        tswitch = False
                                    except KeyError:
                                        pass
                                    try:
                                        self.oltiledict['%s,%s' % (x + num,y + num2)]
                                        tswitch = False
                                    except KeyError:
                                        pass
                                    p = pow(x - tspace[0],2)
                                    p2 = pow(y - tspace[1],2)
                                    pd = sqrt(p + p2)
                                    try:
                                        t = self.treedict['%s,%s' % (x + num,y + num2)][0]
                                        if self.treerad + t[2] < pd:
                                            tswitch = False
                                        if type(self.rheightmap['%s,%s' % (x + num,y + num2)]) == 'str':
                                            tswitch = False
                                    except KeyError:
                                        pass
                            if tswitch:
                                self.wobstructed[self.curz]['%s,%s' % (x,y)] = 'tree'
                                # This is where we determine the tree type depending on the biome and temperature.
                                treetype = wchoice(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['treetypes'])
                                subtype = choice(self.rdict['%s-%s' % (self.maintype,self.tempzone)][treetype][self.treerad])
                                tchar = choice(trunkchars)
                                rlist = []
                                if randrange(2) == 1:
                                    rlist.append('n')
                                if randrange(2) == 1:
                                    rlist.append('e')                                
                                if randrange(2) == 1:
                                    rlist.append('w')
                                if randrange(2) == 1:
                                    rlist.append('s')
                                if treetype == 'Tropical':
                                    rlist = []
                                self.treedict['%s,%s' % (x,y)] = [[x,y,self.treerad,treetype,tchar,False,rlist]]
                                for num in range(-self.treerad,self.treerad + 1):
                                    for num2 in range(-self.treerad,self.treerad + 1):
                                        try:
                                            self.rheightmap['%s,%s' % (x + num,y + num2)]
                                        except KeyError:
                                            continue
                                        self.num,self.num2 = num,num2
                                        self.x,self.y = x,y
                                        if not type(self.rheightmap['%s,%s' % (x + num,y + num2)]) == str:
                                            try:
                                                self.tallgrassdict['%s,%s' % (x + num,y + num2)]
                                                if randrange(5) == 1:
                                                    self.doleaves = wchoice(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['leafchance'])
                                                else:
                                                    self.doleaves = False
                                            except KeyError:
                                                self.doleaves = wchoice(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['leafchance'])
                                        else:
                                            self.doleaves = False
                                        if treetype == 'Tropical':
                                            self.doleaves = False                                                
                                        dotree = getattr(self,'do' + treetype)(subtype)
                                        if dotree:
                                            char,leafcol,tcol = dotree[0],dotree[1],dotree[2]
                                            self.treedict['%s,%s' % (x,y)] += [[x + num,y + num2,tcol,leafcol]]
                                            libtcod.console_set_default_foreground(wrwindow, leafcol)
                                            self.translayer[self.curz]['%s,%s' % (x + num,y + num2)] = [tcol,leafcol,char,treetype]
                                            self.ldict['%s,%s' % (x + num,y + num2)] = (x,y)
                                            libtcod.console_print_ex(wrwindow, x + num, y + num2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))

        # Now add in leaves for forest floors.

        for key in self.treedict.keys():
            if self.treedict[key][0][3] == 'Tropical':
                continue
            x = int(key.split(',')[0])
            y = int(key.split(',')[1])
            for num in range(-15,16):
                for num2 in range(-15,16):
                    try:
                        self.rheightmap['%s,%s' % (x + num,y + num2)]
                    except KeyError:
                        continue
                    if (hperc[1] < self.rheightmap['%s,%s' % (x + num,y + num2)] < hperc[2]) and \
                       isinstance(self.rheightmap['%s,%s' % (x + num,y + num2)],int):                    
                        maxdist = 21 * 1.0
                        curdist = sqrt(pow(num,2) + pow(num2,2)) * 1.0
                        chance = int(((curdist / maxdist) * 100) * 0.5)
                        if self.treedict[key][0][3] == 'Coniferous':
                            chance = chance / 2
                        if chance >  randrange(100):
                            if (not self.ldict.get('%s,%s' % (x + num,y + num2))) or self.copsedict.get('%s,%s' % (x + num,y + num2)):
                                try:
                                    self.tallgrassdict['%s,%s' % (x + num,y + num2)]
                                    if randrange(5) == 1:
                                        doleaves = wchoice(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['leafchance'])
                                    else:
                                        doleaves = False
                                except KeyError:
                                    doleaves = wchoice(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['leafchance'])
                                try:
                                    self.dirtdict['%s,%s' % (x + num,y + num2)]
                                    if randrange(4) == 1:
                                        pass
                                    else:
                                        doleaves = False
                                except KeyError:
                                    pass
                                if doleaves:
                                    fcol = libtcod.color_lerp(self.rterraindict['%s,%s' % (x + num,y + num2)],libtcod.white,0.75)
                                    libtcod.console_set_default_foreground(wrwindow, fcol)
                                    char = choice(leafchars)
                                    try:
                                        self.dirtdict['%s,%s' % (x + num,y + num2)]
                                        char = choice(dirtleafchars)
                                    except KeyError:
                                        pass
                                    if not self.copsedict.get('%s,%s' % (x + num,y + num2)):
                                        libtcod.console_print_ex(wrwindow, x + num, y + num2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                                    self.rtextdict['%s,%s' % (x + num,y + num2)] = [char,fcol]
                                    self.leafgrounddict['%s,%s' % (x + num,y + num2)] = True                                    
            
##        for x in range(RMAP_WIDTH):
##            for y in range(RMAP_HEIGHT):
##                try:
##                    self.ldict['%s,%s' % (x,y)]
##                except KeyError:
##                    if (hperc[1] < self.rheightmap['%s,%s' % (x,y)] < hperc[2]) and \
##                       isinstance(self.rheightmap['%s,%s' % (x,y)],int):
##                        lchance = 0
##                        for num in range(-10,11):
##                            for num2 in range(-10,11):
##                                try:
##                                    self.ldict['%s,%s' % (x + num,y + num2)]
##                                    try:
##                                        self.dirtdict['%s,%s' % (x + num,y + num2)]
##                                    except KeyError:
##                                        try:
##                                            if not self.treedict['%s,%s' % (self.ldict['%s,%s' % (x + num,y + num2)][0],self.ldict['%s,%s' % (x + num,y + num2)][1])][0][3] == 'Tropical':
##                                                lchance += 1
##                                        except KeyError:
##                                            pass
##                                except KeyError:
##                                    pass
##                        try:
##                            self.tallgrassdict['%s,%s' % (x,y)]
##                            if randrange(5) == 1:
##                                doleaves = wchoice(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['leafchance'])
##                            else:
##                                doleaves = False
##                        except KeyError:
##                            doleaves = wchoice(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['leafchance'])
##                        try:
##                            self.dirtdict['%s,%s' %(x,y)]
##                            neg = randrange(-7,-3)
##                            pos = randrange(3,7)
##                            for num in range(neg,pos):
##                                for num2 in range(neg,pos):
##                                    try:
##                                        self.ldict['%s,%s' % (x + num,y + num2)]
##                                        self.dirtdict['%s,%s' % (x + num,y + num2)]
##                                        doleaves = False
##                                    except KeyError:
##                                        pass
##                        except KeyError:
##                            pass
##                        if randrange(100) < lchance and doleaves:
##                            fcol = libtcod.color_lerp(self.rterraindict['%s,%s' % (x,y)],libtcod.white,0.75)
##                            libtcod.console_set_default_foreground(wrwindow, fcol)
##                            char = choice(leafchars)
##                            try:
##                                self.dirtdict['%s,%s' % (x,y)]
##                                char = choice(dirtleafchars)
##                            except KeyError:
##                                pass
##                            libtcod.console_print_ex(wrwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
##                            self.rtextdict['%s,%s' % (x,y)] = [char,fcol]
##                            self.leafgrounddict['%s,%s' % (x,y)] = True

        # Also, trees in/by tall grass need to be modified a bit...

        for x in range(RMAP_WIDTH):
            for y in range(RMAP_HEIGHT):
                try:
                    self.ldict['%s,%s' % (x,y)]
                    try:
                        self.tallgrassdict['%s,%s' % (x,y)]
                        try:
                            self.dirtdict['%s,%s' % (x,y)]
                        except KeyError:
                           if type(self.rheightmap['%s,%s' % (x,y)]) != str:
                                for num in range(randrange(-5,0),randrange(1,6)):
                                    for num2 in range(randrange(-5,0),randrange(1,6)):
                                        try:
                                            self.tallgrassdict['%s,%s' % (x + num,y + num2)]
                                            try:
                                                self.leafgrounddict['%s,%s' % (x + num,y + num2)]
                                            except KeyError:
                                                try:
                                                    self.ldict['%s,%s' % (x + num,y + num2)]
                                                    char = choice(tallgrasschars)
                                                    self.rtextdict['%s,%s' % (x + num,y + num2)] = [char,libtcod.white]
                                                except KeyError:
                                                    char = choice(tallgrasschars)
                                                    libtcod.console_print_ex(wrwindow, x + num, y + num2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                                                    self.rtextdict['%s,%s' % (x + num,y + num2)] = [char,libtcod.white]
                                        except KeyError:
                                            pass
                    except KeyError:
                        pass
                except KeyError:
                    pass
                    

    def doScrub(self):
        
        scrubperc = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['scrubperc']
        shdict = {}

        for x in range(RMAP_WIDTH):
            for y in range(RMAP_HEIGHT):
                try:
                    shdict['%s,%s' % (x,y)]
                    continue
                except KeyError:
                    pass
                ferntype = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['ferntype']
                shrubtype = wchoice(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['shrubtypes'])
                if ferntype:
                    for num in range(-2,3):
                        for num2 in range(-2,3):
                            try:
                                shdict['%s,%s' % (x + num,y + num2)]
                                fernperc = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['fernperc']
                                if shrubtype == 'fern':
                                    scrubperc[0] == self.rdict['%s-%s' % (self.maintype,self.tempzone)]['scrubperc'][0] / 2
                                elif shdict['%s,%s' % (x + num,y + num2)][2] == 'fern' and \
                                     wchoice(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['shrubtypes']) == 'fern':
                                    scrubperc[0] == self.rdict['%s-%s' % (self.maintype,self.tempzone)]['scrubperc'][0] / 2
                                    shrubtype = 'fern'
                            except KeyError:
                                pass
                shcol = libtcod.white
                addshrub = True
                shrubcount = 0
                for num in range(-1,2):
                    for num2 in range(-1,2):
                        nx = min(max(x - num,0),RMAP_WIDTH - 1)
                        ny = min(max(y - num2,0),RMAP_HEIGHT - 1)
                        try:
                            shdict['%s,%s' % (nx,ny)]
                            shrubcount += min(shrubcount + 1,int(scrubperc[0] * .75))
                        except KeyError:
                            pass
                        if isinstance(self.rheightmap['%s,%s' % (nx,ny)],str):
                            addshrub = False
                roll = randrange(1,1 + max(shrubcount,2))
                chance = randrange(1,scrubperc[0])
                for wx in range(-5,9):
                    for wy in range(-5,9):
                        try:
                            self.rheightmap['%s,%s' % (x + wx,y + wy)]
                            try:
                                self.oltiledict['%s,%s' % (x + wx,y + wy)]
                                roll -= 1
                                continue
                            except KeyError:
                                pass
                            if type(self.rheightmap['%s,%s' % (x + wx,y + wy)]) == str and randrange(4) == 1:
                                roll += 1
                        except KeyError:
                            pass
                if roll > chance and addshrub:
                    if self.rheightmap['%s,%s' % (x,y)] in range(scrubperc[1],scrubperc[2]):
                        try:
                            self.dirtdict['%s,%s' % (x,y)]
                            shrubtype = wchoice(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['dirtshrubtypes'])
                        except KeyError:
                            pass
                        for wx in range(-5,9):
                            for wy in range(-5,9):
                                try:
                                    self.rheightmap['%s,%s' % (x + wx,y + wy)]
                                    try:
                                        self.oltiledict['%s,%s' % (x + wx,y + wy)]
                                        continue
                                    except KeyError:
                                        pass
                                    if type(self.rheightmap['%s,%s' % (x + wx,y + wy)]) == str:
                                        if randrange(10) == 1:
                                            try:
                                                shrubtype = wchoice(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['watershrubtypes'])
                                            except KeyError:
                                                pass
                                except KeyError:
                                    pass
                        if shrubtype == 'fern':
                            shrubentry = self.terdict['shrub']['fern'][ferntype]
                        else:
                            shrubentry = self.terdict['shrub']['shrub'][shrubtype]
                        varnum = (x + y) % shrubentry['VARIATIONS']
                        grassshrub = [shrubentry['WIDTH'],shrubentry['HEIGHT'],shrubentry['GRASS'][varnum][0],shrubentry['GRASS'][varnum][1]]
                        tallgrassshrub = [shrubentry['WIDTH'],shrubentry['HEIGHT'],shrubentry['TALLGRASS'][varnum][0],shrubentry['TALLGRASS'][varnum][1]]
                        leafshrub = [shrubentry['WIDTH'],shrubentry['HEIGHT'],shrubentry['LEAF'][varnum][0],shrubentry['LEAF'][varnum][1]]
                        dirtshrub = [shrubentry['WIDTH'],shrubentry['HEIGHT'],shrubentry['DIRT'][varnum][0],shrubentry['DIRT'][varnum][1]]
                        shrub = grassshrub
                        check = True
                        blocked = False
                        for sx in range(shrub[0]):
                            for sy in range(shrub[1]):
                                try:
                                    try:
                                        self.wobstructed[self.curz]['%s,%s' % (x + sx,y + sy)]
                                        blocked = True
                                    except KeyError:
                                        pass
                                    if not self.rheightmap['%s,%s' % (x + sx,y + sy)] < self.mlev:
                                        blocked = True
                                    try:
                                        shdict['%s,%s' % (x + sx,y + sy)]
                                        blocked = True
                                    except KeyError:
                                        pass
                                    try:
                                        self.beachtiles['%s,%s' % (x + sx,y + sy)]
                                        blocked = True
                                    except KeyError:
                                        pass
                                    try:
                                        self.ldict['%s,%s' % (x + sx,y + sy)]
                                        blocked = True
                                    except KeyError:
                                        pass
                                except KeyError:
                                    blocked = True
                        if blocked:
                            continue
                        for sx in range(shrub[0]):
                            for sy in range(shrub[1]):
                                shchar = [shrub[2] + sx,shrub[3] + sy,255]
                                if libtcod.image_get_pixel(fontinfo,shchar[0] * finfomod,shchar[1] * finfomod) == libtcod.Color(125,255,255):
                                    continue
                                try:
                                    self.dirtdict['%s,%s' % (x + sx,y + sy)]
                                    shcol = self.rtextdict['%s,%s' % (x + sx,y + sy)][1]
                                    shrub = dirtshrub
                                except KeyError:
                                    shcol = libtcod.white
                                    shrub = grassshrub
                                libtcod.console_set_default_foreground(wrwindow,shcol)
                                try:
                                    self.tallgrassdict['%s,%s' % (x + sx,y + sy)]
                                    try:
                                        self.dirtdict['%s,%s' % (x + sx,y + sy)]
                                    except KeyError:
                                        for num in range(randrange(-2,0),randrange(1,3)):
                                            for num2 in range(randrange(-2,0),randrange(1,3)):
                                                try:
                                                    self.tallgrassdict['%s,%s' % (x + sx + num,y + sy + num2)]
                                                    try:
                                                        self.leafgrounddict['%s,%s' % (x + sx + num,y + sy + num2)]
                                                    except KeyError:
                                                        try:
                                                            self.ldict['%s,%s' % (x + sx + num,y + sy + num2)]
                                                        except KeyError:
                                                            try:
                                                                shdict['%s,%s' % (x + sx + num,y + sy + num2)]
                                                            except KeyError:
                                                                char = choice(tallgrasschars)
                                                                libtcod.console_print_ex(wrwindow, x + sx + num, y + sy + num2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                                                                self.rtextdict['%s,%s' % (x + sx + num,y + sy + num2)] = [char,libtcod.white]
                                                except KeyError:
                                                    pass
                                    shrub = tallgrassshrub
                                except KeyError:
                                    try:
                                        self.leafgrounddict['%s,%s' % (x + sx,y + sy)]
                                        try:
                                            self.dirtdict['%s,%s' % (x + sx,y + sy)]
                                        except KeyError:
                                            shrub = leafshrub
                                    except KeyError:
                                        pass
                                shchar = [shrub[2] + sx,shrub[3] + sy,255]
                                shdict['%s,%s' % (x + sx,y + sy)] = [shcol,shchar,shrubtype]
                                
                                if not libtcod.image_get_pixel(fontinfo,shchar[0] * finfomod,shchar[1] * finfomod) == libtcod.Color(200,0,200):
                                    if 'cactus' in shrubtype:
                                        self.wobstructed[self.curz]['%s,%s' % (x + sx,y + sy)] = 'cactus'
                                    else:
                                        self.wobstructed[self.curz]['%s,%s' % (x + sx,y + sy)] = 'shrub'
                                libtcod.console_print_ex(wrwindow, x + sx, y + sy, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(shchar)))
                                self.rtextdict['%s,%s' % (x + sx,y + sy)] = [shchar,shcol]
        self.shdict = shdict                

    def doBoulders(self):
        
        self.boulderdict = {}        
        boulderfreq = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['boulderfreq']
        if boulderfreq > 0:
            bouldertypes = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['bouldertypes']
            for x in range(RMAP_WIDTH):
                for y in range(RMAP_HEIGHT):
                    if not self.wobstructed[self.curz].get('%s,%s' % (x,y)):
                        if randrange(boulderfreq) == 1:
                            bouldertype = choice(bouldertypes)
                            boulderentry = self.terdict['boulder']['land'][bouldertype]
                            varnum = (x + y) % boulderentry['VARIATIONS']
                            grassboulder = [boulderentry['WIDTH'],boulderentry['HEIGHT'],boulderentry['GRASS'][varnum][0],boulderentry['GRASS'][varnum][1]]
                            tallgrassboulder = [boulderentry['WIDTH'],boulderentry['HEIGHT'],boulderentry['TALLGRASS'][varnum][0],boulderentry['TALLGRASS'][varnum][1]]
                            leafboulder = [boulderentry['WIDTH'],boulderentry['HEIGHT'],boulderentry['LEAF'][varnum][0],boulderentry['LEAF'][varnum][1]]
                            dirtboulder = [boulderentry['WIDTH'],boulderentry['HEIGHT'],boulderentry['DIRT'][varnum][0],boulderentry['DIRT'][varnum][1]]
                            boulder = grassboulder
                            blocked = False
                            for bx in range(boulder[0]):
                                for by in range(boulder[1]):
                                    try:
                                        if self.wobstructed[self.curz].get('%s,%s' % (x + bx,y + by)):
                                            blocked = True
                                        elif not self.rheightmap['%s,%s' % (x + bx,y + by)] < self.mlev:
                                            blocked = True
                                        elif self.shdict.get('%s,%s' % (x + bx,y + by)):
                                            blocked = True
                                        elif self.ldict.get('%s,%s' % (x + bx,y + by)):
                                            blocked = True
                                    except KeyError:
                                        blocked = True
                            if blocked:
                                continue
                            fcol = libtcod.white
                            libtcod.console_set_default_foreground(wrwindow,fcol)
                            for bx in range(boulder[0]):
                                for by in range(boulder[1]):
                                    boulder = grassboulder
                                    bchar = [boulder[2] + bx,boulder[3] + by,255]
                                    if libtcod.image_get_pixel(fontinfo,bchar[0] * finfomod,bchar[1] * finfomod) == libtcod.Color(125,255,255):
                                        continue
                                    self.boulderdict['%s,%s' % (x + bx,y + by)] = True
                                    if self.leafgrounddict.get('%s,%s' % (x + bx,y + by)):
                                        boulder = leafboulder
                                    elif self.tallgrassdict.get('%s,%s' % (x + bx,y + by)) and not self.dirtdict.get('%s,%s' % (x + bx,y + by)):
                                        boulder = tallgrassboulder
                                        for num in range(randrange(-2,0),randrange(1,3)):
                                            for num2 in range(randrange(-2,0),randrange(1,3)):
                                                if self.tallgrassdict.get('%s,%s' % (x + bx + num,y + by + num2)) and not \
                                                   self.leafgrounddict.get('%s,%s' % (x + bx + num,y + by + num2)) and not \
                                                   self.ldict.get('%s,%s' % (x + bx + num,y + by + num2)) and not \
                                                   self.shdict.get('%s,%s' % (x + bx + num,y + by + num2)) and not \
                                                   self.boulderdict.get('%s,%s' % (x + bx + num,y + by + num2)):
                                                    char = choice(tallgrasschars)
                                                    libtcod.console_print_ex(wrwindow, x + bx + num, y + by + num2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                                                    self.rtextdict['%s,%s' % (x + bx + num,y + by + num2)] = [char,libtcod.white]
                                    elif self.dirtdict.get('%s,%s' % (x + bx,y + by)):
                                        boulder = dirtboulder
                                    bchar = [boulder[2] + bx,boulder[3] + by,255]
                                    if not libtcod.image_get_pixel(fontinfo,bchar[0] * finfomod,bchar[1] * finfomod) == libtcod.Color(200,0,200):
                                        self.wobstructed[self.curz]['%s,%s' % (x + bx,y + by)] = 'boulder'
                                    libtcod.console_print_ex(wrwindow, x + bx, y + by, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bchar)))
                                    self.rtextdict['%s,%s' % (x + bx,y + by)] = [bchar,fcol]

    def doLogs(self):

        self.logdict = {}        
        logfreq = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['logfreq']
        if logfreq > 0:
            logtypes = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['logtypes']
            for x in range(RMAP_WIDTH):
                for y in range(RMAP_HEIGHT):
                    if not self.wobstructed[self.curz].get('%s,%s' % (x,y)):
                        if randrange(logfreq) == 1:
                            logtype = choice(logtypes)
                            logentry = self.terdict['log']['land'][logtype]
                            varnum = (x + y) % logentry['VARIATIONS']
                            grasslog = [logentry['WIDTH'],logentry['HEIGHT'],logentry['GRASS'][varnum][0],logentry['GRASS'][varnum][1]]
                            tallgrasslog = [logentry['WIDTH'],logentry['HEIGHT'],logentry['TALLGRASS'][varnum][0],logentry['TALLGRASS'][varnum][1]]
                            leaflog = [logentry['WIDTH'],logentry['HEIGHT'],logentry['LEAF'][varnum][0],logentry['LEAF'][varnum][1]]
                            dirtlog = [logentry['WIDTH'],logentry['HEIGHT'],logentry['DIRT'][varnum][0],logentry['DIRT'][varnum][1]]
                            log = grasslog
                            blocked = False
                            for lx in range(log[0]):
                                for ly in range(log[1]):
                                    try:
                                        if self.wobstructed[self.curz].get('%s,%s' % (x + lx,y + ly)):
                                            blocked = True
                                        elif not self.rheightmap['%s,%s' % (x + lx,y + ly)] < self.mlev:
                                            blocked = True
                                        elif self.shdict.get('%s,%s' % (x + lx,y + ly)):
                                            blocked = True
                                        elif self.ldict.get('%s,%s' % (x + lx,y + ly)):
                                            blocked = True
                                    except KeyError:
                                        blocked = True
                            if blocked:
                                continue
                            fcol = libtcod.white
                            libtcod.console_set_default_foreground(wrwindow,fcol)
                            for lx in range(log[0]):
                                for ly in range(log[1]):
                                    log = grasslog
                                    lchar = [log[2] + lx,log[3] + ly,255]
                                    if libtcod.image_get_pixel(fontinfo,lchar[0] * finfomod,lchar[1] * finfomod) == libtcod.Color(125,255,255):
                                        continue
                                    self.logdict['%s,%s' % (x + lx,y + ly)] = True
                                    if self.leafgrounddict.get('%s,%s' % (x + lx,y + ly)):
                                        log = leaflog
                                    elif self.tallgrassdict.get('%s,%s' % (x + lx,y + ly)) and not self.dirtdict.get('%s,%s' % (x + lx,y + ly)):
                                        log = tallgrasslog
                                        for num in range(randrange(-2,0),randrange(1,3)):
                                            for num2 in range(randrange(-2,0),randrange(1,3)):
                                                if self.tallgrassdict.get('%s,%s' % (x + lx + num,y + ly + num2)) and not \
                                                   self.leafgrounddict.get('%s,%s' % (x + lx + num,y + ly + num2)) and not \
                                                   self.ldict.get('%s,%s' % (x + lx + num,y + ly + num2)) and not \
                                                   self.shdict.get('%s,%s' % (x + lx + num,y + ly + num2)) and not \
                                                   self.logdict.get('%s,%s' % (x + lx + num,y + ly + num2)):
                                                    char = choice(tallgrasschars)
                                                    libtcod.console_print_ex(wrwindow, x + lx + num, y + ly + num2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                                                    self.rtextdict['%s,%s' % (x + lx + num,y + ly + num2)] = [char,libtcod.white]
                                    elif self.dirtdict.get('%s,%s' % (x + lx,y + ly)):
                                        log = dirtlog
                                    lchar = [log[2] + lx,log[3] + ly,255]
                                    if not libtcod.image_get_pixel(fontinfo,lchar[0] * finfomod,lchar[1] * finfomod) == libtcod.Color(200,0,200):
                                        self.wobstructed[self.curz]['%s,%s' % (x + lx,y + ly)] = 'log'
                                    libtcod.console_print_ex(wrwindow, x + lx, y + ly, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(lchar)))
                                    self.rtextdict['%s,%s' % (x + lx,y + ly)] = [lchar,fcol]


    def doLoadScreen(self,stage):
        global LoadScreen, NoUpdate
        NoUpdate = True
        libtcod.console_set_default_background(LoadScreen,libtcod.magenta)
        libtcod.console_clear(LoadScreen)
        DrawScroll(LoadScreen,(VIEW_WIDTH / 2) - 17,(VIEW_HEIGHT / 2) - 11,33,20,1)
        for x in range(34):
            for y in range(21):
                libtcod.console_set_char_background(LoadScreen,x + (VIEW_WIDTH / 2) - 17,y + (VIEW_HEIGHT / 2) - 11,scrollcolor2,libtcod.BKGND_SET)
        if stage == 'world':
            for x in range(32):
                for y in range(19):
                    char = [x,1509 + y,255]
                    coords = [(VIEW_WIDTH / 2) - 16,(VIEW_HEIGHT / 2) - 10]
                    libtcod.console_set_default_foreground(LoadScreen,libtcod.white)
                    libtcod.console_print_ex(LoadScreen,coords[0] + x,coords[1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
        elif stage == 'terrain':
            for x in range(32):
                for y in range(19):
                    char = [x,1395 + y,255]
                    coords = [(VIEW_WIDTH / 2) - 16,(VIEW_HEIGHT / 2) - 10]
                    libtcod.console_set_default_foreground(LoadScreen,libtcod.white)
                    libtcod.console_print_ex(LoadScreen,coords[0] + x,coords[1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
        elif stage == 'trees':
            for x in range(32):
                for y in range(19):
                    char = [x,1414 + y,255]
                    coords = [(VIEW_WIDTH / 2) - 16,(VIEW_HEIGHT / 2) - 10]
                    libtcod.console_set_default_foreground(LoadScreen,libtcod.white)
                    libtcod.console_print_ex(LoadScreen,coords[0] + x,coords[1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
        elif stage == 'scrub':
            for x in range(32):
                for y in range(19):
                    char = [x,1433 + y,255]
                    coords = [(VIEW_WIDTH / 2) - 16,(VIEW_HEIGHT / 2) - 10]
                    libtcod.console_set_default_foreground(LoadScreen,libtcod.white)
                    libtcod.console_print_ex(LoadScreen,coords[0] + x,coords[1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))            
        elif stage == 'misc':
            for x in range(32):
                for y in range(19):
                    char = [x,1452 + y,255]
                    coords = [(VIEW_WIDTH / 2) - 16,(VIEW_HEIGHT / 2) - 10]
                    libtcod.console_set_default_foreground(LoadScreen,libtcod.white)
                    libtcod.console_print_ex(LoadScreen,coords[0] + x,coords[1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
        elif stage == 'river':
            for x in range(32):
                for y in range(19):
                    char = [x,1471 + y,255]
                    coords = [(VIEW_WIDTH / 2) - 16,(VIEW_HEIGHT / 2) - 10]
                    libtcod.console_set_default_foreground(LoadScreen,libtcod.white)
                    libtcod.console_print_ex(LoadScreen,coords[0] + x,coords[1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))     
        elif stage == 'vectors':
            for x in range(32):
                for y in range(19):
                    char = [x,1490 + y,255]
                    coords = [(VIEW_WIDTH / 2) - 16,(VIEW_HEIGHT / 2) - 10]
                    libtcod.console_set_default_foreground(LoadScreen,libtcod.white)
                    libtcod.console_print_ex(LoadScreen,coords[0] + x,coords[1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
        elif stage == 'shores':
            for x in range(32):
                for y in range(19):
                    char = [x,1528 + y,255]
                    coords = [(VIEW_WIDTH / 2) - 16,(VIEW_HEIGHT / 2) - 10]
                    libtcod.console_set_default_foreground(LoadScreen,libtcod.white)
                    libtcod.console_print_ex(LoadScreen,coords[0] + x,coords[1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
        NoUpdate = False

    def genMap(self,rtypes):
        global MouseLock, rheightmap, moveclouds, GraphicsList, Clouds, NoKeys, rmap

        self.doLoadScreen('vectors')

        self.updateStatus()
        NoKeys = True
        MouseLock = True
        
        maintypes = ['Deciduous Forest','Shrubland','Desert','Heathland','Broadleaf Forest', \
                     'Mixed Forest','Coniferous Forest','Evergreen Forest','Swamp', 'Plain', 'Highland','Mountain', \
                     'Marshland','Tundra','Glacier','Tropical Forest','Savannah','Ocean','Lake']

        self.wcdict = {}
        self.zgrid = {}
        self.ztop = {}
        self.wobstructed = {}
        self.unobstructed = {}
        self.translayer = {}
        self.itemdict = {}
        for z in range(-99,100):
            self.zgrid[z] = {}
            self.wcdict[z] = {}
            self.wobstructed[z] = {}
            self.translayer[z] = {}
            self.itemdict[z] = {}
        self.curz = 0
        self.rtypes = rtypes
        
        self.subtypes = []
        self.maintypes = []
        print rtypes
        for rtype in rtypes:
            if rtype in maintypes:
                self.maintypes += [rtype]
            else:
                self.subtypes.append(rtype)
        if len(self.maintypes) == 0:
            self.maintypes = ['Plain']

        self.tempzone = wtempdict['%s,%s' % (self.curregion[0],self.curregion[1])]

        union = set([])
        if 'Desert' in self.maintypes:
            self.maintypes = ['Desert']
        if len(self.maintypes) > 1:
            for maintype in self.maintypes:
                union = union | set(self.rdict['%s-%s' % (maintype,self.tempzone)].keys())
            self.maintype = 'Fusion'
            self.FusionMap = getattr(self,'%sMap' % choice(self.maintypes).replace(' ',''))
            self.rdict['%s-%s' % ('Fusion',self.tempzone)] = {}
            coltype = None
            wcoltype = None
            dcoltype = None
            for key in list(union):       
                while not self.rdict['%s-%s' % ('Fusion',self.tempzone)].get(key):
                    highkey = -500
                    if key in ['keyidx','keycols','mlev'] and not coltype:
                        coltype = choice(self.maintypes)
                    elif key in ['wkeyidx','wkeycols'] and not wcoltype:
                        wcoltype = choice(self.maintypes)
                    elif key in ['dkeyidx','dkeycols'] and not dcoltype:
                        dcoltype = choice(self.maintypes)   
                    if key in ['keyidx','keycols','mlev']:
                        self.rdict['%s-%s' % ('Fusion',self.tempzone)][key] = self.rdict['%s-%s' % (coltype,self.tempzone)][key]
                        continue
                    elif key in ['wkeyidx','wkeycols']:
                        self.rdict['%s-%s' % ('Fusion',self.tempzone)][key] = self.rdict['%s-%s' % (wcoltype,self.tempzone)][key]
                        continue
                    elif key in ['dkeyidx','dkeycols']:
                        self.rdict['%s-%s' % ('Fusion',self.tempzone)][key] = self.rdict['%s-%s' % (dcoltype,self.tempzone)][key]
                        continue
                    if key == 'wlev':
                        for maintype in self.maintypes:
                            if self.rdict['%s-%s' % (maintype,self.tempzone)]['wlev'] > highkey:
                                highkey = self.rdict['%s-%s' % (maintype,self.tempzone)]['wlev']
                        self.rdict['%s-%s' % ('Fusion',self.tempzone)][key] = highkey
                    else:
                        try:
                            self.rdict['%s-%s' % ('Fusion',self.tempzone)][key] = self.rdict['%s-%s' % (choice(self.maintypes),self.tempzone)][key]
                        except KeyError:
                            pass
        else:
            self.maintype = self.maintypes[0]

        try:
            mapgen = getattr(self,'%sMap' % self.maintype.replace(' ',''))()
        except AttributeError:
            self.maintype = 'Plain'
            mapgen = getattr(self,'%sMap' % self.maintype.replace(' ',''))()
        rmap = mapgen[0]
        minmax = mapgen[1]

        self.wlev = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['wlev']
        self.mlev = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['mlev']

##        for subtype in self.subtypes:
##            dosub = getattr(self,'Sub%s' % subtype.replace(' ',''))(mapgen)

        self.colmap = libtcod.color_gen_map(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['keycols'], \
                                       self.rdict['%s-%s' % (self.maintype,self.tempzone)]['keyidx'])
        self.wcolmap = libtcod.color_gen_map(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['wkeycols'], \
                                        self.rdict['%s-%s' % (self.maintype,self.tempzone)]['wkeyidx'])
        self.dcolmap = libtcod.color_gen_map(self.rdict['%s-%s' % (self.maintype,self.tempzone)]['dkeycols'], \
                                       self.rdict['%s-%s' % (self.maintype,self.tempzone)]['dkeyidx'])
        altrange = minmax[1] - minmax[0]

        rheightmap = {}
        rterraindict = {}
        wlist = []

        for x in range(RMAP_WIDTH):
            for y in range(RMAP_HEIGHT):
                self.itemdict[self.curz]['%s,%s' % (x,y)] = {}

        for x in range(RMAP_WIDTH):
            for y in range(RMAP_HEIGHT):
                lock.acquire()
                self.shadowdict['%s,%s' % (x,y)] = [0.0,0.0]
                altitude = libtcod.heightmap_get_value(rmap, x, y)
                altperc = int(((minmax[1] - altitude) / altrange) * 200)
                if altperc > self.wlev:
                    col = self.colmap[altperc]
                    rheightmap['%s,%s' % (x,y)] = altperc
                    rterraindict['%s,%s' % (x,y)] = col
                    libtcod.console_set_char_background(wrwindow, x, y, col, libtcod.BKGND_SET)
                    if altperc >= self.mlev:
                        self.wobstructed[self.curz]['%s,%s' % (x,y)] = 'mountain'
                else:
                    self.wobstructed[self.curz]['%s,%s' % (x,y)] = 'water'
                    wlist.append([x,y])
                lock.release()

        wmin = 9999999999999
        wmax = 0

        for tile in wlist:
            altitude = libtcod.heightmap_get_value(rmap, tile[0], tile[1])
            if altitude > wmax:
                wmax = altitude
            if altitude < wmin:
                wmin = altitude

        waltrange = wmax - wmin

        for tile in wlist:
            lock.acquire()
            altitude = libtcod.heightmap_get_value(rmap, tile[0], tile[1])
            try:
                waltperc = int(((wmax - altitude) / waltrange) * 60)
            except ZeroDivisionError:
                waltperc = 50
            col = self.wcolmap[waltperc]
            rterraindict['%s,%s' % (tile[0],tile[1])] = col
            rheightmap['%s,%s' % (tile[0],tile[1])] = 'w%s' % waltperc
            libtcod.console_set_char_background(wrwindow, tile[0], tile[1], col, libtcod.BKGND_SET)
            lock.release()

        self.rheightmap = rheightmap
        self.rterraindict = rterraindict

        self.rtree = {}
        self.linkedareas = {}
        self.flood = {}
        self.flood[self.curz] = self.floodFill(self.wobstructed,captureimage = False)

        self.boulderdict = {}

        doshores = False
        for x in range(-1,2):
            for y in range(-1,2):
                if 'o' in wfeaturedict['%s,%s' % (self.curregion[0] + x,self.curregion[1] + y)] or \
                   'l' in wfeaturedict['%s,%s' % (self.curregion[0] + x,self.curregion[1] + y)]:
                    doshores = True

        self.shoretiles = {}
        self.oltiledict = {}
        if doshores:
            self.doLoadScreen('shores')
            self.doShoreLine()
            time.sleep(1.0)

        if 'r' in wfeaturedict['%s,%s' % (self.curregion[0],self.curregion[1])]:       
            self.doLoadScreen('river')
            self.digRiver()
            time.sleep(1.0)
        else:
            self.rtiledict = {}
                    
        self.flood[self.curz] = self.floodFill(self.wobstructed,captureimage = False)
        self.recalcRoutes()

        self.updateStatus()

        MouseLock = False
        NoKeys = False

    def loadMap(self,mapkey):
        global Clouds, lock
        regionmap = self.regiondict['%s,%s' % (mapkey[0],mapkey[1])]
        for key in regionmap.keys():
            if not key.startswith('_'):
                setattr(self, key, regionmap[key])
        self.curz = 0
        Clouds = CloudNoise(wrwindow,self.rheightmap)
        Clouds.initdone = True
        Clouds.colorswitch = True
        Clouds.start()
        for key in regionmap.keys():
            if key.startswith('_'):
                setattr(Clouds, key.strip('_'), regionmap[key])
        lock.acquire()
        for x in range(RMAP_WIDTH):
            for y in range(RMAP_HEIGHT):
                ztop = self.ztop.get('%s,%s' % (x,y))
                bgcol = self.rterraindict['%s,%s' % (x,y)]
                try:
                    fcol = self.shdict['%s,%s' % (x,y)][0]
                    char = self.shdict['%s,%s' % (x,y)][1]
                except KeyError:
                    char = self.rtextdict['%s,%s' % (x,y)][0]
                    fcol = self.rtextdict['%s,%s' % (x,y)][1]
                libtcod.console_set_default_foreground(self.window, fcol)
                libtcod.console_set_default_background(self.window, bgcol)
                libtcod.console_print_ex(self.window, x, y, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                if self.translayer[self.curz].get('%s,%s' % (x,y)):
                    shadperc = self.shadowdict['%s,%s' % (x,y)][1]
                    bgcol = libtcod.color_lerp(self.translayer[self.curz]['%s,%s' % (x,y)][0],libtcod.black,shadperc)
                    fcol = libtcod.color_lerp(self.translayer[self.curz]['%s,%s' % (x,y)][1],libtcod.black,shadperc)
                    char = self.translayer[self.curz]['%s,%s' % (x,y)][2]
                    if type(char) == list:
                        char = chr(DoChar(char))
                    libtcod.console_set_default_foreground(self.window, fcol)
                    libtcod.console_set_default_background(self.window, bgcol)
                    libtcod.console_print_ex(self.window, x, y, libtcod.BKGND_SET, libtcod.LEFT, char)
                elif type(ztop) == int:
                    try:
                        tile = self.zgrid[ztop]['%s,%s' % (x,y)]
                        buildtype = tile[0]
                        char = tile[2]
                        char[2] = 255
                        fg = tile[3]
                        bg = tile[4]
                        if buildtype == 'door':
                            if tile[5] == 'open':
                                try:
                                    ftile = tile[6]
                                    char = ftile[2]
                                    fg = ftile[3]
                                    bg = ftile[4]
                                    char[2] = 255
                                except IndexError:
                                    char = [0,0,255]
                        libtcod.console_set_default_foreground(wrwindow, fg)
                        if bg:
                            libtcod.console_set_default_background(wrwindow, bg)
                            libtcod.console_print_ex(wrwindow, x, y, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                        else:
                            libtcod.console_print_ex(wrwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                    except KeyError:
                        pass
                if self.itemdict[self.curz].get('%s,%s' % (x,y)) and not self.translayer[self.curz].get('%s,%s' % (x,y)):
                    items = self.itemdict[self.curz]['%s,%s' % (x,y)].values()
                    items.sort(key=lambda value: value[1],reverse = True)
                    item = items[0][0]
                    itemname = item[0]
                    itemstruct = self.invdict[item[1]][itemname]
                    fcol = libtcod.Color(int(self.matstruct[item[2]]['COLOR'][0]),int(self.matstruct[item[2]]['COLOR'][1]),int(self.matstruct[item[2]]['COLOR'][2]))
                    char = [int(itemstruct['CHAR'][0]),int(itemstruct['CHAR'][1]),255]
                    libtcod.console_print_ex(self.window, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
        lock.release()

    def packMap(self):
        global Clouds
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])] = {}
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['tempzone'] = copy.copy(self.tempzone)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['rtypes'] = copy.copy(self.rtypes)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['subtypes'] = copy.copy(self.subtypes)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['itemdict'] = copy.copy(self.itemdict)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['treedict'] = copy.copy(self.treedict)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['shdict'] = copy.copy(self.shdict)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['rheightmap'] = copy.copy(self.rheightmap)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['translayer'] = copy.copy(self.translayer)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['rterraindict'] = copy.copy(self.rterraindict)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['shadowdict'] = copy.copy(self.shadowdict)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['clouddict'] = copy.copy(self.clouddict)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['rtextdict'] = copy.copy(self.rtextdict)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['wcdict'] = copy.copy(self.wcdict)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['flood'] = copy.copy(self.flood)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['rtree'] = copy.copy(self.rtree)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['zgrid'] = copy.copy(self.zgrid)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['ztop'] = copy.copy(self.ztop)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['wobstructed'] = copy.copy(self.wobstructed)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['_ocolordict'] = copy.copy(Clouds.ocolordict)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['_ofcolordict'] = copy.copy(Clouds.ofcolordict)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['_ncolordict'] = copy.copy(Clouds.ncolordict)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['_nfcolordict'] = copy.copy(Clouds.nfcolordict)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['_vrskip'] = copy.copy(Clouds.vrskip)
        self.regiondict['%s,%s' % (self.curregion[0],self.curregion[1])]['_bskip'] = copy.copy(Clouds.bskip)

    def leaveRegion(self):
        global moveclouds, MouseLock, MoveLock, pathlock, pathclass
        try:
            pathclass.killswitch = True
        except NameError:
            pass
        LWindow = Dialogue([('Yes',self.doLeave),('No',doNothing)],title = 'Leave region?',resume = True)
        LWindow.start()        

    def doLeave(self):
        global DoLoadScreen
        libtcod.console_set_default_background(LoadScreen,libtcod.magenta)
        libtcod.console_clear(LoadScreen)
        DoLoadScreen = True
        q.put('world')
        time.sleep(1.0)

    def doLeaveProc(self):
        global MenuList, Clouds, PX, PY, PCX, PCY, MouseLock, MoveLock, pathlock, moveclouds, pathclass, PCcol, \
               OPCX, OPCY, hpcswitch, Cursor, BTorch, WeatherLayer, NoUpdate, DoLoadScreen, pathlock
        NoUpdate = True
        self.packMap()
        Clouds.killswitch = True
        moveclouds = False
        hpcswitch = False
        NoKeys,MouseLock,pathlock = True,True,True
        try:
            pathclass.killswitch = True
        except:
            pass
        self.wcdict[self.curz] = {}
        libtcod.console_clear(wrwindow)
        MenuList = []
        WeatherLayer = []
        self.window = wpwindow
        self.rswitch = False
        self.windowswitch = False
        libtcod.console_clear(wpwindow)
        PCX,PCY = self.curregion[0],self.curregion[1]
        DrawWorld(wpwindow,caves = False,drawcolors = False)
        self.curz = 0
        self.rtree,self.flood = {},{}
        self.flood[self.curz] = self.floodFill()
        self.recalcRoutes()
        DoLoadScreen = False
        self.winit = True
        moveclouds = True
        if self.groundview:
            self.groundview = False
        self.updateStatus()
        OPCX,OPCY = PCX,PCY
        adjustScreen()
        time.sleep(1)
        hpcswitch = True
        self.windowlock = False
        NoKeys,MouseLock,pathlock = False,False,False
        NoUpdate = False
        Clouds = WCloudNoise(wpwindow)
        Clouds.start()

    def loadWorld(self):
        global MenuSetting, MenuList, wdict
        MenuList = []
        wdictfile = open('.\\data\\world\\%s' % self.world + '.sav','rb')
        gc.disable()
        wdict = cPickle.load(wdictfile)
        gc.enable()
        wdictfile.close()
        LoadWorld(wdict)
        DrawWorld(wpwindow,caves = False,drawcolors = False)

    def displayCity(self,city = None):
        global PX,PY, TextList, Clouds
        
        TextList = []
        for Button in ButtonList:
            if Button.text == 'Begin Adventuring Here':
                ButtonList.remove(Button)
        libtcod.console_set_default_foreground(wiwindow,libtcod.white)
        if city:
            try:
                wcitydict[city]
                sitetype = 'city'
            except KeyError:
                sitetype = 'village'
            for tilex in range(-1,len(city) + 1):
                for tiley in range(-2,1):
                    x = globals()['w%sdict' % (sitetype)][city][0][0] - (len(city) / 2) + tilex
                    y = globals()['w%sdict' % (sitetype)][city][0][1] - 1 + tiley
                    
            libtcod.console_clear(wiwindow)
            #libtcod.console_print_ex(wiwindow, VIEW_WIDTH / 2, 2, libtcod.BKGND_NONE, libtcod.CENTER, 'The %s of %s' % (sitetype.capitalize(),city))
            for x in range(VIEW_WIDTH):
                for y in range(7):
                    libtcod.console_print_ex(0,20 + x,VIEW_HEIGHT + 3 + y,libtcod.BKGND_NONE,libtcod.LEFT,' ')
            bannertext = 'The %s of %s' % (sitetype.capitalize(),city)
            DrawBanner(wiwindow,VIEW_WIDTH / 2,2,bannertext)
            civname = globals()['w%sdict' % (sitetype)][city][1]
            fcol = wcivdict[civname + '-civcol2']
            bcol = wcivdict[civname + '-civcol2']
            cx = globals()['w%sdict' % (sitetype)][city][0][0] - 1
            cy = globals()['w%sdict' % (sitetype)][city][0][1] - 3
            libtcod.console_set_default_background(wpfxwindow,libtcod.magenta)
            libtcod.console_clear(wpfxwindow)
            for x in range(len(city) + 2):
                for y in range(3):
                    bgcol = libtcod.console_get_char_background(wpwindow,cx - (len(city) / 2) + x,cy + y)
                    libtcod.console_set_char_background(wpfxwindow,cx - (len(city) / 2) + x,cy + y,bgcol,libtcod.BKGND_SET)
            DrawScroll(wpfxwindow, cx - (len(city) / 2), cy, len(city) + 1, 2)
            libtcod.console_set_default_foreground(wpfxwindow,fcol)
            libtcod.console_print_ex(wpfxwindow, cx + 1, cy + 1, libtcod.BKGND_NONE, libtcod.CENTER, city)
            selectbutton = ButtonBox(wiwindow, (VIEW_WIDTH / 2) - 11, 8, 'Begin Adventuring Here', 'b', offx = SCREEN_WIDTH - VIEW_WIDTH - 2, offy = VIEW_HEIGHT)
            self.startregion = [globals()['w%sdict' % (sitetype)][city][0][0],globals()['w%sdict' % (sitetype)][city][0][1]]
            self.curregion = self.startregion
            self.startcity = city
        
    # Game Start Functions

    def siteMenu(self):
        global MenuSetting, MenuList, ButtonList
        MenuList = []
        TextList = []
        optionlist = ['Cities','Villages']

        for Button in ButtonList:
            if Button.text == 'Begin Adventuring Here':
                ButtonList.remove(Button)
            else:
                Button.drawButton()
                
        MenuSetting = 'PWStartLoc'
        StartLocMenu = Menu(wswindow, 2, 4, optionlist, title = 'Starting Sites:', talign = 'center', tx = 9, ty = 2, \
                            MethodList = [('Cities',self.loadCities),('Villages',self.loadVillages)], BMethodList = [doIntroSetup], \
                            drawbox = True, tback = True).start()

        pwtext = 'Select a location in which to begin your journey in the world of ' + worldname + ', adventurer.'
        CurText = FadeText(textWrap(pwtext)[0], VIEW_WIDTH / 2, 4, con=wiwindow, speed=50, align='center').start()
        pwtext = 'You may choose from any city or town by selecting its entry from the list on the left, or by left-clicking its icon on the world map. ' \
                 + 'You can navigate the world map with directional keys or by left-clicking and dragging the map directly.'
        CurText = FadeText(textWrap(pwtext)[0], VIEW_WIDTH / 2, 6, con=wiwindow, speed=50, align='center').start()

    def loadCities(self):
        global MenuSetting, MenuList
        MenuList = []
        MenuSetting = 'PWSelectSite'
        optionlist = wcitydict.keys()
        doScreenSetup()
        for Button in ButtonList:
            Button.drawButton()
        StartLocCities = Menu(wswindow, 2, 4, optionlist, title = 'Cities:', talign = 'center', tx = 9, ty = 2, \
                              MethodList = [(True,self.viewSite)], BMethodList = [doScreenSetup,self.siteMenu], \
                              drawbox = True, tback = True)
        StartLocCities.start()
        self.optionlist = StartLocCities.optionlist

    def loadVillages(self):
        global MenuSetting, MenuList
        MenuList = []
        MenuSetting = 'PWSelectSite'
        optionlist = wvillagedict.keys()
        doScreenSetup()
        for Button in ButtonList:
            Button.drawButton()
        StartLocCities = Menu(wswindow, 2, 4, optionlist, title = 'Villages:', talign = 'center', tx = 9, ty = 2, \
                              MethodList = [(True,self.viewSite)], BMethodList = [doScreenSetup,self.siteMenu], \
                              drawbox = True, tback = True)
        StartLocCities.start()
        self.optionlist = StartLocCities.optionlist

    def viewSite(self):
        global PX, PY
        try:
            PX,PY = wcitydict[self.optionlist[mplayery - 1]][0][0] - (VIEW_WIDTH / 2),wcitydict[self.optionlist[mplayery - 1]][0][1] - (VIEW_HEIGHT / 2)
            GameWorld.displayCity(city = self.optionlist[mplayery - 1])
        except KeyError:
            PX,PY = wvillagedict[self.optionlist[mplayery - 1]][0][0] - (VIEW_WIDTH / 2),wvillagedict[self.optionlist[mplayery - 1]][0][1] - (VIEW_HEIGHT / 2)
            GameWorld.displayCity(city = self.optionlist[mplayery - 1])

    def setupStart(self):
        global MenuSetting, MenuList, TextList, PX, PY, PCX, PCY, OPCX, OPCY, MLogBar, Clouds, MouseLock, moveclouds, hpcswitch, music, DoHUD, rtypes, DoLoadScreen, MoveLock
        MoveLock,MouseLock = True,True
        DoHUD = True
        Clouds.killswitch = True
        MenuSetting = None
        MenuList = []
        PX,PY = (RMAP_WIDTH / 2) - (VIEW_WIDTH / 2),(RMAP_HEIGHT / 2) - (VIEW_HEIGHT / 2)
        PCX,PCY = (RMAP_WIDTH / 2) - 1,(RMAP_HEIGHT / 2)
        OPCX,OPCY = PCX,PCY
        libtcod.console_set_default_foreground(0, libtcod.white)
        libtcod.console_print_ex(0, (SCREEN_WIDTH - (VIEW_WIDTH / 2)) - 9, VIEW_HEIGHT + 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercape)))
        libtcod.console_print_ex(0, (SCREEN_WIDTH - (VIEW_WIDTH / 2)) - 8, VIEW_HEIGHT + 2, libtcod.BKGND_NONE, libtcod.LEFT, ' Message Log ')
        libtcod.console_print_ex(0, (SCREEN_WIDTH - (VIEW_WIDTH / 2)) + 5, VIEW_HEIGHT + 2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(bordercapw)))
        libtcod.console_flush()
        MLogBar = ScrollBar(wiwindow, VIEW_WIDTH - 1, 0, SCREEN_HEIGHT - VIEW_HEIGHT - 3, SCREEN_WIDTH - 3, VIEW_HEIGHT + 3, \
                            arrowcolor = libtcod.Color(173,230,116), bgcolor = bgcolor, \
                            hcolor = libtcod.Color(173,230,116), ID = 'MLogBar')
        MLogBar.start()
        self.window = wrwindow
        self.pswitch = True
        playMusic('music\\wav\\Cult-spring.wav',-1)
        self.addMesg('Generating map, one moment...',col = libtcod.light_orange)
        rtypes = wbiomedict['%s,%s' % (self.curregion[0],self.curregion[1])]
        libtcod.console_set_default_background(LoadScreen,libtcod.magenta)
        libtcod.console_clear(LoadScreen)
        DoLoadScreen = True
        self.rswitch = True
        self.genMap(rtypes)
        q.put('genproc-terrain')
        q.put('genproc-trees')
        q.put('genproc-scrub')
        q.put('genproc-misc')
        while not q.empty():
            time.sleep(0.1)
            MoveLock, MouseLock = True,True
        moveclouds = False
        Clouds = CloudNoise(wrwindow,rheightmap)
        Clouds.start()
        time.sleep(0.5)
        DoLoadScreen = False
        self.rinit = True
        self.setupdone = True
        hpcswitch = True
        self.inventory = {}
        for num in range(36):
            self.inventory[num] = None
        self.inventory[0] = ['hatchet','weapon','iron',1]
        self.inventory[1] = ['pick','weapon','iron',1]
        self.inventory[2] = ['log','component','wood',5000]
        self.inventory[3] = ['stone','component','stone',5000]
        self.inventory[4] = ['glass','component','glass',500]
        MoveLock,MouseLock = False,False
        self.runtime = True
        self.showclock = True

    # Struct File Loading

    def LoadStruct(self,raw):
        sdict = {}
        structfile = open('data\\struct\\%s.txt' % raw, 'r')
        struct = structfile.readlines()
        structfile.close()
        for line in struct:
            line = line.strip('\n')
            if line.startswith('>>'):
                entry = line.strip('>> ')
                sdict[entry] = {}
            elif line.startswith('<<') or line == '':
                pass
            else:
                cat = line.split(': ')[0]
                tags = line.split(': ')[1].split(' | ')
                sdict[entry][cat] = tags
        return sdict

    # Construction File Loading

    def LoadCon(self,raw):
        cdict = {}
        confile = open('data\\build\\%s.txt' % raw, 'r')
        con = confile.readlines()
        confile.close()
        for line in con:
            line = line.strip('\n')
            if line.startswith('>>'):
                entry = line.strip('>> ')
                cdict[entry] = {}
            elif line.startswith('<<') or line == '':
                pass
            else:
                cat = line.split(': ')[0]
                tags = line.split(': ')[1].split(' | ')
                if cat == 'CHARS':
                    for tag in range(len(tags)):
                        tags[tag] = (int(tags[tag].split(',')[0]),int(tags[tag].split(',')[1]))
                cdict[entry][cat] = tags
        return cdict

    # Terrain File Loading

    def LoadTerrain(self,folder,raw):
        coordcats = ['GRASS','TALLGRASS','LEAF','DIRT','WATER']
        intcats = ['VARIATIONS','WIDTH','HEIGHT','XLOC','YLOC']
        terdict = {}
        terfile = open('data\\terrain\\%s\\%s.txt' % (folder,raw), 'r')
        ter = terfile.readlines()
        terfile.close()
        for line in ter:
            line = line.strip('\n')
            if line.startswith('>>'):
                entry = line.strip('>> ')
                terdict[entry] = {}
            elif line.startswith('<<') or line == '':
                pass
            else:
                cat = line.split(': ')[0]
                tags = line.split(': ')[1].split(' | ')
                if cat in coordcats:
                    for tag in range(len(tags)):
                        tags[tag] = (int(tags[tag].split(',')[0]),int(tags[tag].split(',')[1]))
                    terdict[entry][cat] = tags
                elif cat in intcats:
                    terdict[entry][cat] = int(tags[0])
                else:
                    terdict[entry][cat] = tags
        return terdict

    # Game Options

    def doOptions(self):
        global Options, pathclass
        try:
            pathclass.killswitch = True
        except NameError:
            pass
        time.sleep(0.2)
        if not self.topwindow:
            if not self.optopen:
                Options = OptWindow()
                Options.start()
                self.optopen = True
                self.opaused = self.paused
                self.oruntime = self.runtime
                self.paused = True
                self.runtime = False
            else:
                Options.close()
                self.optopen = False
                self.paused = self.opaused
                self.runtime = self.oruntime
                del self.opaused
                del self.oruntime

    # Inventory & Related

    def addToInv(self,item,number = 1):
        space = False
        for invnum in range(35):
            if not self.inventory.get(invnum):
                space = (True,invnum)
                break
        for invnum in range(35):
            try:
                if self.inventory[invnum][0] == item[0]:
                    space = (True,invnum)
                    break
            except TypeError:
                pass
        if space:
            if self.inventory.get(space[1]):
                self.inventory[space[1]][3] += number
                self.addMesg('You now have %s %s.' % (p.number_to_words(self.inventory[space[1]][3]),p.plural_noun(item[0])))
            else:
                invfinal = item
                
                self.inventory[space[1]] = item
                self.inventory[space[1]][3] = number
                if number == 1:
                    self.addMesg('You now have the %s.' % item[0])
                else:
                    self.addMesg('You now have %s %s.' % (p.number_to_words(number),p.plural_noun(item[0])))
            return True
        else:
            self.addMesg('You don\'t have any space for that!', col = libtcod.yellow)
            return False

    def doInventory(self):
        global Inventory, pathclass
        try:
            pathclass.killswitch = True
        except NameError:
            pass
        time.sleep(0.2)
        if not self.topwindow:
            if not self.invopen:
                Inventory = InvWindow(self.window)
                Inventory.start()
                self.invopen = True
                self.opaused = self.paused
                self.oruntime = self.runtime
                self.paused = True
                self.runtime = False
            else:
                Inventory.close()
                self.invopen = False
                self.paused = self.opaused
                self.runtime = self.oruntime
                del self.opaused
                del self.oruntime

            
    def getItem(self,item = None,number = False):
        global PCX, PCY
        if (not number) and item:
            if item[3] > 1:
                GetItemDialogue = NDialogue(item[3],self.getItem,item = item,resume = True)
                GetItemDialogue.start()
            else:
                self.getItem(item,1)
        elif not item:
            if self.itemdict[self.curz].get('%s,%s' % (PCX,PCY)):
                if len(self.itemdict[self.curz]['%s,%s' % (PCX,PCY)]) > 1:
                    doitems = []
                    for value in self.itemdict[self.curz]['%s,%s' % (PCX,PCY)].values():
                        item = value[0]
                        itemname = item[0]
                        if item[3] > 1:
                            itemnum = ' (' + str(item[3]) + ')'
                        else:
                            itemnum = ''
                        doitems += [(itemname.capitalize() + itemnum,self.getItem,item)]
                    self.ItemDialogue = Dialogue(doitems,title = 'Pick up which item?',resume = True)
                    self.ItemDialogue.start()
                else:
                    item = self.itemdict[self.curz]['%s,%s' % (PCX,PCY)].values()[0][0]
                    self.getItem(item)         
            else:
                self.addMesg('There\'s nothing there to pick up.', col = libtcod.yellow)
        else:
            aitem,anumber = copy.copy(item),copy.copy(number)
            hasroom = self.addToInv(aitem,anumber)
            if hasroom:
                if number == item[3]:
                    self.itemdict[self.curz]['%s,%s' % (PCX,PCY)].pop('%s-%s' % (item[0],item[2]))
                    try:
                        Clouds.nfcolordict.pop('%s,%s' % (PCX,PCY))
                    except KeyError:
                        pass
                    if self.zgrid[self.curz].get('%s,%s' % (PCX,PCY)):
                        gridcols = self.getgridColor(PCX,PCY)
                        Clouds.nfcolordict['%s,%s' % (PCX,PCY)] = gridcols[1]
                else:
                    self.itemdict[self.curz]['%s,%s' % (PCX,PCY)]['%s-%s' % (item[0],item[2])][0][3] -= number

    def getgridColor(self,x,y):
        tile = self.zgrid[self.curz]['%s,%s' % (x,y)]
        buildtype = tile[0]
        fg = tile[3]
        bg = tile[4]
        char = tile[2]
        char[2] = 255
        if buildtype == 'door':
            if tile[5] == 'open':
                try:
                    ftile = tile[6]
                    char = ftile[2]
                    fg = ftile[3]
                    bg = ftile[4]
                    char[2] = 255
                except IndexError:
                    char = [0,0,255]
        if self.curz == self.ztop.get('%s,%s' % (x,y)):
            if self.curz == 0:
                try:
                    sperc = max(self.shadowdict['%s,%s' % (x,y)][0],self.shadowdict['%s,%s' % (x,y)][1])
                    fg = libtcod.color_lerp(fg, libtcod.black, sperc)
                    if bg:
                        bg = libtcod.color_lerp(bg, libtcod.black, sperc)
                except IndexError:
                    print buildtype
        if buildtype == 'roof':
            lighten = 0.0
            nzrange = range(self.ztop['%s,%s' % (x,y)])
            nzrange.reverse()
            for nz in nzrange:
                if self.zgrid[nz].get('%s,%s' % (x,y)):
                    lighten = min(0.3,lighten + 0.03)
            fg = libtcod.color_lerp(fg, libtcod.white, lighten)
            if bg:
                bg = libtcod.color_lerp(bg, libtcod.white, lighten)
        return [bg,fg]

    def pickUp(self):
        global ActionMenu, PCX, PCY
        x = ActionMenu.x
        y = ActionMenu.y
        MoveLock = True
        pathdone = False
        if [PCX,PCY] == [x,y]:
            pathdone = True
        else:
            path = Pathfinder(self.wobstructed[self.curz],self.flood[self.curz],PCX,PCY,x,y,domove = False)
            path.start()
            while path.pathgoing:
                time.sleep(0.1)
            if path.path:
                pathdone = True
                path.movePC(path.path)
        if pathdone:
            self.getItem()

    def placeItem(self,item,x,y):
        global PCX, PCY, Clouds
        if GameWorld.itemdict[GameWorld.curz]['%s,%s' % (x,y)].get('%s-%s' % (item[0],item[2])):
            GameWorld.itemdict[GameWorld.curz]['%s,%s' % (x,y)]['%s-%s' % (item[0],item[2])][0][3] += item[3]
        else:
            GameWorld.itemdict[GameWorld.curz]['%s,%s' % (x,y)]['%s-%s' % (item[0],item[2])] = [item,time.time()]
        itemname = item[0]
        col = libtcod.white
        itemstruct = GameWorld.invdict[item[1]][itemname]
        char = [int(itemstruct['CHAR'][0]),int(itemstruct['CHAR'][1]),255]
        col = libtcod.color_lerp(col, libtcod.black, max(self.shadowdict['%s,%s' % (x,y)][0],self.shadowdict['%s,%s' % (x,y)][1]))
        if [PCX,PCY] != [x,y]:
            libtcod.console_set_default_foreground(self.window, col)
            libtcod.console_print_ex(self.window, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))

    # Construction System

    def doConstruction(self):
        global Constructions, pathclass
        try:
            pathclass.killswitch = True
        except NameError:
            pass
        time.sleep(0.2)
        if not self.topwindow:
            if not self.cmopen:
                Constructions = CWindow()
                Constructions.start()
                self.cmopen = True
                self.opaused = self.paused
                self.oruntime = self.runtime
                self.paused = True
                self.runtime = False
            else:
                Constructions.close()
                self.cmopen = False        
                self.paused = self.opaused
                self.runtime = self.oruntime
                del self.opaused
                del self.oruntime

    # PC Action Handling

    def getActionType(self,x,y):
        num = PCX - x
        num2 = PCY - y
        a = pow(num, 2)
        b = pow(num2, 2)
        d = sqrt(a + b)
        atype = 'none'
        if self.itemdict[self.curz].get('%s,%s' % (x,y)):
            atype = 'item'
        elif self.zgrid[self.curz].get('%s,%s' % (x,y)):
            if self.zgrid[self.curz]['%s,%s' % (x,y)][0] == 'door':
                if self.zgrid[self.curz]['%s,%s' % (x,y)][5] == 'closed':
                    atype = 'door-closed'
                else:
                    atype = 'door-open'
            elif self.zgrid[self.curz]['%s,%s' % (x,y)][0] == 'stairs':
                if self.zgrid[self.curz]['%s,%s' % (x,y)][5] == 'up-stairs':
                    atype = 'up-stairs'
                else:
                    atype = 'down-stairs'
            elif self.zgrid[self.curz]['%s,%s' % (x,y)][0] == 'ladder':
                if self.zgrid[self.curz]['%s,%s' % (x,y)][5] == 'up-ladder':
                    atype = 'up-ladder'
                else:
                    atype = 'down-ladder'
        elif self.wobstructed[self.curz].get('%s,%s' % (x,y)):
            atype = self.wobstructed[self.curz].get('%s,%s' % (x,y))
        elif self.ldict.get('%s,%s' % (x,y)) and d > ViewRad:
            atype = 'tree'
            if self.copsedict.get('%s,%s' % (x,y)):
                atype = 'copse'
        return atype

    def doActionMenu(self,x,y,ox,oy):
        global PCX, PCY, PX, PY, ActionMenu
        choices = self.adict[self.getActionType(x,y)]
        ActionMenu = Dialogue(choices, resume = True, offx = ox, offy = oy, killonclick = True, align = 'left')
        ActionMenu.x,ActionMenu.y = x,y
        ActionMenu.start()

    # PC Actions

    def fellTree(self):
        global ActionMenu, Clouds, PCX, PCY, PCcol, MoveLock
        canchop = False
        for item in self.inventory.values():
            try:
                if 'CHOP_TREES' in self.weaponstruct[item[0]]['TAGS']:
                    tool = item[0]
                    canchop = True
            except:
                pass
        if canchop:
            x = ActionMenu.x
            y = ActionMenu.y
            tlist = []
            MoveLock = True
            for num in range(-1,2):
                for num2 in range(-1,2):
                    if [num,num2] != [0,0]:
                        tlist.append([num,num2])
            tlist.sort(key=lambda tile: sqrt((pow(PCX - (x + tile[0]),2) + pow(PCY - (y + tile[1]),2)))) 
            for tile in tlist:
                pathdone = False
                if [PCX,PCY] == [x + tile[0],y + tile[1]]:
                    pathdone = True
                else:
                    path = Pathfinder(self.wobstructed[self.curz],self.flood[self.curz],PCX,PCY,x + tile[0],y + tile[1],domove = False,notify = False)
                    path.start()
                    while path.pathgoing:
                        time.sleep(0.1)
                    if path.path:
                        pathdone = True
                        path.movePC(path.path)
                    elif tile == tlist[-1]:
                        GameWorld.addMesg('You can\'t reach that place.', col = libtcod.yellow)
                if pathdone:
                    ttime = 0.0
                    treesound = playSound('sounds\\ogg\\chop.ogg')
                    self.addMesg('You begin chopping down the tree with your %s.' % tool)
                    Progress = ProgressBar('Felling',5)
                    Progress.start()
                    while ttime < 5.0:
                        time.sleep(0.5)
                        ttime += 0.5
                        Progress.inc += 0.5
                    time.sleep(0.3)
                    Progress.killswitch = True
                    treesound.stop()
                    treerad = self.treedict['%s,%s' % (x,y)][0][2]
                    llist = []
                    for tile in self.treedict['%s,%s' % (x,y)][1:]:
                        if not self.wobstructed[self.curz].get('%s,%s' % (tile[0],tile[1])):
                            llist.append(tile)
                        try:
                            Clouds.vrskip.pop('%s,%s' % (tile[0],tile[1]))
                        except KeyError:
                            pass
                        shadow = max(self.shadowdict['%s,%s' % (tile[0],tile[1])][0],self.shadowdict['%s,%s' % (tile[0],tile[1])][1])
                        bgcol = self.rterraindict['%s,%s' % (tile[0],tile[1])]
                        try:
                            fcol = self.shdict['%s,%s' % (tile[0],tile[1])][0]
                            char = self.shdict['%s,%s' % (tile[0],tile[1])][1]
                        except KeyError:
                            char = self.rtextdict['%s,%s' % (tile[0],tile[1])][0]
                            fcol = self.rtextdict['%s,%s' % (tile[0],tile[1])][1]
                        if self.itemdict[self.curz].get('%s,%s' % (tile[0],tile[1])):
                            items = self.itemdict[self.curz]['%s,%s' % (tile[0],tile[1])].values()
                            items.sort(key=lambda value: value[1],reverse = True)
                            item = items[0][0]
                            itemname = item[0]
                            itemstruct = self.invdict[item[1]][itemname]
                            fcol = libtcod.white
                            char = [int(itemstruct['CHAR'][0]),int(itemstruct['CHAR'][1]),255]
                        if not type(self.rheightmap['%s,%s' % (tile[0],tile[1])]) == str:
                            Clouds.ocolordict['%s,%s' % (tile[0],tile[1])] = bgcol
                            libtcod.console_set_default_foreground(self.window, fcol)
                            libtcod.console_set_default_background(self.window, bgcol)
                            libtcod.console_print_ex(self.window, tile[0], tile[1], libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                        else:
                            libtcod.console_set_default_foreground(self.window, fcol)
                            libtcod.console_print_ex(self.window, tile[0], tile[1], libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                        self.translayer[self.curz].pop('%s,%s' % (tile[0],tile[1]))
                        try:
                            self.ldict.pop('%s,%s' % (tile[0],tile[1]))
                        except KeyError:
                            pass
                    self.handlePCchar()
                    playSound('sounds\\ogg\\treefall.ogg')
                    self.addMesg('You chop down the tree.')
                    log = ['log','component','wood',1]
                    for section in range(treerad):
                        if len(llist) == 0:
                            break
                        tile = choice(llist)
                        llist.remove(tile)
                        self.placeItem(log,tile[0],tile[1])
                    self.wobstructed[self.curz].pop('%s,%s' % (x,y))
                    for area in self.flood[self.curz]:
                        if self.flood[self.curz][area].get('%s,%s' % (PCX,PCY)):
                            curarea = area
                    self.flood[self.curz][curarea]['%s,%s' % (x,y)] = True
                    self.treedict.pop('%s,%s' % (x,y))
                    break
                
        else:
            self.addMesg('You don\'t have anything to chop that down with.', col = libtcod.yellow)
        MoveLock = False

    def fellCopse(self):
        self.addMesg('Felling such a thick copse of trees requires several workers.')

    def mineRock(self):
        global PCX, PCY, ActionMenu, MoveLock
        canmine = False
        for item in self.inventory.values():
            try:
                if item[0] == 'pick':
                    canmine = True
            except:
                pass
        if canmine:
            x = ActionMenu.x
            y = ActionMenu.y
            tlist = []
            MoveLock = True
            self.windowlock = True
            for num in range(-1,2):
                for num2 in range(-1,2):
                    if [num,num2] != [0,0]:
                        tlist.append([num,num2])
            tlist.sort(key=lambda tile: sqrt((pow(PCX - (x + tile[0]),2) + pow(PCY - (y + tile[1]),2)))) 
            for tile in tlist:
                pathdone = False
                if [PCX,PCY] == [x + tile[0],y + tile[1]]:
                    pathdone = True
                else:
                    path = Pathfinder(self.wobstructed[self.curz],self.flood[self.curz],PCX,PCY,x + tile[0],y + tile[1],domove = False,notify = False)
                    path.start()
                    while path.pathgoing:
                        time.sleep(0.1)
                    if path.path:
                        pathdone = True
                        path.movePC(path.path)
                    elif tile == tlist[-1]:
                        GameWorld.addMesg('You can\'t reach that place.', col = libtcod.yellow)
                if pathdone:
                    ttime = 0.0
                    picksound = playSound('sounds\\ogg\\pick.ogg')
                    self.addMesg('You begin mining the rock.')
                    Progress = ProgressBar('Mining',7)
                    Progress.start()
                    while ttime < 7.0:
                        time.sleep(0.5)
                        ttime += 0.5
                        Progress.inc += 0.5
                    Progress.killswitch = True
                    picksound.stop()
                    soillist = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['soilcol']
                    rocklist = self.rdict['%s-%s' % (self.maintype,self.tempzone)]['rockcol']
                    rockcolor = libtcod.Color(rocklist[0],rocklist[1],rocklist[2])
                    soilcolor = libtcod.Color(soillist[0],soillist[1],soillist[2])
                    soilcolor = libtcod.color_lerp(soilcolor,libtcod.black,self.shadowdict['%s,%s' % (x,y)][0])
                    soilfcolor = libtcod.color_lerp(soilcolor,rockcolor,0.4)
                    libtcod.console_set_char_background(self.window, x, y, soilcolor, libtcod.BKGND_SET)
                    libtcod.console_set_char_foreground(self.window, x, y, soilfcolor)
                    Clouds.ocolordict['%s,%s' % (x,y)] = soilcolor
                    Clouds.ofcolordict['%s,%s' % (x,y)] = soilfcolor
                    newchar = choice(grasschars)
                    self.rtextdict['%s,%s' % (x,y)] = [ord(newchar),soilfcolor]
                    rock = ['stone','component','stone',1]
                    self.placeItem(rock,x,y)
                    self.wobstructed[self.curz].pop('%s,%s' % (x,y))
                    for area in self.flood[self.curz]:
                        if self.flood[self.curz][area].get('%s,%s' % (PCX,PCY)):
                            curarea = area
                    self.flood[self.curz][curarea]['%s,%s' % (x,y)] = True
                    self.rheightmap['%s,%s' % (x,y)] = self.mlev - 1
                    break
        else:
            self.addMesg('You don\'t have anything to mine with.', col = libtcod.yellow)
        MoveLock = False
        self.windowlock = False

    def recalcRoutes(self):
        self.rtree[self.curz] = {}
        areas = []
        for area in self.linkedareas[self.curz]:
            self.rtree[self.curz][area] = []
        for area in self.rtree[self.curz]:
            areas.append(area)
            pool = self.linkedareas[self.curz][area].keys()
            finalpool = []
            while len(pool) > 0:
                curarea = pool[0]
                if curarea not in finalpool and curarea != area:
                    finalpool.append(curarea)
                for addarea in self.linkedareas[self.curz][curarea]:
                    if addarea not in finalpool:
                        pool.append(addarea)
                pool.remove(curarea)
            self.rtree[self.curz][area] = finalpool

    def openDoor(self):
        x = ActionMenu.x
        y = ActionMenu.y
        tlist = []
        MoveLock = True
        self.windowlock = True
        for num in range(-1,2):
            for num2 in range(-1,2):
                if [num,num2] != [0,0]:
                    tlist.append([num,num2])
        tlist.sort(key=lambda tile: sqrt((pow(PCX - (x + tile[0]),2) + pow(PCY - (y + tile[1]),2)))) 
        for tile in tlist:
            pathdone = False
            if [PCX,PCY] == [x + tile[0],y + tile[1]]:
                pathdone = True
            else:
                path = Pathfinder(self.wobstructed[self.curz],self.flood[self.curz],PCX,PCY,x + tile[0],y + tile[1],domove = False,notify = False)
                path.start()
                while path.pathgoing:
                    time.sleep(0.1)
                if path.path:
                    pathdone = True
                    path.movePC(path.path)
                elif tile == tlist[-1]:
                    GameWorld.addMesg('You can\'t reach that place.', col = libtcod.yellow)
            if pathdone:
                self.openSet(x,y)
                self.recalcRoutes()
                if self.zgrid[self.curz]['%s,%s' % (x,y)][1] == 'Stone Door':
                    doorsound = playSound('sounds\\wav\\stonedooropen.wav')
                else:
                    doorsound = playSound('sounds\\wav\\dooropen.wav')
                self.zgrid[self.curz]['%s,%s' % (x,y)][5] = 'open'
                self.wobstructed[self.curz].pop('%s,%s' % (x,y))
                self.addMesg('You open the door.')
                break
        self.handlePCview()
        MoveLock = False
        self.windowlock = False        

    def openSet(self,x,y):
        doorareas = []
        for num in range(-1,2):
            for num2 in range(-1,2):
                for area in self.flood[self.curz]:
                    if self.flood[self.curz][area].get('%s,%s' % (x + num,y + num2)):
                        if area not in doorareas:
                            doorareas.append(area)
        if len(doorareas) > 1:
            for area in doorareas:
                for addarea in doorareas:
                    if area == addarea:
                        continue
                    if type(self.linkedareas[self.curz][area].get(addarea)) == int:
                        self.linkedareas[self.curz][area][addarea] += 1
                    else:
                        self.linkedareas[self.curz][area][addarea] = 1
        self.flood[self.curz][doorareas[0]]['%s,%s' % (x,y)] = True

    def closeDoor(self):
        x = ActionMenu.x
        y = ActionMenu.y
        tlist = []
        MoveLock = True
        self.windowlock = True
        for num in range(-1,2):
            for num2 in range(-1,2):
                if [num,num2] != [0,0]:
                    tlist.append([num,num2])
        tlist.sort(key=lambda tile: sqrt((pow(PCX - (x + tile[0]),2) + pow(PCY - (y + tile[1]),2)))) 
        for tile in tlist:
            pathdone = False
            if [PCX,PCY] == [x + tile[0],y + tile[1]]:
                pathdone = True
            else:
                path = Pathfinder(self.wobstructed[self.curz],self.flood[self.curz],PCX,PCY,x + tile[0],y + tile[1],domove = False,notify = False)
                path.start()
                while path.pathgoing:
                    time.sleep(0.1)
                if path.path:
                    pathdone = True
                    path.movePC(path.path)
                elif tile == tlist[-1]:
                    GameWorld.addMesg('You can\'t reach that place.', col = libtcod.yellow)
            if pathdone:
                ttime = 0.0
                doorareas = []
                for num in range(-1,2):
                    for num2 in range(-1,2):
                        for area in self.flood[self.curz]:
                            if self.flood[self.curz][area].get('%s,%s' % (x + num,y + num2)):
                                if area not in doorareas:
                                    doorareas.append(area)
                if len(doorareas) > 1:
                    for area in doorareas:
                        for addarea in doorareas:
                            if area == addarea:
                                continue
                            if type(self.linkedareas[self.curz][area].get(addarea)) == int:
                                if self.linkedareas[self.curz][area][addarea] > 1:
                                    self.linkedareas[self.curz][area][addarea] -= 1
                                else:
                                    self.linkedareas[self.curz][area].pop(addarea)
                            else:
                                pass
                self.flood[self.curz][doorareas[0]].pop('%s,%s' % (x,y))
                self.recalcRoutes()
                if self.zgrid[self.curz]['%s,%s' % (x,y)][1] == 'Stone Door':
                    doorsound = playSound('sounds\\wav\\stonedoorclose.wav')
                else:
                    doorsound = playSound('sounds\\wav\\doorclose.wav')
                tile = self.zgrid[self.curz]['%s,%s' % (x,y)]
                char = tile[2]
                fg = tile[3]
                bg = tile[4]
                char[2] = 255
                libtcod.console_set_default_foreground(wrwindow, fg)
                if bg:
                    libtcod.console_set_default_background(wrwindow, bg)
                    libtcod.console_print_ex(wrwindow, x, y, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                else:
                    libtcod.console_print_ex(wrwindow, x, y, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                self.zgrid[self.curz]['%s,%s' % (x,y)][5] = 'closed'
                self.wobstructed[self.curz]['%s,%s' % (x,y)] = 'door'
                self.addMesg('You close the door.')
                break
        self.handlePCview()
        MoveLock = False
        self.windowlock = False

    def climbStairs(self,x = None,y = None):
        if not x:
            x = ActionMenu.x
        if not y:
            y = ActionMenu.y
        tlist = []
        MoveLock = True
        self.windowlock = True
        pathdone = False
        if [PCX,PCY] == [x,y]:
            pathdone = True
        else:
            path = Pathfinder(self.wobstructed[self.curz],self.flood[self.curz],PCX,PCY,x,y,domove = False,notify = False)
            path.start()
            while path.pathgoing:
                time.sleep(0.1)
            if path.path:
                pathdone = True
                path.movePC(path.path)
            else:
                GameWorld.addMesg('You can\'t reach that place.', col = libtcod.yellow)
        if pathdone:
            stairsound = playSound('sounds\\ogg\\stairstep.ogg',3000)
            self.changeZ(1)
            if not self.flood.get(self.curz):
                self.flood[self.curz] = self.floodFill(self.wobstructed)
            self.recalcRoutes()
        self.handlePCview()
        MoveLock = False
        self.windowlock = False

    def descendStairs(self,x = None,y = None):
        if not x:
            x = ActionMenu.x
        if not y:
            y = ActionMenu.y
        tlist = []
        MoveLock = True
        self.windowlock = True
        pathdone = False
        if [PCX,PCY] == [x,y]:
            pathdone = True
        else:
            path = Pathfinder(self.wobstructed[self.curz],self.flood[self.curz],PCX,PCY,x,y,domove = False,notify = False)
            path.start()
            while path.pathgoing:
                time.sleep(0.1)
            if path.path:
                pathdone = True
                path.movePC(path.path)
            else:
                GameWorld.addMesg('You can\'t reach that place.', col = libtcod.yellow)
        if pathdone:
            stairsound = playSound('sounds\\ogg\\stairstep.ogg',3000)
            self.changeZ(-1)
            if not self.flood.get(self.curz):
                self.flood[self.curz] = self.floodFill(self.wobstructed)
            self.recalcRoutes()
        self.handlePCview()
        MoveLock = False
        self.windowlock = False

    def changeZ(self,n):
        global PX, PY, WeatherLayer
        time.sleep(0.5)
        self.curz += n
        for conlist in WeatherLayer:
            if conlist[0] == self.zconsole:
                WeatherLayer.remove(conlist)
        if self.curz > 0:
            libtcod.console_set_default_background(self.zconsole, libtcod.black)
            libtcod.console_clear(self.zconsole)
            libtcod.console_set_key_color(self.zconsole, libtcod.magenta)
            zmod = min((self.curz * 0.05) + .2,0.8)
            for key in self.zgrid[self.curz].keys():
                x = int(key.split(',')[0])
                y = int(key.split(',')[1])
                libtcod.console_set_char_background(self.zconsole, x, y, libtcod.magenta, libtcod.BKGND_SET)
            self.zconlist = [self.zconsole,PX,PY,VIEW_WIDTH,VIEW_HEIGHT,(SCREEN_WIDTH - VIEW_WIDTH) - 2,2,1.0,zmod]
            WeatherLayer.append(self.zconlist)

    # PC Movement

    #def viewTile(self,x,y,

    def handlePC(self):
        global PX, PY, PCX, PCY, OPCX, OPCY, OPX, OPY, PCcol, ViewRad, Clouds, moveclouds
        if Clouds.initdone or not GameWorld.rswitch:
            if self.rinit:
                while self.wobstructed[self.curz].get('%s,%s' % (PCX,PCY)):
                    PCX,PCY = randrange(2,RMAP_WIDTH - 2),randrange(2,RMAP_HEIGHT - 2)
                OPCX = PCX
                OPCY = PCY
                adjustScreen()
                moveclouds = True
                self.updateStatus()
                self.addMesg('Finished.',col = libtcod.light_orange)
                self.ochar = [libtcod.console_get_char(self.window,PCX,PCY),libtcod.console_get_char_foreground(self.window,PCX,PCY)]
                Clouds.ofcolordict['%s,%s' % (PCX,PCY)] = libtcod.console_get_char_foreground(wrwindow,PCX,PCY)
                self.docopses = {}
                self.handlePCchar()
                self.handlePCview()
                self.rinit = False
            if self.winit:
                OPCX = PCX
                OPCY = PCY
                self.ochar = [libtcod.console_get_char(self.window,PCX,PCY),libtcod.console_get_char_foreground(self.window,PCX,PCY)]
                Clouds.ofcolordict['%s,%s' % (PCX,PCY)] = libtcod.console_get_char_foreground(wpwindow,PCX,PCY)
                self.handlePCchar()
                self.winit = False           
            if (OPCX,OPCY) != (PCX,PCY):
                if self.rswitch:
                    wobstructed = self.wobstructed[self.curz]
                else:
                    wobstructed = self.ffobdict
                if wobstructed.get('%s,%s' % (PCX,PCY)):
                    obstruction = wobstructed['%s,%s' % (PCX,PCY)]
                    if obstruction == 'water':
                        self.addMesg('You don\'t know how to swim.',col = libtcod.yellow)
                    elif obstruction == 'mountain':
                        self.addMesg('You don\'t have the skills to climb that high.',col = libtcod.yellow)
                    elif obstruction == 'cactus':
                        self.addMesg('You stop to avoid running into the cactus.',col = libtcod.yellow)
                    else:
                        if obstruction == 'copse':
                            obstruction = 'tree'
                        self.addMesg('You bump into the %s.' % obstruction,col = libtcod.yellow)
                    PCX,PCY = OPCX,OPCY
                    PX,PY = OPX,OPY
                else:
                    self.handlePCchar()            
                if self.rswitch:
                    self.handlePCview()
                            
            OPCX = PCX
            OPCY = PCY
            OPX = PX
            OPY = PY

    def handlePCchar(self):
        global Clouds, PCX, PCY, PX, PY, OPCX, OPCY, PCcol, WeatherLayer, lock, PCRlayer, PCWlayer
        libtcod.console_clear(PCRlayer)
        libtcod.console_clear(PCWlayer)
        lock.acquire()
        if self.rswitch:
            shadperc = max(self.shadowdict['%s,%s' % (PCX,PCY)][0],self.shadowdict['%s,%s' % (PCX,PCY)][1])
            try:
                self.translayer[self.curz]['%s,%s' % (PCX,PCY)]
                col = libtcod.color_lerp(PCcol, libtcod.black, 0.4)
                if self.rswitch:
                    libtcod.console_set_char_foreground(PCRlayer, PCX, PCY, col)
                else:
                    libtcod.console_set_char_foreground(PCWlayer, PCX, PCY, col)
            except KeyError:
                pass
            if shadperc > 0.0:
                nPCcol = libtcod.color_lerp(PCcol,libtcod.black,shadperc)
            else:
                nPCcol = PCcol
        else:
            nPCcol = PCcol
        if self.rswitch:
            libtcod.console_set_default_foreground(PCRlayer, nPCcol)
            libtcod.console_print_ex(PCRlayer, PCX, PCY, libtcod.BKGND_NONE, libtcod.LEFT, '@')
        else:
            libtcod.console_set_default_foreground(PCWlayer, nPCcol)
            libtcod.console_print_ex(PCWlayer, PCX, PCY, libtcod.BKGND_NONE, libtcod.LEFT, '@')
        lock.release()
            
    def handlePCview(self):
        global Clouds, PCX, PCY, PCcol, ViewRad, LockName
        lock.acquire()
        donotdraw = {}
        for num in range(-(ViewRad + 2),ViewRad + 2):
            for num2 in range(-(ViewRad + 2),ViewRad + 2):
                try:
                    donotdraw['%s,%s' % (PCX + num,PCY + num2)]
                    continue
                except KeyError:
                    pass
                LockName = 'HandleView'
                if self.rswitch:
                    limitx,limity = RMAP_WIDTH,RMAP_HEIGHT
                else:
                    limitx,limity = MAP_WIDTH,MAP_HEIGHT
                if PCX + num < limitx and PCX + num > 0 and PCY + num2 < limity and PCY + num2 > 0:
                    pass
                else:
                    continue
                a = pow(num, 2)
                b = pow(num2, 2)
                d = sqrt(a + b)
                for area in self.flood[self.curz]:
                    if self.flood[self.curz][area].get('%s,%s' % (PCX,PCY)):
                        curarea = area
                if d < ViewRad:
                    copsecheck = False
                    treecheck = False
                    try:
                        leaflist = self.treedict['%s,%s' % (PCX + num,PCY + num2)][1:]
                        treecheck = True
                    except KeyError:
                        pass
                    try:
                        copsecenter = self.copsedict['%s,%s' % (PCX + num,PCY + num2)][0]
                        try:
                            if self.docopses['%s,%s' % (copsecenter[0],copsecenter[1])][0] == 'out' or self.docopses['%s,%s' % (copsecenter[0],copsecenter[1])] == ['done','out']:
                                self.docopses['%s,%s' % (copsecenter[0],copsecenter[1])] = ['in-%s,%s' % (PCX,PCY),self.docopses['%s,%s' % (copsecenter[0],copsecenter[1])][1]]
                        except KeyError:
                            self.docopses['%s,%s' % (copsecenter[0],copsecenter[1])] = ['in-%s,%s' % (PCX,PCY),'out']
                        treecheck = False
                        copsecheck = True
                    except KeyError:
                        pass
                    if treecheck and not self.groundview:
                        for leaf in leaflist:
                            lx = leaf[0]
                            ly = leaf[1]
                            donotdraw['%s,%s' % (lx,ly)] = True
                            bgcol = self.rterraindict['%s,%s' % (lx,ly)]
                            try:
                                fcol = self.shdict['%s,%s' % (lx,ly)][0]
                                char = self.shdict['%s,%s' % (lx,ly)][1]
                            except KeyError:
                                try:
                                    char = self.rtextdict['%s,%s' % (lx,ly)][0]
                                    fcol = self.rtextdict['%s,%s' % (lx,ly)][1]
                                except KeyError:
                                    pass
                            if self.treedict.get('%s,%s' % (lx,ly)):
                                char = self.treedict['%s,%s' % (lx,ly)][0][4]
                            elif self.treedict.get('%s,%s' % (lx + 1,ly)):
                                if 'w' in self.treedict['%s,%s' % (lx + 1,ly)][0][6]:
                                    if self.tallgrassdict.get('%s,%s' % (lx,ly)):
                                        char = rootcharwtg
                                    elif self.dirtdict.get('%s,%s' % (lx,ly)):
                                        char = rootcharwd
                                    elif self.leafgrounddict.get('%s,%s' % (lx,ly)):
                                        char = rootcharwl
                                    else:
                                        char = rootcharwg
                            elif self.treedict.get('%s,%s' % (lx - 1,ly)):
                                if 'e' in self.treedict['%s,%s' % (lx - 1,ly)][0][6]:
                                    if self.tallgrassdict.get('%s,%s' % (lx,ly)):
                                        char = rootcharetg
                                    elif self.dirtdict.get('%s,%s' % (lx,ly)):
                                        char = rootchared
                                    elif self.leafgrounddict.get('%s,%s' % (lx,ly)):
                                        char = rootcharel
                                    else:
                                        char = rootchareg
                            elif self.treedict.get('%s,%s' % (lx,ly + 1)):
                                if 'n' in self.treedict['%s,%s' % (lx,ly + 1)][0][6]:
                                    if self.tallgrassdict.get('%s,%s' % (lx,ly)):
                                        char = rootcharntg
                                    elif self.dirtdict.get('%s,%s' % (lx,ly)):
                                        char = rootcharnd
                                    elif self.leafgrounddict.get('%s,%s' % (lx,ly)):
                                        char = rootcharnl
                                    else:
                                        char = rootcharng
                            elif self.treedict.get('%s,%s' % (lx,ly - 1)):
                                if 's' in self.treedict['%s,%s' % (lx,ly - 1)][0][6]:
                                    if self.tallgrassdict.get('%s,%s' % (lx,ly)):
                                        char = rootcharstg
                                    elif self.dirtdict.get('%s,%s' % (lx,ly)):
                                        char = rootcharsd
                                    elif self.leafgrounddict.get('%s,%s' % (lx,ly)):
                                        char = rootcharsl
                                    else:
                                        char = rootcharsg
                            elif self.zgrid[self.curz].get('%s,%s' % (lx,ly)):
                                tile = self.zgrid[self.curz]['%s,%s' % (lx,ly)]
                                buildtype = tile[0]
                                char = tile[2]
                                char[2] = 255
                                fcol = tile[3]
                                nbgcol = tile[4]
                                if nbgcol:
                                    bcol = nbgcol
                                if buildtype == 'door':
                                    if tile[5] == 'open':
                                        try:
                                            ftile = tile[6]
                                            char = ftile[2]
                                            fcol = ftile[3]
                                            nbgcol = ftile[4]
                                            if nbgcol:
                                                bcol = nbgcol
                                            char[2] = 255
                                        except IndexError:
                                            char = [0,0,255]
                            if self.itemdict[self.curz].get('%s,%s' % (lx,ly)):
                                shadperc = max(self.shadowdict['%s,%s' % (lx,ly)][0],self.shadowdict['%s,%s' % (lx,ly)][1])
                                items = self.itemdict[self.curz]['%s,%s' % (lx,ly)].values()
                                items.sort(key=lambda value: value[1],reverse = True)
                                item = items[0][0]
                                itemname = item[0]
                                itemstruct = self.invdict[item[1]][itemname]
                                fcol = libtcod.color_lerp(libtcod.white,libtcod.black,shadperc)
                                char = [int(itemstruct['CHAR'][0]),int(itemstruct['CHAR'][1]),255]
                            try:
                                if not type(self.rheightmap['%s,%s' % (lx,ly)]) == str:
                                    tfcol = self.translayer[self.curz]['%s,%s' % (lx,ly)][1]
                                    tbcol = self.translayer[self.curz]['%s,%s' % (lx,ly)][0]
                                    shadperc = max(self.shadowdict['%s,%s' % (lx,ly)][0],self.shadowdict['%s,%s' % (lx,ly)][1])
                                    fcol = libtcod.color_lerp(tfcol, libtcod.black, shadperc)
                                    bcol = libtcod.color_lerp(tbcol, libtcod.black, shadperc)
                            except KeyError:
                                pass
                            if type(self.rheightmap['%s,%s' % (lx,ly)]) == str:
                                try:
                                    fcol = Clouds.nfcolordict['%s,%s' % (lx,ly)]
                                    bcol = Clouds.ncolordict['%s,%s' % (lx,ly)]
                                except KeyError:
                                    fcol = Clouds.ofcolordict['%s,%s' % (lx,ly)]
                                    bcol = Clouds.ocolordict['%s,%s' % (lx,ly)]
                                shadperc = min(self.shadowdict['%s,%s' % (lx,ly)][1],0.9)
                                fcol = libtcod.color_lerp(fcol,libtcod.white,shadperc)
                                bcol = libtcod.color_lerp(bcol,libtcod.white,shadperc)
                            libtcod.console_set_default_foreground(self.window, fcol)
                            libtcod.console_set_default_background(self.window, bcol)
                            libtcod.console_print_ex(self.window, lx, ly, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))                        
                    elif self.translayer[self.curz].get('%s,%s' % (PCX + num,PCY + num2)) and not self.groundview:
                        if (not (self.wobstructed[self.curz].get('%s,%s' % (PCX + num,PCY + num2)) == 'water' and \
                           self.tempzone == 'Arctic') and not self.ldict.get('%s,%s' % (PCX + num,PCY + num2))) or copsecheck:
                            if not type(self.rheightmap['%s,%s' % (PCX + num,PCY + num2)]) == str:
                                Clouds.vrskip['%s,%s' % (PCX + num,PCY + num2)] = True
                            dperc = (d * 1.0) / (ViewRad * 1.0)
                            if dperc < .4:
                                dperc = 0.0
                            if (num,num2) == (0,0):
                                continue
                            else:
                                bgcol = self.rterraindict['%s,%s' % (PCX + num,PCY + num2)]
                                try:
                                    fcol = self.shdict['%s,%s' % (PCX + num,PCY + num2)][0]
                                    char = self.shdict['%s,%s' % (PCX + num,PCY + num2)][1]
                                except KeyError:
                                    try:
                                        char = self.rtextdict['%s,%s' % (PCX + num,PCY + num2)][0]
                                        fcol = self.rtextdict['%s,%s' % (PCX + num,PCY + num2)][1]
                                    except KeyError:
                                        pass
                                if self.treedict.get('%s,%s' % (PCX + num,PCY + num2)):
                                    dperc = 0.0
                                    fcol = libtcod.white
                                    char = self.treedict['%s,%s' % (PCX + num,PCY + num2)][0][4]
                                elif self.treedict.get('%s,%s' % (PCX + num + 1,PCY + num2)):
                                    if 'w' in self.treedict['%s,%s' % (PCX + num + 1,PCY + num2)][0][6]:
                                        if self.tallgrassdict.get('%s,%s' % (PCX + num,PCY + num2)):
                                            char = rootcharwtg
                                        elif self.dirtdict.get('%s,%s' % (PCX + num,PCY + num2)):
                                            char = rootcharwd
                                        elif self.leafgrounddict.get('%s,%s' % (PCX + num,PCY + num2)):
                                            char = rootcharwl
                                        else:
                                            char = rootcharwg
                                elif self.treedict.get('%s,%s' % (PCX + num - 1,PCY + num2)):
                                    if 'e' in self.treedict['%s,%s' % (PCX + num - 1,PCY + num2)][0][6]:
                                        if self.tallgrassdict.get('%s,%s' % (PCX + num,PCY + num2)):
                                            char = rootcharetg
                                        elif self.dirtdict.get('%s,%s' % (PCX + num,PCY + num2)):
                                            char = rootchared
                                        elif self.leafgrounddict.get('%s,%s' % (PCX + num,PCY + num2)):
                                            char = rootcharel
                                        else:
                                            char = rootchareg
                                elif self.treedict.get('%s,%s' % (PCX + num,PCY + num2 + 1)):
                                    if 'n' in self.treedict['%s,%s' % (PCX + num,PCY + num2 + 1)][0][6]:
                                        if self.tallgrassdict.get('%s,%s' % (PCX + num,PCY + num2)):
                                            char = rootcharntg
                                        elif self.dirtdict.get('%s,%s' % (PCX + num,PCY + num2)):
                                            char = rootcharnd
                                        elif self.leafgrounddict.get('%s,%s' % (PCX + num,PCY + num2)):
                                            char = rootcharnl
                                        else:
                                            char = rootcharng
                                elif self.treedict.get('%s,%s' % (PCX + num,PCY + num2 - 1)):
                                    if 's' in self.treedict['%s,%s' % (PCX + num,PCY + num2 - 1)][0][6]:
                                        if self.tallgrassdict.get('%s,%s' % (PCX + num,PCY + num2)):
                                            char = rootcharstg
                                        elif self.dirtdict.get('%s,%s' % (PCX + num,PCY + num2)):
                                            char = rootcharsd
                                        elif self.leafgrounddict.get('%s,%s' % (PCX + num,PCY + num2)):
                                            char = rootcharsl
                                        else:
                                            char = rootcharsg
                                elif self.zgrid[self.curz].get('%s,%s' % (PCX + num,PCY + num2)):
                                    tile = self.zgrid[self.curz]['%s,%s' % (PCX + num,PCY + num2)]
                                    buildtype = tile[0]
                                    char = tile[2]
                                    char[2] = 255
                                    fcol = tile[3]
                                    nbgcol = tile[4]
                                    if nbgcol:
                                        bgcol = nbgcol
                                    if buildtype == 'door':
                                        if tile[5] == 'open':
                                            try:
                                                ftile = tile[6]
                                                char = ftile[2]
                                                fcol = ftile[3]
                                                nbgcol = ftile[4]
                                                if nbgcol:
                                                    bgcol = nbgcol
                                                char[2] = 255
                                            except IndexError:
                                                char = [0,0,255]
##                                    shadperc = max(self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][0],self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][1])
                                    #fcol = libtcod.color_lerp(fcol, libtcod.black, shadperc)
                                    #bcol = libtcod.color_lerp(bgcol, libtcod.black, shadperc)
                                if self.itemdict[self.curz].get('%s,%s' % (PCX + num,PCY + num2)):
                                    shadperc = max(self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][0],self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][1])
                                    items = self.itemdict[self.curz]['%s,%s' % (PCX + num,PCY + num2)].values()
                                    items.sort(key=lambda value: value[1],reverse = True)
                                    item = items[0][0]
                                    itemname = item[0]
                                    itemstruct = self.invdict[item[1]][itemname]
                                    fcol = libtcod.color_lerp(libtcod.white,libtcod.black,shadperc)
                                    char = [int(itemstruct['CHAR'][0]),int(itemstruct['CHAR'][1]),255]
                                try:
                                    if not type(self.rheightmap['%s,%s' % (PCX + num,PCY + num2)]) == str:
                                        tfcol = self.translayer[self.curz]['%s,%s' % (PCX + num,PCY + num2)][1]
                                        tbcol = self.translayer[self.curz]['%s,%s' % (PCX + num,PCY + num2)][0]
                                        nfcol = libtcod.color_lerp(fcol, tfcol, dperc)
                                        nbcol = libtcod.color_lerp(bgcol, tbcol, dperc)
                                        shadperc = max(self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][0],self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][1])
                                        fcol = fcol
                                        bcol = bgcol
                                except KeyError:
                                    pass
                                if type(self.rheightmap['%s,%s' % (PCX + num,PCY + num2)]) == str:
                                    try:
                                        fcol = Clouds.nfcolordict['%s,%s' % (PCX + num,PCY + num2)]
                                        bcol = Clouds.ncolordict['%s,%s' % (PCX + num,PCY + num2)]
                                    except KeyError:
                                        fcol = Clouds.ofcolordict['%s,%s' % (PCX + num,PCY + num2)]
                                        bcol = Clouds.ocolordict['%s,%s' % (PCX + num,PCY + num2)]
                                    shadperc = min(self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][1],0.9)
                                    fcol = libtcod.color_lerp(fcol,libtcod.white,shadperc)
                                    bcol = libtcod.color_lerp(bcol,libtcod.white,shadperc)
                                libtcod.console_set_default_foreground(self.window, fcol)
                                libtcod.console_set_default_background(self.window, bcol)
                                libtcod.console_print_ex(self.window, PCX + num, PCY + num2, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                    elif self.curz < 99 and not self.ldict.get('%s,%s' % (PCX + num,PCY + num2)):
                        ztop = self.ztop.get('%s,%s' % (PCX + num,PCY + num2))
                        if ztop > self.curz:
                            objarea = None
                            for area in self.flood[self.curz]:
                                if self.flood[self.curz][area].get('%s,%s' % (PCX + num,PCY + num2)):
                                    objarea = area
                            linked = False
                            if objarea in self.rtree[self.curz][curarea]:
                                linked = True
                            isarea = False
                            if objarea == curarea:
                                isarea = True
                            if self.zgrid[self.curz].get('%s,%s' % (PCX + num,PCY + num2)) and not (linked or isarea):
                                try:
                                    tile = self.zgrid[self.curz]['%s,%s' % (PCX + num,PCY + num2)]
                                    buildtype = tile[0]
                                except KeyError:
                                    continue
                                Clouds.bskip['%s,%s' % (PCX + num,PCY + num2)] = True
                                outtile = False
                                if buildtype in ['wall','window','door']:
                                    for cnum in range(-1,2):
                                        if outtile:
                                            break
                                        for cnum2 in range(-1,2):
                                            if [cnum,cnum2] == [0,0]:
                                                continue
                                            if self.flood[self.curz][curarea].get('%s,%s' % (PCX + num + cnum,PCY + num2 + cnum2)):
                                                outtile = True
                                                break
                                            for area in self.rtree[self.curz][curarea]:
                                                if self.flood[self.curz][area].get('%s,%s' % (PCX + num + cnum,PCY + num2 + cnum2)):
                                                    outtile = True
                                                    break
                                            try:
                                                cztop = self.ztop['%s,%s' % (PCX + num + cnum,PCY + num2 + cnum2)]
                                            except KeyError:
                                                cztop = self.curz
                                            if not cztop > self.curz:
                                                outtile = True
                                                break
                                if objarea:
                                    if objarea != curarea and not (self.linkedareas[self.curz][objarea].get(curarea) or self.linkedareas[self.curz][curarea].get(objarea)):
                                        libtcod.console_set_default_background(wrwindow, libtcod.black)
                                        libtcod.console_print_ex(wrwindow, PCX + num, PCY + num2, libtcod.BKGND_SET, libtcod.LEFT,chr(DoChar([0,0,255])))
                                else:
                                    tile = self.zgrid[self.curz]['%s,%s' % (PCX + num,PCY + num2)]
                                    buildtype = tile[0]
                                    fg = tile[3]
                                    bg = tile[4]
                                    char = tile[2]
                                    char[2] = 255
                                    libtcod.console_set_default_foreground(wrwindow, fg)
                                    if buildtype == 'door':
                                        if tile[5] == 'open':
                                            try:
                                                ftile = tile[6]
                                                char = ftile[2]
                                                fg = ftile[3]
                                                bg = ftile[4]
                                                char[2] = 255
                                                libtcod.console_set_default_foreground(wrwindow, fg)
                                                libtcod.console_set_default_background(wrwindow, bg)
                                            except IndexError:
                                                char = [0,0,255]
                                    if outtile:
                                        if bg:
                                            libtcod.console_set_default_background(wrwindow, bg)
                                            libtcod.console_print_ex(wrwindow, PCX + num, PCY + num2, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                                        else:
                                            libtcod.console_print_ex(wrwindow, PCX + num, PCY + num2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                                    else:
                                        libtcod.console_set_default_background(wrwindow, libtcod.black)
                                        libtcod.console_print_ex(wrwindow, PCX + num, PCY + num2, libtcod.BKGND_SET, libtcod.LEFT, ' ')
                            elif self.zgrid[self.curz].get('%s,%s' % (PCX + num,PCY + num2)) and (linked or isarea):
                                Clouds.bskip['%s,%s' % (PCX + num,PCY + num2)] = True
                                try:
                                    tile = self.zgrid[self.curz]['%s,%s' % (PCX + num,PCY + num2)]
                                    buildtype = tile[0]
                                    fg = tile[3]
                                    bg = tile[4]
                                    char = tile[2]
                                    char[2] = 255
                                    if buildtype == 'door':
                                        if tile[5] == 'open':
                                            try:
                                                ftile = tile[6]
                                                char = ftile[2]
                                                fg = ftile[3]
                                                bg = ftile[4]
                                                char[2] = 255
                                                libtcod.console_set_default_foreground(wrwindow, fg)
                                                libtcod.console_set_default_background(wrwindow, bg)
                                            except IndexError:
                                                char = [0,0,255]
                                    libtcod.console_set_default_foreground(wrwindow, fg)
                                    if [PCX + num,PCY + num2] != [PCX,PCY]:
                                        if bg:
                                            libtcod.console_set_default_background(wrwindow, bg)
                                            libtcod.console_print_ex(wrwindow, PCX + num, PCY + num2, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                                        else:
                                            libtcod.console_print_ex(wrwindow, PCX + num, PCY + num2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                                    elif bg:
                                        libtcod.console_set_char_background(wrwindow, PCX + num, PCY + num2, bg, libtcod.BKGND_SET)
                                except KeyError:
                                    pass
                            elif not self.zgrid[self.curz].get('%s,%s' % (PCX + num,PCY + num2)) and not (isarea or linked):
                                if not self.wobstructed.get('%s,%s' % (PCX + num,PCY + num2)) == 'water' and not \
                                   self.tempzone == 'Arctic':
                                    Clouds.bskip['%s,%s' % (PCX + num,PCY + num2)] = True
                                    libtcod.console_set_default_background(wrwindow, libtcod.black)
                            elif not self.zgrid[self.curz].get('%s,%s' % (PCX + num,PCY + num2)) and linked:
                                bgcol = self.rterraindict['%s,%s' % (PCX + num,PCY + num2)]
                                try:
                                    fcol = self.shdict['%s,%s' % (PCX + num,PCY + num2)][0]
                                    char = self.shdict['%s,%s' % (PCX + num,PCY + num2)][1]
                                except KeyError:
                                    char = self.rtextdict['%s,%s' % (PCX + num,PCY + num2)][0]
                                    fcol = self.rtextdict['%s,%s' % (PCX + num,PCY + num2)][1]
                                if self.treedict.get('%s,%s' % (PCX + num,PCY + num2)):
                                    fcol = libtcod.white
                                    char = self.treedict['%s,%s' % (PCX + num,PCY + num2)][0][4]
                                elif self.itemdict[self.curz].get('%s,%s' % (PCX + num,PCY + num2)):
                                    items = self.itemdict[self.curz]['%s,%s' % (PCX + num,PCY + num2)].values()
                                    items.sort(key=lambda value: value[1],reverse = True)
                                    item = items[0][0]
                                    itemname = item[0]
                                    itemstruct = self.invdict[item[1]][itemname]
                                    fcol = libtcod.white
                                    char = [int(itemstruct['CHAR'][0]),int(itemstruct['CHAR'][1]),255]
                                libtcod.console_set_default_foreground(wrwindow, fcol)
                                libtcod.console_set_default_background(wrwindow, bgcol)
                                libtcod.console_print_ex(self.window, PCX + num, PCY + num2, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                        elif self.zgrid[self.curz].get('%s,%s' % (PCX + num,PCY + num2)):
                            if [num,num2] == [0,0]:
                                continue
                            try:
                                Clouds.bskip.pop('%s,%s' % (PCX + num,PCY + num2))
                            except KeyError:
                                pass
                            tile = self.zgrid[self.curz]['%s,%s' % (PCX + num,PCY + num2)]
                            buildtype = tile[0]
                            fg = tile[3]
                            bg = tile[4]
                            char = tile[2]
                            char[2] = 255
                            if buildtype == 'door':
                                if tile[5] == 'open':
                                    try:
                                        ftile = tile[6]
                                        char = ftile[2]
                                        fg = ftile[3]
                                        bg = ftile[4]
                                        char[2] = 255
                                    except IndexError:
                                        char = [0,0,255]                       
                            if self.itemdict[self.curz].get('%s,%s' % (PCX + num,PCY + num2)):
                                items = self.itemdict[self.curz]['%s,%s' % (PCX + num,PCY + num2)].values()
                                items.sort(key=lambda value: value[1],reverse = True)
                                item = items[0][0]
                                itemname = item[0]
                                itemstruct = self.invdict[item[1]][itemname]
                                fg = libtcod.white
                                char = [int(itemstruct['CHAR'][0]),int(itemstruct['CHAR'][1]),255]
                            if self.curz == self.ztop.get('%s,%s' % (PCX + num,PCY + num2)):
                                sperc = max(self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][0],self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][1])
                                fg = libtcod.color_lerp(fg, libtcod.black, sperc)
                                if bg:
                                    bg = libtcod.color_lerp(bg, libtcod.black, sperc)
                            libtcod.console_set_default_foreground(wrwindow, fg)
                            if bg:
                                libtcod.console_set_default_background(wrwindow, bg)
                                libtcod.console_print_ex(wrwindow, PCX + num, PCY + num2, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                            else:
                                libtcod.console_print_ex(wrwindow, PCX + num, PCY + num2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                        else:
                            if not self.wobstructed[self.curz].get('%s,%s' % (PCX + num,PCY + num2)) == 'water':
                                shadperc = max(self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][0],self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][1])
                                try:
                                    char = self.rtextdict['%s,%s' % (PCX + num,PCY + num2)][0]
                                    bgcol = self.rterraindict['%s,%s' % (PCX + num,PCY + num2)]
                                    fcol = self.rtextdict['%s,%s' % (PCX + num,PCY + num2)][1]
                                except KeyError:
                                    pass
                                try:
                                    fcol = self.shdict['%s,%s' % (PCX + num,PCY + num2)][0]
                                    char = self.shdict['%s,%s' % (PCX + num,PCY + num2)][1]
                                    bgcol = self.rterraindict['%s,%s' % (PCX + num,PCY + num2)]
                                except KeyError:
                                    pass
                                if self.itemdict[self.curz].get('%s,%s' % (PCX + num,PCY + num2)):
                                    items = self.itemdict[self.curz]['%s,%s' % (PCX + num,PCY + num2)].values()
                                    items.sort(key=lambda value: value[1],reverse = True)
                                    item = items[0][0]
                                    itemname = item[0]
                                    itemstruct = self.invdict[item[1]][itemname]
                                    fcol = libtcod.white
                                    char = [int(itemstruct['CHAR'][0]),int(itemstruct['CHAR'][1]),255]
                                if self.treedict.get('%s,%s' % (PCX + num,PCY + num2)):
                                    dperc = 0.0
                                    fcol = libtcod.white
                                    char = self.treedict['%s,%s' % (PCX + num,PCY + num2)][0][4]
                                try:
                                    fcol = Clouds.nfcolordict['%s,%s' % (PCX + num,PCY + num2)]
                                    bgcol = Clouds.ncolordict['%s,%s' % (PCX + num,PCY + num2)]
                                except KeyError:
                                    fcol = Clouds.ofcolordict['%s,%s' % (PCX + num,PCY + num2)]
                                    bgcol = Clouds.ocolordict['%s,%s' % (PCX + num,PCY + num2)]
                                fcol = libtcod.color_lerp(fcol,libtcod.black,shadperc)
                                bgcol = libtcod.color_lerp(bgcol,libtcod.black,shadperc)
                                libtcod.console_set_default_foreground(self.window, fcol)
                                libtcod.console_set_default_background(self.window, bgcol)
                                libtcod.console_print_ex(self.window, PCX + num, PCY + num2, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                else:
                    if not self.groundview:
                        treecheck = False
                        try:
                            self.treedict['%s,%s' % (PCX + num,PCY + num2)]
                            leaflist = self.treedict['%s,%s' % (PCX + num,PCY + num2)][1:]
                            treecheck = True
                        except KeyError:
                            pass
                        try:
                            copsecenter = self.copsedict['%s,%s' % (PCX + num,PCY + num2)][0]
                            try:
                                if self.docopses['%s,%s' % (copsecenter[0],copsecenter[1])][0] != 'in-%s,%s' % (PCX,PCY):
                                    self.docopses['%s,%s' % (copsecenter[0],copsecenter[1])] = ['out',self.docopses['%s,%s' % (copsecenter[0],copsecenter[1])][1]]
                            except KeyError:
                                self.docopses['%s,%s' % (copsecenter[0],copsecenter[1])] = ['done','out']
                            treecheck = False
                        except KeyError:
                            pass
                        if treecheck:
                            for leaf in leaflist:
                                lx = leaf[0]
                                ly = leaf[1]
                                shadperc = max(self.shadowdict['%s,%s' % (lx,ly)][0],self.shadowdict['%s,%s' % (lx,ly)][1])
                                try:
                                    char = self.rtextdict['%s,%s' % (lx,ly)][0]
                                    bgcol = self.rterraindict['%s,%s' % (lx,ly)]
                                    fcol = self.rtextdict['%s,%s' % (lx,ly)][1]
                                except KeyError:
                                    pass
                                try:
                                    Clouds.vrskip.pop('%s,%s' % (lx,ly))
                                except KeyError:
                                    pass
                                try:
                                    fcol = self.shdict['%s,%s' % (lx,ly)][0]
                                    char = self.shdict['%s,%s' % (lx,ly)][1]
                                    bgcol = self.rterraindict['%s,%s' % (lx,ly)]
                                except KeyError:
                                    pass
                                try:
                                    bgcol = self.translayer[self.curz]['%s,%s' % (lx,ly)][0]
                                    fcol = self.translayer[self.curz]['%s,%s' % (lx,ly)][1]
                                    char = self.translayer[self.curz]['%s,%s' % (lx,ly)][2]
                                except KeyError:
                                    pass
                                try:
                                    fcol = Clouds.nfcolordict['%s,%s' % (lx,ly)]
                                    bgcol = Clouds.ncolordict['%s,%s' % (lx,ly)]
                                except KeyError:
                                    fcol = Clouds.ofcolordict['%s,%s' % (lx,ly)]
                                    bgcol = Clouds.ocolordict['%s,%s' % (lx,ly)]
                                if type(self.rheightmap['%s,%s' % (lx,ly)]) == str:
                                    try:
                                        fcol = Clouds.nfcolordict['%s,%s' % (lx,ly)]
                                        bcol = Clouds.ncolordict['%s,%s' % (lx,ly)]
                                    except KeyError:
                                        fcol = Clouds.ofcolordict['%s,%s' % (lx,ly)]
                                        bcol = Clouds.ocolordict['%s,%s' % (lx,ly)]
                                    shadperc = min(self.shadowdict['%s,%s' % (lx,ly)][1],0.9)
                                    fcol = libtcod.color_lerp(fcol,libtcod.white,shadperc)
                                    bgcol = libtcod.color_lerp(bcol,libtcod.white,shadperc)
                                else:
                                    fcol = libtcod.color_lerp(fcol,libtcod.black,shadperc)
                                    bgcol = libtcod.color_lerp(bgcol,libtcod.black,shadperc)
                                libtcod.console_set_default_foreground(self.window, fcol)
                                libtcod.console_set_default_background(self.window, bgcol)
                                libtcod.console_print_ex(self.window, lx, ly, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                                try:
                                    try:
                                        ztop = self.ztop['%s,%s' % (lx,ly)]
                                    except KeyError:
                                        ztop = self.curz
                                    if ztop > self.curz:
                                        try:
                                            Clouds.bskip.pop('%s,%s' % (lx,ly))
                                            tile = self.zgrid[ztop]['%s,%s' % (lx,ly)]
                                            buildtype = tile[0]
                                            char = tile[2]
                                            char[2] = 255
                                            fg = tile[3]
                                            bg = tile[4]
                                            if buildtype == 'door':
                                                if tile[5] == 'open':
                                                    try:
                                                        ftile = tile[6]
                                                        char = ftile[2]
                                                        fg = ftile[3]
                                                        bg = ftile[4]
                                                        char[2] = 255
                                                    except IndexError:
                                                        char = [0,0,255]
                                            if self.curz == self.ztop.get('%s,%s' % (PCX + num,PCY + num2)):
                                                sperc = max(self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][0],self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][1])
                                                fg = libtcod.color_lerp(fg, libtcod.black, sperc)
                                                if bg:
                                                    bg = libtcod.color_lerp(bg, libtcod.black, sperc)
                                            libtcod.console_set_default_foreground(wrwindow, fg)
                                            if bg:
                                                libtcod.console_set_default_background(wrwindow, bg)
                                                libtcod.console_print_ex(wrwindow, lx, ly, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                                            else:
                                                libtcod.console_print_ex(wrwindow, lx, ly, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                                        except KeyError:
                                            pass
                                except KeyError:
                                    pass
                                donotdraw['%s,%s' % (lx,ly)] = True
                        elif not self.ldict.get('%s,%s' % (PCX + num,PCY + num2)):
                            shadperc = max(self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][0],self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][1])
                            try:
                                char = self.rtextdict['%s,%s' % (PCX + num,PCY + num2)][0]
                                bgcol = self.rterraindict['%s,%s' % (PCX + num,PCY + num2)]
                                fcol = self.rtextdict['%s,%s' % (PCX + num,PCY + num2)][1]
                            except KeyError:
                                pass
                            try:
                                Clouds.vrskip.pop('%s,%s' % (PCX + num,PCY + num2))
                            except KeyError:
                                pass
                            try:
                                fcol = self.shdict['%s,%s' % (PCX + num,PCY + num2)][0]
                                char = self.shdict['%s,%s' % (PCX + num,PCY + num2)][1]
                                bgcol = self.rterraindict['%s,%s' % (PCX + num,PCY + num2)]
                            except KeyError:
                                pass
                            try:
                                bgcol = self.translayer[self.curz]['%s,%s' % (PCX + num,PCY + num2)][0]
                                fcol = self.translayer[self.curz]['%s,%s' % (PCX + num,PCY + num2)][1]
                                char = self.translayer[self.curz]['%s,%s' % (PCX + num,PCY + num2)][2]
                            except KeyError:
                                pass
                            if self.itemdict[self.curz].get('%s,%s' % (PCX + num,PCY + num2)):
                                items = self.itemdict[self.curz]['%s,%s' % (PCX + num,PCY + num2)].values()
                                items.sort(key=lambda value: value[1],reverse = True)
                                item = items[0][0]
                                itemname = item[0]
                                itemstruct = self.invdict[item[1]][itemname]
                                fcol = libtcod.white
                                char = [int(itemstruct['CHAR'][0]),int(itemstruct['CHAR'][1]),255]
                            try:
                                fcol = Clouds.nfcolordict['%s,%s' % (PCX + num,PCY + num2)]
                                bgcol = Clouds.ncolordict['%s,%s' % (PCX + num,PCY + num2)]
                            except KeyError:
                                fcol = Clouds.ofcolordict['%s,%s' % (PCX + num,PCY + num2)]
                                bgcol = Clouds.ocolordict['%s,%s' % (PCX + num,PCY + num2)]
                            if self.zgrid[self.curz].get('%s,%s' % (PCX + num,PCY + num2)):
                                ztop = self.ztop.get('%s,%s' % (PCX + num,PCY + num2))
                                tile = self.zgrid[ztop]['%s,%s' % (PCX + num,PCY + num2)]
                                buildtype = tile[0]
                                char = tile[2]
                                char[2] = 255
                                fcol = tile[3]
                                nbgcol = tile[4]
                                if nbgcol:
                                    bgcol = nbgcol
                                if buildtype == 'door':
                                    if tile[5] == 'open':
                                        try:
                                            ftile = tile[6]
                                            char = ftile[2]
                                            fcol = ftile[3]
                                            nbgcol = ftile[4]
                                            if nbgcol:
                                                bgcol = nbgcol
                                            char[2] = 255
                                        except IndexError:
                                            char = [0,0,255]
                            if type(self.rheightmap['%s,%s' % (PCX + num,PCY + num2)]) == str:
                                try:
                                    fcol = Clouds.nfcolordict['%s,%s' % (PCX + num,PCY + num2)]
                                    bcol = Clouds.ncolordict['%s,%s' % (PCX + num,PCY + num2)]
                                except KeyError:
                                    fcol = Clouds.ofcolordict['%s,%s' % (PCX + num,PCY + num2)]
                                    bcol = Clouds.ocolordict['%s,%s' % (PCX + num,PCY + num2)]
                                shadperc = min(self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][1],0.9)
                                fcol = libtcod.color_lerp(fcol,libtcod.white,shadperc)
                                bgcol = libtcod.color_lerp(bcol,libtcod.white,shadperc)
                            else:
                                fcol = libtcod.color_lerp(fcol,libtcod.black,shadperc)
                                bgcol = libtcod.color_lerp(bgcol,libtcod.black,shadperc)
                            libtcod.console_set_default_foreground(self.window, fcol)
                            libtcod.console_set_default_background(self.window, bgcol)
                            libtcod.console_print_ex(self.window, PCX + num, PCY + num2, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                            try:
                                try:
                                    ztop = self.ztop['%s,%s' % (PCX + num,PCY + num2)]
                                except KeyError:
                                    ztop = self.curz
                                if ztop > self.curz:
                                    try:
                                        Clouds.bskip.pop('%s,%s' % (PCX + num,PCY + num2))
                                        tile = self.zgrid[ztop]['%s,%s' % (PCX + num,PCY + num2)]
                                        buildtype = tile[0]
                                        char = tile[2]
                                        char[2] = 255
                                        fg = tile[3]
                                        bg = tile[4]
                                        if buildtype == 'door':
                                            if tile[5] == 'open':
                                                try:
                                                    ftile = tile[6]
                                                    char = ftile[2]
                                                    fg = ftile[3]
                                                    bg = ftile[4]
                                                    char[2] = 255
                                                except IndexError:
                                                    char = [0,0,255]
                                        sperc = max(self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][0],self.shadowdict['%s,%s' % (PCX + num,PCY + num2)][1])
                                        fg = libtcod.color_lerp(fg, libtcod.black, sperc)
                                        if bg:
                                            bg = libtcod.color_lerp(bg, libtcod.black, sperc)
                                        libtcod.console_set_default_foreground(wrwindow, fg)
                                        if bg:
                                            libtcod.console_set_default_background(wrwindow, bg)
                                            libtcod.console_print_ex(wrwindow, PCX + num, PCY + num2, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                                        else:
                                            libtcod.console_print_ex(wrwindow, PCX + num, PCY + num2, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                                    except KeyError:
                                        pass
                            except KeyError:
                                pass
                LockName = 'None'
        for key in self.docopses.keys():
            if self.groundview:
                continue
            cx = int(key.split(',')[0])
            cy = int(key.split(',')[1])
            leaflist = self.copsedict['%s,%s' % (cx,cy)][1]
            if self.docopses[key][0] == 'in-%s,%s' % (PCX,PCY) and self.docopses[key][1] == 'out':
                self.docopses[key] = ['done','in']
                for leaf in leaflist:
                    lx = leaf[0]
                    ly = leaf[1]
                    bgcol = self.rterraindict['%s,%s' % (lx,ly)]
                    try:
                        fcol = self.shdict['%s,%s' % (lx,ly)][0]
                        char = self.shdict['%s,%s' % (lx,ly)][1]
                    except KeyError:
                        try:
                            char = self.rtextdict['%s,%s' % (lx,ly)][0]
                            fcol = self.rtextdict['%s,%s' % (lx,ly)][1]
                        except KeyError:
                            pass
                    if self.treedict.get('%s,%s' % (lx,ly)):
                        char = self.treedict['%s,%s' % (lx,ly)][0][4]
                    elif self.treedict.get('%s,%s' % (lx + 1,ly)):
                        if 'w' in self.treedict['%s,%s' % (lx + 1,ly)][0][6]:
                            if self.tallgrassdict.get('%s,%s' % (lx,ly)):
                                char = rootcharwtg
                            elif self.dirtdict.get('%s,%s' % (lx,ly)):
                                char = rootcharwd
                            elif self.leafgrounddict.get('%s,%s' % (lx,ly)):
                                char = rootcharwl
                            else:
                                char = rootcharwg
                    elif self.treedict.get('%s,%s' % (lx - 1,ly)):
                        if 'e' in self.treedict['%s,%s' % (lx - 1,ly)][0][6]:
                            if self.tallgrassdict.get('%s,%s' % (lx,ly)):
                                char = rootcharetg
                            elif self.dirtdict.get('%s,%s' % (lx,ly)):
                                char = rootchared
                            elif self.leafgrounddict.get('%s,%s' % (lx,ly)):
                                char = rootcharel
                            else:
                                char = rootchareg
                    elif self.treedict.get('%s,%s' % (lx,ly + 1)):
                        if 'n' in self.treedict['%s,%s' % (lx,ly + 1)][0][6]:
                            if self.tallgrassdict.get('%s,%s' % (lx,ly)):
                                char = rootcharntg
                            elif self.dirtdict.get('%s,%s' % (lx,ly)):
                                char = rootcharnd
                            elif self.leafgrounddict.get('%s,%s' % (lx,ly)):
                                char = rootcharnl
                            else:
                                char = rootcharng
                    elif self.treedict.get('%s,%s' % (lx,ly - 1)):
                        if 's' in self.treedict['%s,%s' % (lx,ly - 1)][0][6]:
                            if self.tallgrassdict.get('%s,%s' % (lx,ly)):
                                char = rootcharstg
                            elif self.dirtdict.get('%s,%s' % (lx,ly)):
                                char = rootcharsd
                            elif self.leafgrounddict.get('%s,%s' % (lx,ly)):
                                char = rootcharsl
                            else:
                                char = rootcharsg
                    elif self.zgrid[self.curz].get('%s,%s' % (lx,ly)):
                        tile = self.zgrid[self.curz]['%s,%s' % (lx,ly)]
                        buildtype = tile[0]
                        char = tile[2]
                        char[2] = 255
                        fcol = tile[3]
                        nbgcol = tile[4]
                        if nbgcol:
                            bgcol = nbgcol
                        if buildtype == 'door':
                            if tile[5] == 'open':
                                try:
                                    ftile = tile[6]
                                    char = ftile[2]
                                    fcol = ftile[3]
                                    nbgcol = ftile[4]
                                    if nbgcol:
                                        bgcol = nbgcol
                                    char[2] = 255
                                except IndexError:
                                    char = [0,0,255]
                    if self.itemdict[self.curz].get('%s,%s' % (lx,ly)):
                        items = self.itemdict[self.curz]['%s,%s' % (lx,ly)].values()
                        items.sort(key=lambda value: value[1],reverse = True)
                        item = items[0][0]
                        itemname = item[0]
                        itemstruct = self.invdict[item[1]][itemname]
                        fcol = libtcod.white
                        char = [int(itemstruct['CHAR'][0]),int(itemstruct['CHAR'][1]),255]
                    try:
                        if not type(self.rheightmap['%s,%s' % (lx,ly)]) == str:
                            tfcol = self.translayer[self.curz]['%s,%s' % (lx,ly)][1]
                            tbcol = self.translayer[self.curz]['%s,%s' % (lx,ly)][0]
                            shadperc = max(self.shadowdict['%s,%s' % (lx,ly)][0],self.shadowdict['%s,%s' % (lx,ly)][1])
                            fcol = libtcod.color_lerp(tfcol, libtcod.black, shadperc)
                            bcol = libtcod.color_lerp(tbcol, libtcod.black, shadperc)
                    except KeyError:
                        pass
                    if type(self.rheightmap['%s,%s' % (lx,ly)]) == str:
                        try:
                            fcol = Clouds.nfcolordict['%s,%s' % (lx,ly)]
                            bcol = Clouds.ncolordict['%s,%s' % (lx,ly)]
                        except KeyError:
                            fcol = Clouds.ofcolordict['%s,%s' % (lx,ly)]
                            bcol = Clouds.ocolordict['%s,%s' % (lx,ly)]
                        shadperc = min(self.shadowdict['%s,%s' % (lx,ly)][1],0.9)
                        fcol = libtcod.color_lerp(fcol,libtcod.white,shadperc)
                        bcol = libtcod.color_lerp(bcol,libtcod.white,shadperc)
                    libtcod.console_set_default_foreground(self.window, fcol)
                    libtcod.console_set_default_background(self.window, bcol)
                    libtcod.console_print_ex(self.window, lx, ly, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))                        
            elif self.docopses[key][0] == 'out' and self.docopses[key][1] == 'in':
                self.docopses[key] = ['done','out']
                for leaf in leaflist:
                    lx = leaf[0]
                    ly = leaf[1]
                    shadperc = max(self.shadowdict['%s,%s' % (lx,ly)][0],self.shadowdict['%s,%s' % (lx,ly)][1])
                    try:
                        char = self.rtextdict['%s,%s' % (lx,ly)][0]
                        bgcol = self.rterraindict['%s,%s' % (lx,ly)]
                        fcol = self.rtextdict['%s,%s' % (lx,ly)][1]
                    except KeyError:
                        pass
                    try:
                        Clouds.vrskip.pop('%s,%s' % (lx,ly))
                    except KeyError:
                        pass
                    try:
                        fcol = self.shdict['%s,%s' % (lx,ly)][0]
                        char = self.shdict['%s,%s' % (lx,ly)][1]
                        bgcol = self.rterraindict['%s,%s' % (lx,ly)]
                    except KeyError:
                        pass
                    try:
                        bgcol = self.translayer[self.curz]['%s,%s' % (lx,ly)][0]
                        fcol = self.translayer[self.curz]['%s,%s' % (lx,ly)][1]
                        char = self.translayer[self.curz]['%s,%s' % (lx,ly)][2]
                    except KeyError:
                        pass
                    try:
                        fcol = Clouds.nfcolordict['%s,%s' % (lx,ly)]
                        bgcol = Clouds.ncolordict['%s,%s' % (lx,ly)]
                    except KeyError:
                        fcol = Clouds.ofcolordict['%s,%s' % (lx,ly)]
                        bgcol = Clouds.ocolordict['%s,%s' % (lx,ly)]
                    if type(self.rheightmap['%s,%s' % (lx,ly)]) == str:
                        try:
                            fcol = Clouds.nfcolordict['%s,%s' % (lx,ly)]
                            bcol = Clouds.ncolordict['%s,%s' % (lx,ly)]
                        except KeyError:
                            fcol = Clouds.ofcolordict['%s,%s' % (lx,ly)]
                            bcol = Clouds.ocolordict['%s,%s' % (lx,ly)]
                        shadperc = min(self.shadowdict['%s,%s' % (lx,ly)][1],0.9)
                        fcol = libtcod.color_lerp(fcol,libtcod.white,shadperc)
                        bgcol = libtcod.color_lerp(bcol,libtcod.white,shadperc)
                    else:
                        fcol = libtcod.color_lerp(fcol,libtcod.black,shadperc)
                        bgcol = libtcod.color_lerp(bgcol,libtcod.black,shadperc)
                    libtcod.console_set_default_foreground(self.window, fcol)
                    libtcod.console_set_default_background(self.window, bgcol)
                    libtcod.console_print_ex(self.window, lx, ly, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                    try:
                        try:
                            ztop = self.ztop['%s,%s' % (lx,ly)]
                        except KeyError:
                            ztop = self.curz
                        if ztop > self.curz:
                            try:
                                Clouds.bskip.pop('%s,%s' % (lx,ly))
                                tile = self.zgrid[ztop]['%s,%s' % (lx,ly)]
                                buildtype = tile[0]
                                char = tile[2]
                                char[2] = 255
                                fg = tile[3]
                                bg = tile[4]
                                if buildtype == 'door':
                                    if tile[5] == 'open':
                                        try:
                                            ftile = tile[6]
                                            char = ftile[2]
                                            fg = ftile[3]
                                            bg = ftile[4]
                                            char[2] = 255
                                        except IndexError:
                                            char = [0,0,255]
                                libtcod.console_set_default_foreground(wrwindow, fg)
                                if bg:
                                    libtcod.console_set_default_background(wrwindow, bg)
                                    libtcod.console_print_ex(wrwindow, lx, ly, libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
                                else:
                                    libtcod.console_print_ex(wrwindow, lx, ly, libtcod.BKGND_NONE, libtcod.LEFT, chr(DoChar(char)))
                            except KeyError:
                                pass
                    except KeyError:
                        pass                  
        lock.release()

    # In-Game Visual Functionality

    def groundView(self):
        global ButtonList, Clouds, NoButtons, NoMenus, DoHUD, moveclouds
        NoButtons,NoMenus,DoHUD = True,True,False
        ButtonList = []
        if not self.groundview:
            lock.acquire()
            for tile in self.translayer[self.curz].keys():
                tile = [int(tile.split(',')[0]),int(tile.split(',')[1])]
                bgcol = self.rterraindict['%s,%s' % (tile[0],tile[1])]
                try:
                    char = self.rtextdict['%s,%s' % (tile[0],tile[1])][0]
                    fcol = self.rtextdict['%s,%s' % (tile[0],tile[1])][1]
                except KeyError:
                    pass
                try:
                    fcol = self.shdict['%s,%s' % (tile[0],tile[1])][0]
                    char = self.shdict['%s,%s' % (tile[0],tile[1])][1]
                except KeyError:
                    pass
                if self.treedict.get('%s,%s' % (tile[0],tile[1])):
                    dperc = 0.0
                    fcol = libtcod.white
                    char = self.treedict['%s,%s' % (tile[0],tile[1])][0][4]
                elif self.treedict.get('%s,%s' % (tile[0] + 1,tile[1])):
                    if 'w' in self.treedict['%s,%s' % (tile[0] + 1,tile[1])][0][6]:
                        if self.tallgrassdict.get('%s,%s' % (tile[0],tile[1])):
                            char = rootcharwtg
                        elif self.dirtdict.get('%s,%s' % (tile[0],tile[1])):
                            char = rootcharwd
                        elif self.leafgrounddict.get('%s,%s' % (tile[0],tile[1])):
                            char = rootcharwl
                        else:
                            char = rootcharwg
                elif self.treedict.get('%s,%s' % (tile[0] - 1,tile[1])):
                    if 'e' in self.treedict['%s,%s' % (tile[0] - 1,tile[1])][0][6]:
                        if self.tallgrassdict.get('%s,%s' % (tile[0],tile[1])):
                            char = rootcharetg
                        elif self.dirtdict.get('%s,%s' % (tile[0],tile[1])):
                            char = rootchared
                        elif self.leafgrounddict.get('%s,%s' % (tile[0],tile[1])):
                            char = rootcharel
                        else:
                            char = rootchareg
                elif self.treedict.get('%s,%s' % (tile[0],tile[1] + 1)):
                    if 'n' in self.treedict['%s,%s' % (tile[0],tile[1] + 1)][0][6]:
                        if self.tallgrassdict.get('%s,%s' % (tile[0],tile[1])):
                            char = rootcharntg
                        elif self.dirtdict.get('%s,%s' % (tile[0],tile[1])):
                            char = rootcharnd
                        elif self.leafgrounddict.get('%s,%s' % (tile[0],tile[1])):
                            char = rootcharnl
                        else:
                            char = rootcharng
                elif self.treedict.get('%s,%s' % (tile[0],tile[1] - 1)):
                    if 's' in self.treedict['%s,%s' % (tile[0],tile[1] - 1)][0][6]:
                        if self.tallgrassdict.get('%s,%s' % (tile[0],tile[1])):
                            char = rootcharstg
                        elif self.dirtdict.get('%s,%s' % (tile[0],tile[1])):
                            char = rootcharsd
                        elif self.leafgrounddict.get('%s,%s' % (tile[0],tile[1])):
                            char = rootcharsl
                        else:
                            char = rootcharsg
                if type(self.rheightmap['%s,%s' % (tile[0],tile[1])]) == str:
                    try:
                        fcol = Clouds.nfcolordict['%s,%s' % (tile[0],tile[1])]
                        bcol = Clouds.ncolordict['%s,%s' % (tile[0],tile[1])]
                    except KeyError:
                        fcol = Clouds.ofcolordict['%s,%s' % (tile[0],tile[1])]
                        bcol = Clouds.ocolordict['%s,%s' % (tile[0],tile[1])]
                    shadperc = min(self.shadowdict['%s,%s' % (tile[0],tile[1])][1],0.9)
                    fcol = libtcod.color_lerp(fcol,libtcod.white,shadperc)
                    bcol = libtcod.color_lerp(bcol,libtcod.white,shadperc)
                Clouds.ncolordict['%s,%s' % (tile[0],tile[1])] = bgcol
                Clouds.nfcolordict['%s,%s' % (tile[0],tile[1])] = fcol
                libtcod.console_set_default_foreground(self.window, fcol)
                libtcod.console_set_default_background(self.window, bgcol)
                libtcod.console_print_ex(self.window, tile[0], tile[1], libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
            self.groundview = True
            lock.release()
            NoButtons,NoMenus,DoHUD = False,False,True
            self.handlePCchar()
            self.handlePCview()
        else:
            for item in self.translayer[self.curz].items():
                tile = [int(item[0].split(',')[0]),int(item[0].split(',')[1])]
                try:
                    Clouds.vrskip.pop('%s,%s' % (tile[0],tile[1]))
                except KeyError:
                    pass
                shadperc = max(self.shadowdict['%s,%s' % (tile[0],tile[1])][0],self.shadowdict['%s,%s' % (tile[0],tile[1])][1])
                Clouds.ncolordict['%s,%s' % (tile[0],tile[1])] = item[1][0]
                Clouds.nfcolordict['%s,%s' % (tile[0],tile[1])] = item[1][1]
                bgcol = libtcod.color_lerp(item[1][0],libtcod.black,shadperc)
                fcol = libtcod.color_lerp(item[1][1],libtcod.black,shadperc)
                char = item[1][2]
                libtcod.console_set_default_foreground(self.window, fcol)
                libtcod.console_set_default_background(self.window, bgcol)
                libtcod.console_print_ex(self.window, tile[0], tile[1], libtcod.BKGND_SET, libtcod.LEFT, chr(DoChar(char)))
            self.groundview = False
            self.updateStatus()
            self.handlePCchar()
            self.handlePCview()
        NoButtons,NoMenus = False,False

    # Game Startup

    def run(self):
        global MenuSetting, MenuList, DOSCREEN, TextList, MouseLock, MoveLock, moveclouds, Clouds, DoHUD, NoUpdate, q, NoKeys, PX, PY

        DOSCREEN = 2

        if not self.loading:
            # Set up the world.

            self.PCHP = 80
            self.PCDamage = 0
            self.PCMP = 90
            self.PCManaDrain = 0
            self.PCPhase = 100
            PX,PY = 0,0

            self.pswitch = False
            GameWorld.windowswitch = False
            MouseLock,MoveLock = True,True

            DrawScroll(wpwindow,VIEW_WIDTH / 2 - 7,VIEW_HEIGHT / 2 - 1, 13, 2, 1)
            libtcod.console_set_default_foreground(wpwindow,libtcod.black)
            libtcod.console_print_ex(wpwindow,VIEW_WIDTH / 2,VIEW_HEIGHT / 2,libtcod.BKGND_NONE,libtcod.CENTER,'Loading...')
            time.sleep(1.0)

            playMusic('music\\wav\\Cult-summer.wav',-1)
            
            libtcod.console_set_default_background(wrwindow, libtcod.black)
            libtcod.console_clear(wiwindow)
            libtcod.console_clear(wswindow)
            time.sleep(0.1)
            libtcod.console_clear(wpwindow)
            
            self.loadWorld()
            Clouds = WCloudNoise(wpwindow)
            Clouds.start()
            moveclouds = True

            # Load in all external configuration/text-entry files.
            # (Eventually, this is where you will want to put mod-loading, probably.)

            self.matstruct = self.LoadStruct('mats')
            self.weaponstruct = self.LoadStruct('weapons')
            self.compstruct = self.LoadStruct('components')

            self.invdict = {}
            self.invdict['weapon'] = self.weaponstruct
            self.invdict['component'] = self.compstruct

            self.treefiles = {}
            self.treefiles['deciduous'] = self.LoadTerrain('tree','deciduous')
            self.treefiles['coniferous'] = self.LoadTerrain('tree','coniferous')
            self.treefiles['tropical'] = self.LoadTerrain('tree','tropical')

            self.boulderfiles = {}
            self.boulderfiles['land'] = self.LoadTerrain('boulder','land')

            self.shrubfiles = {}
            self.shrubfiles['shrub'] = self.LoadTerrain('shrub','shrub')
            self.shrubfiles['fern'] = self.LoadTerrain('shrub','fern')

            self.logfiles = {}
            self.logfiles['land'] = self.LoadTerrain('log','land')

            self.copsefiles = {}
            self.copsefiles['copse'] = self.LoadTerrain('copse','copse')

            self.terdict = {}
            self.terdict['shrub'] = self.shrubfiles
            self.terdict['tree'] = self.treefiles
            self.terdict['boulder'] = self.boulderfiles
            self.terdict['copse'] = self.copsefiles
            self.terdict['log'] = self.logfiles

            ###

            # Building Engine

            self.buildtypes = ['floor','wall','roof','door','window','pillar','fence','stairs','ladder']
            self.builddict = {}
            for btype in self.buildtypes:
                self.builddict[btype] = self.LoadCon(btype)

            ###

            # Action Types

            self.adict = {}
            self.adict['none'] = [('Look',doNothing)]
            self.adict['item'] = [('Examine',doNothing),('Pick Up',GameWorld.pickUp)]
            self.adict['mountain'] = [('Strike',doNothing),('Mine',GameWorld.mineRock),('Look',doNothing)]
            self.adict['tree'] = [('Climb',doNothing),('Fell',GameWorld.fellTree),('Strike',doNothing),('Look',doNothing)]
            self.adict['copse'] = [('Climb',doNothing),('Fell',GameWorld.fellCopse),('Strike',doNothing),('Look',doNothing)]
            self.adict['shrub'] = [('Forage',doNothing),('Fell',doNothing),('Look',doNothing)]
            self.adict['water'] = [('Swim',doNothing),('Drink',doNothing),('Look',doNothing)]
            self.adict['door-closed'] = [('Open',GameWorld.openDoor),('Force',doNothing),('Look',doNothing)]
            self.adict['door-open'] = [('Close',GameWorld.closeDoor),('Look',doNothing)]
            self.adict['up-stairs'] = [('Climb',GameWorld.climbStairs),('Look',doNothing)]
            self.adict['up-ladder'] = [('Climb',GameWorld.climbStairs),('Look',doNothing)]
            self.adict['down-stairs'] = [('Descend',GameWorld.descendStairs),('Look',doNothing)]
            self.adict['down-ladder'] = [('Descend',GameWorld.descendStairs),('Look',doNothing)]
            self.adict['air'] = [('Look',doNothing)]

            ###

            self.regiondict = {}
            self.citygrid = {}
            for x in range(MAP_WIDTH):
                for y in range(MAP_HEIGHT):
                    self.citygrid['%s,%s' % (x,y)] = None
            for city in wcitydict.keys():
                self.citygrid['%s,%s' % (wcitydict[city][0][0],wcitydict[city][0][1])] = city
            for village in wvillagedict.keys():
                self.citygrid['%s,%s' % (wvillagedict[village][0][0],wvillagedict[village][0][1])] = village
            
            self.rdictSetup()
            self.siteMenu()
            borderbutton = ButtonBox(wswindow, 5, 44, '+ Borders', '+')
            self.ocity = {}

            self.doGUIMenu(page = 1)

        MouseLock,MoveLock = False,False

        while DOSCREEN == 2 and not self.killswitch:
            # Time handling.
            time.sleep(1)
            drawclock = False
            if self.runtime:
                self.minutes += 1
                if self.minutes == 60:
                    self.minutes = 0
                    self.hours += 1
                    drawclock = True
                    if self.hours == 24:
                        self.hours = 0
                if self.hours > 11:
                    ampm = ' PM'
                else:
                    ampm = ' AM'
                if self.hours == 0:
                    self.timestr = '12:%02d' % self.minutes
                elif self.hours > 12:
                    self.timestr = '%02d:%02d' % (self.hours - 12,self.minutes)
                else:
                    self.timestr = '%02d:%02d' % (self.hours,self.minutes)
                self.timestr += ampm
                NoGraphics,NoMenus,NoButtons = True,True,True
                lock.acquire()
                if drawclock:
                    libtcod.console_set_default_background(TimeLayer,scrollcolor2)
                    libtcod.console_clear(TimeLayer)
                    libtcod.console_set_default_foreground(TimeLayer,libtcod.white)
                    xmod = self.hours % 6
                    ymod = self.hours / 6
                    xpos = xmod * 5
                    ypos = 2035 + (ymod * 5)
                    for x in range(5):
                        for y in range(5):
                            char = [x + xpos,y + ypos,255]
                            libtcod.console_print_ex(TimeLayer,x,y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                    for x in range(11):
                        for y in range(5):
                            if y == 0 or y == 4 or x == 10:
                                char = [x,2030 + y,255]
                                libtcod.console_print_ex(TimeLayer,5 + x,y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
                libtcod.console_set_default_foreground(TimeLayer,libtcod.black)
                libtcod.console_print_ex(TimeLayer,6,2,libtcod.BKGND_NONE,libtcod.LEFT,self.timestr)
                lock.release()
                NoGraphics,NoMenus,NoButtons = False,False,False
            # Status updates.
            if DoHUD and not NoUpdate:
                if self.PCPhase < 100:
                    self.PCPhase = min(self.PCPhase + 5,100)
                self.updateStatus()
            # Queue handling.
            if not q.empty():
                item = q.get()
                if item == 'genproc-terrain':
                    lock.acquire()
                    NoKeys,MouseLock = True,True
                    self.doLoadScreen('terrain')
                    self.doTexture(rmap)
                    NoKeys,MouseLock = False,False
                    lock.release()
                elif item == 'genproc-trees':
                    lock.acquire()
                    NoKeys,MouseLock = True,True
                    self.doLoadScreen('trees')
                    self.doCopses()
                    self.doTrees()
                    NoKeys,MouseLock = False,False
                    lock.release()
                elif item == 'genproc-scrub':
                    lock.acquire()
                    NoKeys,MouseLock = True,True
                    self.doLoadScreen('scrub')
                    self.doScrub()
                    NoKeys,MouseLock = False,False
                    lock.release()
                elif item == 'genproc-misc':
                    lock.acquire()
                    NoKeys,MouseLock = True,True
                    self.doLoadScreen('misc')
                    self.doBoulders()
                    self.doLogs()
                    NoKeys,MouseLock = False,False
                    lock.release()
                elif item == 'world':
                    lock.acquire()
                    self.doLoadScreen('world')
                    time.sleep(1.0)
                    lthread = threading.Thread(target=GameWorld.doLeaveProc)
                    lthread.start()
                    lock.release()
                q.task_done()

class Pathfinder(threading.Thread):

    # This class handles pathfinding algorithms.
    
    def __init__(self,wobstructed,areas,x,y,x2,y2,actor = 'PC',domove = True,notify = True,skipareas = False,canswim = False):
        threading.Thread.__init__(self)
        self.wobstructed = wobstructed
        self.x = x
        self.y = y
        self.x2 = x2
        self.y2 = y2
        self.killswitch = False
        self.actor = actor
        self.areas = areas
        self.domove = domove
        self.pathgoing = True
        self.notify = notify
        self.skipareas = skipareas
        self.canswim = canswim
        self.path = True

    def run(self):
        global moveclouds
        mcloudstate = moveclouds
        moveclouds = False
        start = [self.x,self.y]
        end = [self.x2,self.y2]
        
        opendict = {}
        closeddict = {}
        
        heap = {}
        hposdict = {}

        gdict = {}
        pdict = {}

        heap[1] = [0,start]
        gdict['%s,%s' % (start[0],start[1])] = 0
        opendict['%s,%s' % (start[0],start[1])] = True

        curarea = None
        for area in self.areas:
            try:
                self.areas[area]['%s,%s' % (self.x,self.y)]
                curarea = area
            except KeyError:
                pass

        if GameWorld.rswitch == True:
            limitx,limity = RMAP_WIDTH,RMAP_HEIGHT
        else:
            limitx,limity = MAP_WIDTH,MAP_HEIGHT

    
        endarea = None
        for area in GameWorld.flood[GameWorld.curz]:
            try:
                GameWorld.flood[GameWorld.curz][area]['%s,%s' % (end[0],end[1])]
                endarea = area
            except KeyError:
                pass
                
        linked = False
        try:
            if type(endarea) == int:
                if endarea in GameWorld.rtree[GameWorld.curz][curarea]:
                    linked = True
        except KeyError:
            pass
                
        if not self.skipareas:
            if self.wobstructed.get('%s,%s' % (end[0],end[1])) or not (self.areas[curarea].get('%s,%s' % (end[0],end[1])) or linked):
                endfine = False
                if linked or self.areas[curarea].get('%s,%s' % (end[0],end[1])):
                    if self.wobstructed.get('%s,%s' % (end[0],end[1])) == 'water' and self.canswim:
                        endfine = True
                if endfine:
                    pass
                else:
                    if self.notify:
                        GameWorld.addMesg('You can\'t reach that place.', col = libtcod.yellow)
                    self.pathgoing = False
                    self.path = False
        else:
            if self.wobstructed.get('%s,%s' % (end[0],end[1])) or self.wobstructed.get('%s,%s' % (start[0],start[1])):
                endfine,startfine = False,False
                if self.wobstructed.get('%s,%s' % (end[0],end[1])) == 'water' and self.canswim:
                    endfine = True
                if self.wobstructed.get('%s,%s' % (start[0],start[1])) == 'water' and self.canswim:
                    startfine = True
                if endfine and startfine:
                    pass
                else:
                    if self.notify:
                        GameWorld.addMesg('You can\'t reach that place.', col = libtcod.yellow)
                    self.pathgoing = False
                    self.path = False
            
        if self.path:
            self.pathgoing = True
            while self.pathgoing:
                if len(heap) == 0:
                    break
                curtile = heap[1][1]
                opendict.pop('%s,%s' % (curtile[0],curtile[1]))
                closeddict['%s,%s' % (curtile[0],curtile[1])] = True
                heap[1] = heap[len(heap)]
                movetile = heap[1]
                heap.pop(len(heap))
                heappos = 1
                
                while True:
                    if len(heap) >= (heappos * 2) + 1:
                        if heap[heappos * 2][0] > heap[(heappos * 2) + 1][0]:
                            if heap[(heappos * 2) + 1][0] <= movetile[0]:
                                heap[heappos] = heap[(heappos * 2) + 1]
                                heap[(heappos * 2) + 1] = movetile
                                heappos = (heappos * 2) + 1
                            else:
                                break
                        else:
                            if heap[heappos * 2][0] <= movetile[0]:
                                heap[heappos] = heap[heappos * 2]
                                heap[heappos * 2] = movetile
                                heappos = heappos * 2
                            else:
                                break
                    elif len(heap) >= heappos * 2:
                        if heap[heappos * 2][0] <= movetile[0]:
                            heap[heappos] = heap[heappos * 2]
                            heap[heappos * 2] = movetile
                            heappos = heappos * 2
                        else:
                            break
                    else:
                        break
                
                for num in range(-1,2):
                    for num2 in range(-1,2):
                        newtile = [curtile[0] - num,curtile[1] - num2]
                        if newtile[0] in range(0,limitx) and newtile[1] in range(0,limity):
                            try:
                                if self.wobstructed['%s,%s' % (newtile[0],newtile[1])]:
                                    if self.canswim and self.wobstructed['%s,%s' % (newtile[0],newtile[1])] == 'water':
                                        pass
                                    else:
                                        continue
                            except KeyError:
                                try:
                                    closeddict['%s,%s' % (newtile[0],newtile[1])]
                                    continue
                                except KeyError:
                                    pass
                            if num == 0 or num2 == 0:
                                g = 10
                            else:
                                g = 14
                            try:
                                g += gdict['%s,%s' % (curtile[0],curtile[1])]
                            except KeyError:
                                pass
                            try:
                                oldcheck = opendict['%s,%s' % (newtile[0],newtile[1])]
                            except KeyError:
                                oldcheck = None
                            oldswitch = False
                            if oldcheck:
                                if g > gdict['%s,%s' % (newtile[0],newtile[1])]:
                                    continue
                                else:
                                    oldswitch = True                     
                            gdict['%s,%s' % (newtile[0],newtile[1])] = g
                            h = (abs(newtile[0] - end[0]) + abs(newtile[1] - end[1])) * 10
                            f = g + h

                            if oldswitch:
                                heappos = filter(lambda x: heap[x][1] == newtile, heap.keys())[0]
                            else:
                                heappos = len(heap) + 1
                            heap[heappos] = [f,newtile]
                            while heappos > 1:
                                if f < heap[heappos / 2][0]:
                                    heap[heappos] = heap[heappos / 2]
                                    heap[heappos / 2] = [f,newtile]
                                    heappos = heappos / 2
                                else:
                                    break
                            opendict['%s,%s' % (newtile[0],newtile[1])] = True
                            pdict['%s,%s' % (newtile[0],newtile[1])] = curtile
                            
                if curtile == end:
                    path = [end]
                    try:
                        ptile = pdict['%s,%s' % (end[0],end[1])]
                    except KeyError:
                        self.killswitch = True
                    while True:
                        try:
                            path.insert(0,[ptile[0],ptile[1]])
                            ptile = pdict['%s,%s' % (ptile[0],ptile[1])]
                        except KeyError or UnboundLocalError:
                            self.pathgoing = False
                            break
            moveclouds = mcloudstate

            if self.actor == 'PC' and self.domove:
                self.movePC(path)
                moveclouds = True
            try:
                self.path = path
            except UnboundLocalError:
                self.path = False
        else:
            moveclouds = mcloudstate

    def movePC(self,path):
        global PCX, PCY, hpcswitch
        hpcswitch = False
        leavecheck = False
        path.pop(0)
        while len(path) > 0 and not self.killswitch:
            while GameWorld.paused:
                time.sleep(0.1)
            ntile = path[0]
            path.remove(ntile)
            PCX = ntile[0]
            PCY = ntile[1]
            adjustScreen()
            GameWorld.handlePC()
            if (PCX in [0,RMAP_WIDTH - 1] or PCY in [0,RMAP_HEIGHT - 1]) and GameWorld.rswitch and len(path) == 0:
                GameWorld.leaveRegion()
            time.sleep(.15)
        if not self.killswitch:
            hpcswitch = True

####################################
# XV. Thesaurus Entries            #
####################################

thesaurus = {}

# Colors ========================= #

thesaurus['black'] = ['black','charcoal black','coal black','ebon','ebony','jet','onyx','sable']
thesaurus['blue'] = ['azure','beryl','blue-gray','blue-green','cerulean','cobalt','indigo','navy','royal blue','sapphire','teal','turquoise', \
                     'aquamarine','periwinkle']
thesaurus['brown'] = ['almond','brown','amber','auburn','beige','bronze','burnt sienna','chestnut','chocolate','cinnamon','cocoa brown','copper brown', \
                      'ginger brown','hazel','mahogany brown','ochre','puce','russet','sepia','tan','tawny','umber','sandy brown']
thesaurus['green'] = ['green','emerald green','beryl','forest green','chartreuse','jade green','lime green','pea green','moss green','olive green','sage green', \
                      'viridian']
thesaurus['gray'] = ['gray','ashen gray','cloudy gray','dove gray','dusky gray','granite gray','iron gray','leaden gray','pepper-gray','silver-gray', \
                     'slate gray','smoky gray']
thesaurus['orange'] = ['orange','goldenrod','burnt orange','tangerine-orange']
thesaurus['purple'] = ['purple','royal purple','amaranthine','amethyst','violet','blue-violet','pomegranate purple','mulberry purple','mauve','magenta','lavender','lilac purple', \
                       'heliotrope','orchid purple','periwinkle','perse']
thesaurus['red'] = ['red','blood red','cherry red','cardinal red','crimson','garnet red','magenta','maroon','coral red','puce','pink','rose red','rust red', \
                    'salmon pink','scarlet','vermilion','wine red']
thesaurus['silver'] = ['pearly silver','silver','sterling silver']
thesaurus['tan'] = ['peach','tan','cream-colored','beige','taupe']
thesaurus['white'] = ['white','chalky white','milky white','ivory white','snowy white','hoary white','off-white']
thesaurus['yellow'] = ['yellow','blonde','citron','canary yellow','creamy yellow','golden yellow','honey yellow','primrose yellow','straw yellow','sulfur yellow','tawny yellow','puce', \
                       'gold','caramel','flaxen yellow']

# Color Modifiers ================ #

thesaurus['pale'] = ['pale','blanched','faint','dim','faded','palid','waxen','sickly','cool']
thesaurus['bright'] = ['bright','blazing','dazzling','effulgent','glossy','radiant','lustrous','vivid']
thesaurus['dull'] = ['drab','dull','bleak','dreary','lusterless','faded','murky','somber']
thesaurus['neon'] = ['neon','iridescent','phosphorescent','softly glowing']
thesaurus['flecked'] = ['flecked','speckled','sprinkled']
thesaurus['striped'] = ['striped','banded','straked']
thesaurus['patched'] = ['patched','blotched','daubed','smeared','blotted','mottled','spattered','splotched','dappled']
thesaurus['spotted'] = ['spotted','dotted','bespotted']
thesaurus['tipped'] = ['tipped','topped']

# Creature Reproduction =========== #

thesaurus['crep-1'] = ['almost never reproduces','only reproduces once in a blue moon']
thesaurus['crep-2'] = ['reproduces extremely rarely']
thesaurus['crep-3'] = ['reproduces very rarely','very rarely reproduces']
thesaurus['crep-4'] = ['rarely reproduces','reproduces infrequently','seldomly reproduces']
thesaurus['crep-5'] = ['reproduces sporadically','reproduces semi-regularly']
thesaurus['crep-6'] = ['reproduces frequently','reproduces somewhat frequently']
thesaurus['crep-7'] = ['reproduces quite often','reproduces fairly often']
thesaurus['crep-8'] = ['reproduces enthusiastically and often','reproduces very often']
thesaurus['crep-9'] = ['reproduces at an astounding rate','reproduces extremely often']
thesaurus['crep-10'] = ['never seems to stop reproducing','constantly reproduces']

# ================================= #

thesaurus['aggwords'] = ['aggressive','belligerent','ferocious','vicious','bellicose','quarrelsome']
thesaurus['angeredwords'] = ['angered','antagonized','irritated','aggravated','upset']
thesaurus['appextingwords'] = ['extending','protruding','stretching','originating','emerging']
thesaurus['appextwords'] = ['extend','protrude','stretch','originate','emerge']
thesaurus['augustwords'] = ['august','remarkable','imposing','great','preeminent','prominent']
thesaurus['averagewords'] = ['average','typical','common','middling','unexceptional','ordinary']
thesaurus['avoidedwords'] = ['avoided','evaded','left alone','left to its own devices','steered clear of']
thesaurus['avoidwords'] = ['avoid','steer clear of','stay away from','keep clear of']

thesaurus['becausewords'] = ['because of','due to','as a result of','as a consequence of']
thesaurus['beholdwords'] = ['behold','lay eyes on','gaze upon','witness']
thesaurus['breachedwords'] = ['breached','violated','infringed upon','intruded upon','trespassed upon']
thesaurus['breachingwords'] = ['breaching','violating','infringing upon','intruding upon','trespassing upon']
thesaurus['breachwords'] = ['breach','violate','infringe upon','intrude upon','trespass upon']

thesaurus['careaboutwords'] = ['care about','concern itself with','bother with','trouble itself with','bother itself over','trouble itself over', \
                  'worry about']
thesaurus['clawwords'] = ['claw','talon','nail']
thesaurus['concernedwords'] = ['concerned','preoccupied','consumed','involved','engaged','engrossed']
thesaurus['cwords'] = ['creature','animal','beast']
thesaurus['cwordsplur'] = ['creatures','animals','beasts']

thesaurus['dangerouswords'] = ['dangerous','perilous','hazardous']
thesaurus['dangerwords'] = ['danger','threat','hazard','peril','risk','menace']
thesaurus['despisedwords'] = ['despised','abhorred','detested','hated','loathed']
thesaurus['despitewords'] = ['despite','in spite of','regardless of']
thesaurus['dietwords'] = ['diet','food preferences','feeding habits','feeding preferences','dietary preferences']
thesaurus['digitwords'] = ['digit','finger']
thesaurus['dividewords'] = ['divided into','comprised of','made up of','separated into']
thesaurus['docilewords'] = ['docile','amicable','peaceful','placid','nonbelligerent','easygoing','tranquil','peaceable','friendly']
thesaurus['dwellswords'] = ['dwells','lives','abides','resides']
thesaurus['dwellingwords'] = ['dwelling','inhabiting','abiding','living','residing']

thesaurus['encounteredwords'] = ['encountered','met','confronted','chanced upon','crossed']
thesaurus['encounterwords'] = ['encounter','meet','confront','chance upon','come across','run across','cross']
thesaurus['endingwords'] = ['ending','terminating','culminating']
thesaurus['endwords'] = ['end','terminate','culminate']

thesaurus['generallywords'] = ['generally','usually','typically','normally']

thesaurus['habitswords'] = ['habits','tendencies','mannerisms','proclivities','propensities','ways']
thesaurus['hasknownwords'] = ['has been said to have','is reputed to have','is said to have','is rumored to have','has been rumored to have']
thesaurus['howeverwords'] = ['however','all the same','be that as it may','nonetheless']

thesaurus['illtempwords'] = ['ill-tempered','cantankerous','irascible','touchy','acrimonious']
thesaurus['immensewords'] = ['immense','colossal','elephantine','enormous','gigantic','mammoth','monstrous']
thesaurus['inclinedwords'] = ['inclined to be','inclined towards being','disposed towards being','predisposed towards being','given to being']
thesaurus['inhabitswords'] = ['inhabits','populates','dwells in','abides in','resides in','dwells in']
thesaurus['iswords'] = ['is','can be','may be','tends to be','is known to be','is reputedly','has a reputation for being','is said to be', \
           'is regarded as being','is judged to be','is reckoned to be']

thesaurus['knowntowords'] = ['known to','reputed to','said to','rumored to','reputed to']

thesaurus['mainwords'] = ['main','primary','principal','major']
thesaurus['mainlywords'] = ['mainly','primarily','principally','mostly']

thesaurus['naturewords'] = ['nature','personality','behavior','demeanor','tendencies','disposition','temperament']

thesaurus['oddwords'] = ['remarkable','unusual','surprising','curious','peculiar','uncommon','odd']
thesaurus['oftenwords'] = ['frequently','often','usually']

thesaurus['peoplewords'] = ['many people','many races','some people','some races','some','many','numerous people','numerous peoples']
thesaurus['predatorwords'] = ['predator','beast of prey','animal of prey','hunter','meat-eater','carnivore']

thesaurus['rarelywords'] = ['infrequently','rarely','seldomly','occasionally','periodically']
thesaurus['respectedwords'] = ['honored','respected','revered','exalted','venerated','regarded highly','highly regarded']

thesaurus['seasonedwords'] = ['seasoned','accomplished','hardened','competent','expert','prepared']
thesaurus['segadj'] = ['segmented','partitioned','compartmentalized']
thesaurus['segwordplur'] = ['segments','sections','partitions']
thesaurus['segwordsing'] = ['cavity','segment','section']
thesaurus['shywords'] = ['shy','introverted','timid','reclusive','solitary']
thesaurus['sizewords'] = ['size','stature']
thesaurus['sometimeswords'] = ['sometimes','at times','occasionally','periodically']
thesaurus['surprisinglywords'] = ['surprisingly','shockingly','amazingly','peculiarly','unusually','singularly']

thesaurus['tendencywords'] = ['tendency','proclivity','propensity','predisposition']
thesaurus['terrguardwords'] = ['guard','protect','defend','safeguard','maintain']
thesaurus['terrifyingwords'] = ['terrifying','horrifying','frightening','daunting','unnerving','fearsome']
thesaurus['territorywords'] = ['territory','territorial domain','territorial dominion','territorial stomping ground', \
                  'territorial demesne']
thesaurus['thoughwords'] = ['though','although','while','even though','whilst']
thesaurus['travwordsplur'] = ['travelers','adventurers','wanderers','wayfarers']
thesaurus['triflingwords'] = ['insignificant','unimpressive','trifling','trivial','slight']

thesaurus['verywords'] = ['very','extremely','exceedingly','profoundly','remarkably','incredibly','excessively','extraordinarily','highly']
thesaurus['visionwords'] = ['image','sight','vision','spectacle']

thesaurus['weightwords'] = ['weight','heft','mass','bulk']

def t(baseword):
    global thesaurus
    return thesaurus[baseword]

####################################
# XVI. Main Worldgen Loop          #
####################################

def doWorldGen():
    global VIEW_HEIGHT, VIEW_WIDTH, SCREEN_HEIGHT, DoScaleLayer
    while KeyLock:
        libtcod.console_wait_for_keypress(True)
    libtcod.console_blit(wgwindow,0 + playerx,0 + playery,VIEW_WIDTH,VIEW_HEIGHT,0,20,2,1.0,1.0)
    libtcod.console_blit(wiwindow,0,0,VIEW_WIDTH,SCREEN_HEIGHT - VIEW_HEIGHT - 3,0,20,VIEW_HEIGHT + 3,1.0,0.5)
    libtcod.console_blit(wswindow,0,0,SCREEN_WIDTH - VIEW_WIDTH - 3,SCREEN_HEIGHT - 2,0,0,2,1.0,0.5)
    if DoScaleLayer:
        libtcod.console_blit(toplayer,0,0,VIEW_WIDTH,VIEW_HEIGHT,0,20,2,1.0,1.0)

####################################
# XVII. Main World Atlas Loop      #
####################################

def doWorldAtlas():
    global VIEW_HEIGHT, VIEW_WIDTH, SCREEN_HEIGHT
    
    while KeyLock:
        libtcod.console_wait_for_keypress(True)
    libtcod.console_blit(wawindow,0,0,VIEW_WIDTH,VIEW_HEIGHT,0,20,2,1.0,1.0)
    libtcod.console_blit(wswindow,0,0,SCREEN_WIDTH - VIEW_WIDTH - 3,SCREEN_HEIGHT - 2,0,0,2,1.0,0.5)

####################################
# XVIII. Main Game Loop            #
####################################

def doMainGame():
    global VIEW_HEIGHT, VIEW_WIDTH, SCREEN_HEIGHT, SCREEN_WIDTH, MAP_HEIGHT, SCREEN_HEIGHT, PY, PX, GameWorld, hpcswitch, \
           XConsoles, TopWindow, freeze, PCRlayer, PCWlayer, DoLoadScreen
    while KeyLock:
        libtcod.console_wait_for_keypress(True)
    if not freeze:
        if GameWorld.rswitch == True:
            limitx,limity = RMAP_WIDTH,RMAP_HEIGHT
        else:
            limitx,limity = MAP_WIDTH,MAP_HEIGHT
        MPX = max(min(PX,limitx - VIEW_WIDTH),0)
        MPY = max(min(PY,limity - VIEW_HEIGHT),0)
        if GameWorld.windowswitch:
            libtcod.console_blit(wrwindow,0 + MPX,0 + MPY,VIEW_WIDTH,VIEW_HEIGHT,0,20,2,1.0,1.0)
        else:
            libtcod.console_blit(wpwindow,0 + MPX,0 + MPY,VIEW_WIDTH,VIEW_HEIGHT,0,20,2,1.0,1.0)
            libtcod.console_blit(wpfxwindow,0 + MPX,0 + MPY,VIEW_WIDTH,VIEW_HEIGHT,0,20,2,1.0,1.0)
        for console in WeatherLayer:
            libtcod.console_blit(console[0],MPX,MPY,console[3],console[4],0,console[5],console[6],console[7],console[8])
        if GameWorld.windowswitch:
            libtcod.console_blit(PCRlayer,MPX,MPY,VIEW_WIDTH,VIEW_HEIGHT,0,20,2,1.0,0.0)
        else:
            libtcod.console_blit(PCWlayer,MPX,MPY,VIEW_WIDTH,VIEW_HEIGHT,0,20,2,1.0,0.0)
        if GameWorld.showclock:
            libtcod.console_blit(TimeLayer,0,0,16,5,0,22,3,1.0,1.0)
        if GameWorld.paused:
            libtcod.console_blit(PauseLayer,0,0,5,5,0,SCREEN_WIDTH - 9,3,1.0,1.0)
        for console in XConsoles:
            libtcod.console_blit(console[0],console[1],console[2],console[3],console[4],0,console[5],console[6],console[7],console[8])
        for console in TopWindow:
            libtcod.console_blit(console[0],console[1],console[2],console[3],console[4],0,console[5],console[6],console[7],console[8])
        libtcod.console_blit(toplayer,0,0,VIEW_WIDTH,VIEW_HEIGHT,0,20,2,1.0,0.0)
        if DoLoadScreen:
            libtcod.console_blit(LoadScreen,0,0,VIEW_WIDTH,VIEW_HEIGHT,0,20,2,1.0,1.0)
        if hpcswitch:
            GameWorld.handlePC()
        libtcod.console_blit(wiwindow,0,0,VIEW_WIDTH,SCREEN_HEIGHT - VIEW_HEIGHT - 3,0,20,VIEW_HEIGHT + 3,1.0,0.5)
        libtcod.console_blit(wswindow,0,0,SCREEN_WIDTH - VIEW_WIDTH - 3,SCREEN_HEIGHT - 2,0,0,2,1.0,0.5)
    else:
        time.sleep(0.1)

####################################
# XIX. Main Loop                   #
####################################

if __name__ == '__main__':
    libtcod.mouse_show_cursor(True)

    fontimage = libtcod.image_load('fonts\\' + init['FONT'])

    if init['FONT TYPE'] == 'GREYSCALE':
        libtcod.console_set_custom_font('fonts\\' + init['FONT'],libtcod.FONT_LAYOUT_TCOD | libtcod.FONT_TYPE_GREYSCALE,fontx,fonty)
    else:
        libtcod.console_set_custom_font('fonts\\' + init['FONT'],libtcod.FONT_LAYOUT_TCOD,fontx,fonty)
    libtcod.console_init_root(SCREEN_WIDTH,SCREEN_HEIGHT,'Empyrea ' + __version__,False)

    finfomod = libtcod.image_get_size(fontimage)
    finfomod = finfomod[0] / 32
    fontinfo = libtcod.image_load('fonts\\fontinfo%s.png' % finfomod)
    
    libtcod.sys_set_fps(LIMIT_FPS)

    # GUI Layer Location

    GUITiles = {}
    GUIxloc = 20 + (VIEW_WIDTH / 2) - 16
    GUIyloc = 2 + VIEW_HEIGHT - 10
    for x in range(GUIxloc + 12,GUIxloc + 20):
        for y in range(GUIyloc,GUIyloc + 4):
            GUITiles['%s,%s' % (x,y)] = True
    for x in range(GUIxloc,GUIxloc + 32):
        for y in range(GUIyloc + 4,GUIyloc + 9):
            GUITiles['%s,%s' % (x,y)] = True

    # GUI Buttons Setup
    icon_emptybutton = (1,2026)
    icon_pause = (9,2022)
    icon_unpause = (13,2022)
    icon_group = (16,2022)
    icon_grouph = (20,2022)
    icon_battle = (13,2026)
    icon_battleh = (6,2022)
    icon_task = (16,2026)
    icon_taskh = (23,2022)
    button_sub = (13,2025)
    button_subh = (10,2021)
    button_add = (17,2025)
    button_addh = (20,2021)

    GUITiles['button1'] = []
    GUITiles['button2'] = []
    GUITiles['button3'] = []
    GUITiles['button4'] = []
    GUITiles['button5'] = []
    GUITiles['button6'] = []
    GUITiles['unpause'] = []
    GUITiles['pause'] = []
    GUITiles['group'] = []
    GUITiles['grouph'] = []
    GUITiles['battle'] = []
    GUITiles['battleh'] = []
    GUITiles['task'] = []
    GUITiles['taskh'] = []
    GUITiles['sub'] = []
    GUITiles['subh'] = []
    GUITiles['add'] = []
    GUITiles['addh'] = []
    for x in range(3):
        for y in range(3):
            GUITiles['button1'].append((1 + x,5 + y))
            GUITiles['button2'].append((5 + x,5 + y))
            GUITiles['button3'].append((9 + x,5 + y))
            GUITiles['button4'].append((20 + x,5 + y))
            GUITiles['button5'].append((24 + x,5 + y))
            GUITiles['button6'].append((28 + x,5 + y))
            GUITiles['unpause'].append((13 + x,1 + y))
            GUITiles['pause'].append((9 + x,1 + y))
            GUITiles['group'].append((16 + x,1 + y))
            GUITiles['grouph'].append((20 + x,1 + y))
            GUITiles['battle'].append((13 + x,5 + y))
            GUITiles['battleh'].append((10 + x,1 + y))
            GUITiles['task'].append((16 + x,5 + y))
            GUITiles['taskh'].append((23 + x,1 + y))
    for x in range(2):
        GUITiles['sub'].append((13 + x,4))
        GUITiles['add'].append((17 + x,4))
        GUITiles['subh'].append((10 + x,0))
        GUITiles['addh'].append((20 + x,0))
    
    # Initial GUI Setup
    GUIMenu = {}
    GUIMenu['menu'] = 'battle'
    GUIMenu['page'] = 1
    GUIMenu['battle'] = {}
    GUIMenu['task'] = {}
    GUIMenu['group'] = {}
    libtcod.console_set_key_color(GUILayer,libtcod.magenta)
    libtcod.console_set_default_background(GUILayer,libtcod.magenta)
    libtcod.console_clear(GUILayer)
    libtcod.console_set_default_background(GUILayer,libtcod.black)
    libtcod.console_set_default_foreground(GUILayer,libtcod.white)
    for x in range(12,20):
        for y in range(2021,2025):
            char = [x,y,255]
            libtcod.console_print_ex(GUILayer,x,y - 2021,libtcod.BKGND_SET,libtcod.LEFT,chr(DoChar(char)))
    for x in range(32):
        for y in range(2025,2030):
            char = [x,y,255]
            libtcod.console_print_ex(GUILayer,x,y - 2021,libtcod.BKGND_SET,libtcod.LEFT,chr(DoChar(char)))
    for x in range(3):
        for y in range(3):
            char = [icon_battleh[0] + x,icon_battleh[1] + y,255]
            libtcod.console_print_ex(GUILayer,GUITiles['battle'][0][0] + x,GUITiles['battle'][0][1] + y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))       
    libtcod.console_set_default_foreground(GUILayer,libtcod.black)
    libtcod.console_set_default_background(GUILayer,scrollcolor2)
    libtcod.console_print_ex(GUILayer,15,4,libtcod.BKGND_SET,libtcod.LEFT,'%02d' % GUIMenu['page'])
    GUICon = [GUILayer,0,0,32,9,GUIxloc,GUIyloc,1.0,1.0]
    libtcod.console_set_default_foreground(GUILayer,libtcod.white)

    # Actions Setup

    # Tasks
    action_dig = [(0,2006),'task','Dig','Dig a pit or a channel.']
    action_mine = [(3,2006),'task','Mine','Mine out rocky tiles.']
    action_fell = [(6,2006),'task','Fell','Chop down trees or shrubs.']
    action_forage = [(9,2006),'task','Forage','Forage for berries and fruits.']
    action_till = [(12,2006),'task','Till','Till the ground for farming.']
    action_deconstruct = [(15,2006),'task','Deconstruct','Destroy a construction.']
    
    GUIMenu['task'][1] = [action_dig,action_mine,action_fell,action_forage,action_till,action_deconstruct]
    GUIMenu['task'][2] = [None,None,None,None,None,None]
    GUIMenu['task'][3] = [None,None,None,None,None,None]
    GUIMenu['task'][4] = [None,None,None,None,None,None]
    GUIMenu['task'][5] = [None,None,None,None,None,None]
    GUIMenu['task'][6] = [None,None,None,None,None,None]

    # Battle
    action_attack = [(0,2012),'battle','Attack','Attack a target with your primary weapon.']
    action_throw = [(3,2012),'battle','Throw','Throw something at a target.']
    action_drink = [(6,2012),'battle','Drink','Drink a potion.']
    action_defend = [(9,2012),'battle','Defend','Defend against physical attacks.']
    action_poisonblade = [(12,2012),'battle','Poison Blade','Poison your primary weapon.']
    action_ember = [(15,2012),'battle','Ember','A hot, magical ember which can be tossed at an enemy.']

    GUIMenu['battle'][1] = [action_attack,action_throw,action_drink,action_defend,action_poisonblade,action_ember]
    GUIMenu['battle'][2] = [None,None,None,None,None,None]
    GUIMenu['battle'][3] = [None,None,None,None,None,None]
    GUIMenu['battle'][4] = [None,None,None,None,None,None]
    GUIMenu['battle'][5] = [None,None,None,None,None,None]
    GUIMenu['battle'][6] = [None,None,None,None,None,None]

    # Group
    action_alert = [(0,2018),'group','Alert','Alert your entire party to danger.']
    action_formranks = [(3,2018),'group','Form Ranks','Order your party to get into formation.']
    action_battlecry = [(6,2018),'group','Battle Cry','A rage-filled battle cry. +Damage for whole party.']
    action_anthem = [(9,2018),'group','Anthem','An inspiring tune. Increases party morale.']
    action_groupstealth = [(12,2018),'group','Group Stealth','Order your party to use stealth.']
    action_allforone = [(15,2018),'group','All For One','Strong party members sometimes shield weak members.']

    GUIMenu['group'][1] = [action_alert,action_formranks,action_battlecry,action_anthem,action_groupstealth,action_allforone]
    GUIMenu['group'][2] = [None,None,None,None,None,None]
    GUIMenu['group'][3] = [None,None,None,None,None,None]
    GUIMenu['group'][4] = [None,None,None,None,None,None]
    GUIMenu['group'][5] = [None,None,None,None,None,None]
    GUIMenu['group'][6] = [None,None,None,None,None,None]
    
    # Initial time setup.
    libtcod.console_set_default_background(TimeLayer,scrollcolor2)
    libtcod.console_clear(TimeLayer)
    for x in range(5):
        for y in range(5):
            char = [x,2035 + y,255]
            libtcod.console_set_default_foreground(TimeLayer,libtcod.white)
            libtcod.console_print_ex(TimeLayer,x,y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))
    for x in range(11):
        for y in range(5):
            if y == 0 or y == 4 or x == 10:
                char = [x,2030 + y,255]
                libtcod.console_print_ex(TimeLayer,5 + x,y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))

    # Pause icon setup.
    libtcod.console_set_default_foreground(PauseLayer,libtcod.white)
    for x in range(5):
        for y in range(5):
            char = [11 + x,2030 + y ,255]
            libtcod.console_print_ex(PauseLayer,x,y,libtcod.BKGND_NONE,libtcod.LEFT,chr(DoChar(char)))

    # Color Scheme Settings
    colorscheme = {}
    colorscheme['GREEN'] = {}
    colorscheme['GREEN']['bordercol'] = libtcod.Color(125,168,122)
    colorscheme['GREEN']['bordercol2'] = libtcod.Color(74,47,47)
    colorscheme['GREEN']['bordercolh2'] = libtcod.Color(98,50,51)
    colorscheme['GREEN']['candlecolor'] = libtcod.light_flame
    colorscheme['GREEN']['bgcolor'] = libtcod.Color(39,60,38)
    colorscheme['GREEN']['hcolor'] = libtcod.Color(64,17,18)
    colorscheme['GREEN']['hcolor2'] = libtcod.Color(171,60,60)
    colorscheme['GREEN']['buttonh'] = libtcod.crimson
    colorscheme['GREEN']['buttont'] = libtcod.black
    colorscheme['GREEN']['hlite'] = libtcod.lighter_sea
    colorscheme['GREEN']['bgcolor2'] = libtcod.Color(43,80,41)
    colorscheme['GREEN']['buttonback'] = libtcod.Color(30,43,30)

    bordercol = colorscheme[init['COLOR SCHEME']]['bordercol']
    bordercol2 = colorscheme[init['COLOR SCHEME']]['bordercol2']
    bordercolh2 = colorscheme[init['COLOR SCHEME']]['bordercolh2']
    candlecolor = colorscheme[init['COLOR SCHEME']]['candlecolor']
    bgcolor = colorscheme[init['COLOR SCHEME']]['bgcolor']
    bgcolor2 = colorscheme[init['COLOR SCHEME']]['bgcolor2']
    hcolor = colorscheme[init['COLOR SCHEME']]['hcolor']
    hcolor2 = colorscheme[init['COLOR SCHEME']]['hcolor2']
    buttonh = colorscheme[init['COLOR SCHEME']]['buttonh']
    buttont = colorscheme[init['COLOR SCHEME']]['buttont']
    hlite = colorscheme[init['COLOR SCHEME']]['hlite']
    buttonback = colorscheme[init['COLOR SCHEME']]['buttonback']

    # Soft-numbered character locations for use with f. DoChar

    rboulder1 = [26,32,255]
    rboulder2 = [27,32,255]
    rboulder3 = [26,33,255]
    rboulder4 = [27,33,255]
    rboulderchars = [rboulder1,rboulder2,rboulder3,rboulder4]

    rweeds1 = [26,34,255]
    rweeds2 = [27,34,255]
    rweeds3 = [26,35,255]
    rweeds4 = [27,35,255]
    rweedschars = [rweeds1,rweeds2,rweeds3,rweeds4]

    bankweed1 = [26,36,255]
    bankweed2 = [27,36,255]
    bankweed3 = [26,37,255]
    bankweed4 = [27,37,255]
    bankweedchars = [bankweed1,bankweed2,bankweed3,bankweed4]

    thickgrass1 = [26,38,255]
    thickgrass2 = [27,38,255]
    thickgrass3 = [26,39,255]
    thickgrass4 = [27,39,255]
    thickgrass5 = [26,40,255]
    thickgrass6 = [27,40,255]
    thickgrass7 = [26,41,255]
    thickgrass8 = [27,41,255]
    thickgrasschars = [thickgrass1,thickgrass2,thickgrass3,thickgrass4, \
                       thickgrass5,thickgrass6,thickgrass7,thickgrass8]

    count = 0
    tallgrasschars = []
    for x in range(28,32):
        for y in range(36,40):
            count += 1
            globals()['tallgrass%s' % count] = [x,y,255]
    tallgrasschars = [tallgrass1,tallgrass2,tallgrass3,tallgrass4, \
                      tallgrass5,tallgrass6,tallgrass7,tallgrass8, \
                      tallgrass9,tallgrass10,tallgrass11,tallgrass12, \
                      tallgrass13,tallgrass14,tallgrass15,tallgrass16]

    count = 0
    midgrasschars = []
    for x in range(28,32):
        for y in range(40,44):
            count += 1
            globals()['midgrass%s' % count] = [x,y,255]
    midgrasschars = [midgrass1,midgrass2,midgrass3,midgrass4, \
                      midgrass5,midgrass6,midgrass7,midgrass8, \
                      midgrass9,midgrass10,midgrass11,midgrass12, \
                      midgrass13,midgrass14,midgrass15,midgrass16]

    leafchar1 = [19,6,255]
    leafchar2 = [20,6,255]
    leafchar3 = [19,7,255]
    leafchar4 = [20,7,255]
    leafchars = [leafchar1,leafchar2,leafchar3,leafchar4]
    
    lshrubul = [0,7,255]
    lshrubur = [1,7,255]
    lshrubll = [2,7,255]
    lshrublr = [3,7,255]

    aconu = [19,5,161]
    acond = [20,5,163]
    aconl = [21,5,162]
    aconr = [22,5,164]
    dconu = [19,6,161]
    dcond = [20,6,163]
    dconl = [19,7,162]
    dconr = [20,7,164]

    bordercorner = [28,2,255]

    border3waye = [26,4,255]
    
    bordercapn = [26,3,255]
    bordercape = [27,3,255]
    bordercaps = [28,3,255]
    bordercapw = [29,3,255]

    borderhchar1 = [25,2,255]
    borderhchar2 = [26,2,255]
    borderhchar3 = [27,2,255]
    borderhchars = [borderhchar1,borderhchar2,borderhchar3]

    bordervchar1 = [29,2,255]
    bordervchar2 = [30,2,255]
    bordervchar3 = [31,2,255]
    bordervchars = [bordervchar1,bordervchar2,bordervchar3]

    twdownborder = [20,2,255]
    twupborder = [18,2,255]

    vnborder = [14,1,255]
    hnborder = [15,1,255]
    fwnborder = [16,1,255]

    unchecked = [10,2,255]
    checked = [11,2,255]

    uschar = [4,2,255]
    dschar = [5,2,255]
    lschar = [6,2,255]
    rschar = [7,2,255]

    cavechar = [7,5,255]

    swampchar1 = [23,5,255]
    swampchar2 = [24,5,255]
    swampchar3 = [25,5,255]
    swampchar4 = [26,5,255]

    mountain1 = [11,6,255]
    mountain2 = [12,6,255]
    mountain3 = [11,7,255]
    mountain4 = [12,7,255]
    mountain5 = [13,6,255]
    mountain6 = [14,6,255]
    mountain7 = [13,7,255]
    mountain8 = [14,7,255]

    water1 = [24,6,255]
    water2 = [25,6,255]
    water3 = [24,7,255]
    water4 = [25,7,255]

    beach1 = [28,4,255]
    beach2 = [29,4,255]
    beach3 = [28,5,255]
    beach4 = [29,5 ,255]
    beachchars = [beach1,beach2,beach3,beach4]

    shore1 = [30,4,255]
    shore2 = [31,4,255]
    shore3 = [30,5,255]
    shore4 = [31,5,255]
    shorechars = [shore1,shore2,shore3,shore4]

    snow1 = [26,6,255]
    snow2 = [27,6,255]
    snow3 = [26,7,255]
    snow4 = [27,7,255]

    glacier1 = [28,6,255]
    glacier2 = [29,6,255]
    glacier3 = [28,7,255]
    glacier4 = [29,7,255]

    desert1 = [15,6,255]
    desert2 = [16,6,255]
    desert3 = [15,7,255]
    desert4 = [16,7,255]

    dirt1 = [21,6,255]
    dirt2 = [22,6,255]
    dirt3 = [21,7,255]
    dirt4 = [22,7,255]

    dirtleaf1 = [30,6,255]
    dirtleaf2 = [31,6,255]
    dirtleaf3 = [30,7,255]
    dirtleaf4 = [31,7,255]
    dirtleafchars = [dirtleaf1,dirtleaf2,dirtleaf3,dirtleaf4]

    blankchar = [5,7,255]

    rivsources1 = [27,9,255]
    rivsourcew1 = [28,9,255]
    rivsourcen1 = [29,9,255]
    rivsourcee1 = [30,9,255]
    rivsources2 = [27,10,255]
    rivsourcew2 = [28,10,255]
    rivsourcen2 = [29,10,255]
    rivsourcee2 = [30,10,255]

    lrivsources1 = [27,11,255]
    lrivsourcew1 = [28,11,255]
    lrivsourcen1 = [29,11,255]
    lrivsourcee1 = [30,11,255]

    scrollul = [21,9,255]
    scrollum = [22,9,255]
    scrollur = [23,9,255]
    scrolll = [21,10,255]
    scrollr = [23,10,255]
    scrollbl = [21,11,255]
    scrollbm = [22,11,255]
    scrollbr = [23,11,255]

    scroll2ul = [24,9,255]
    scroll2um = [25,9,255]
    scroll2ur = [26,9,255]
    scroll2l = [24,10,255]
    scroll2r = [26,10,255]
    scroll2bl = [24,11,255]
    scroll2bm = [25,11,255]
    scroll2br = [26,11,255]

    ## NOTE TO SELF - Blit2x reserves characters 226-232 ##

    libtcod.console_map_ascii_code_to_font(157,4,5) # Deciduous
    libtcod.console_map_ascii_code_to_font(156,1,5) # Shrubland
    libtcod.console_map_ascii_code_to_font(154,2,5) # Cacti
    libtcod.console_map_ascii_code_to_font(153,3,5) # Heathland
    libtcod.console_map_ascii_code_to_font(151,0,5) # Broadleaf
    libtcod.console_map_ascii_code_to_font(150,5,5) # Mixed Forest
    libtcod.console_map_ascii_code_to_font(149,13,5) # Coniferous
    libtcod.console_map_ascii_code_to_font(148,6,5) # Evergreen
    libtcod.console_map_ascii_code_to_font(147,7,5) # Caves
    libtcod.console_map_ascii_code_to_font(146,8,5) # Tropical Forest

    libtcod.console_map_ascii_code_to_font(145,9,5) # Human
    libtcod.console_map_ascii_code_to_font(144,10,5) # Castle
    libtcod.console_map_ascii_code_to_font(143,11,5) # Village
    libtcod.console_map_ascii_code_to_font(142,12,5) # City

    libtcod.console_map_ascii_code_to_font(159,16,2) # 4-way wall.

    # Skip chr. 160 - return key?
    libtcod.console_map_ascii_code_to_font(161,19,6) # Conifer 1
    libtcod.console_map_ascii_code_to_font(162,19,7) # Conifer 2
    libtcod.console_map_ascii_code_to_font(163,20,6) # Conifer 3
    libtcod.console_map_ascii_code_to_font(164,20,7) # Conifer 4
    libtcod.console_map_ascii_code_to_font(165,21,6) # Conifer 5
    libtcod.console_map_ascii_code_to_font(166,21,7) # Conifer 6
    libtcod.console_map_ascii_code_to_font(167,22,6) # Conifer 7
    libtcod.console_map_ascii_code_to_font(168,22,7) # Conifer 8
    libtcod.console_map_ascii_code_to_font(169,23,7) # Conifer Tree-Top

    libtcod.console_map_ascii_code_to_font(170,23,6) # Tree Trunk

    libtcod.console_map_ascii_code_to_font(171,14,5) # Cactus
    libtcod.console_map_ascii_code_to_font(172,15,5) # Cactus Branch 1
    libtcod.console_map_ascii_code_to_font(173,16,5) # Cactus Branch 2
    libtcod.console_map_ascii_code_to_font(174,17,5) # Cactus Branch 3
    libtcod.console_map_ascii_code_to_font(175,18,5) # Cactus Branch 4

    libtcod.console_map_ascii_code_to_font(219,0,6) # Vertical river.
    libtcod.console_map_ascii_code_to_font(220,1,6) # Horizontal river.
    libtcod.console_map_ascii_code_to_font(221,2,6) # 4-way river.
    libtcod.console_map_ascii_code_to_font(222,3,6) # 3-way west river.
    libtcod.console_map_ascii_code_to_font(223,4,6) # 3-way north river.
    libtcod.console_map_ascii_code_to_font(224,5,6) # 3-way east river.
    libtcod.console_map_ascii_code_to_font(225,6,6) # 3-way south river.

    libtcod.console_map_ascii_code_to_font(233,7,6) # Corner north/east river.
    libtcod.console_map_ascii_code_to_font(234,8,6) # Corner south/east river.
    libtcod.console_map_ascii_code_to_font(235,9,6) # Corner south/west river.
    libtcod.console_map_ascii_code_to_font(236,10,6) # Corner north/west river.
    libtcod.console_map_ascii_code_to_font(237,11,6) # Glacier 1
    libtcod.console_map_ascii_code_to_font(238,12,6) # Glacier 2
    libtcod.console_map_ascii_code_to_font(239,11,7) # Glacier 3
    libtcod.console_map_ascii_code_to_font(240,12,7) # Glacier 4
    libtcod.console_map_ascii_code_to_font(245,17,6) # Grass 1
    libtcod.console_map_ascii_code_to_font(246,18,6) # Grass 2
    libtcod.console_map_ascii_code_to_font(247,17,7) # Grass 3
    libtcod.console_map_ascii_code_to_font(248,18,7) # Grass 4
    libtcod.console_map_ascii_code_to_font(249,17,6) # Leaves 1
    libtcod.console_map_ascii_code_to_font(250,18,6) # Leaves 2
    libtcod.console_map_ascii_code_to_font(251,17,7) # Leaves 3
    libtcod.console_map_ascii_code_to_font(252,18,7) # Leaves 4

    libtcod.console_map_ascii_code_to_font(253,4,2) # Up Scroll Arrow
    libtcod.console_map_ascii_code_to_font(254,5,2) # Down Scroll Arrow

    citychar = [12,5,255]
    villagechar = [11,5,255]
    castlechar = [10,5,255]
    humanchar = chr(145)

    grasschar1 = [17,6,254]
    grasschar2 = [18,6,254]
    grasschar3 = [17,7,254]
    grasschar4 = [18,7,254]

    leafground1 = [19,6,254]
    leafground2 = [20,6,254]
    leafground3 = [19,7,254]
    leafground4 = [20,7,254]

    trunkchar1 = [17,122,255]
    trunkchar2 = [18,122,255]
    trunkchar3 = [17,123,255]
    trunkchar4 = [18,123,255]
    trunkchars = [trunkchar1,trunkchar2,trunkchar3,trunkchar4]

    rootcharng = [19,122,255]
    rootcharwg = [20,122,255]
    rootchareg = [19,123,255]
    rootcharsg = [20,123,255]
    rootcharnl = [21,122,255]
    rootcharwl = [22,122,255]
    rootcharel = [21,123,255]
    rootcharsl = [22,123,255]
    rootcharntg = [23,122,255]
    rootcharwtg = [24,122,255]
    rootcharetg = [23,123,255]
    rootcharstg = [24,123,255]
    rootcharnd = [25,122,255]
    rootcharwd = [26,122,255]
    rootchared = [25,123,255]
    rootcharsd = [26,123,255]
    
    ballchar = [23,6,255]

    waterchars = [water1,water2,water3,water4]
    grasschars = [grasschar1,grasschar2,grasschar3,grasschar2,grasschar3,grasschar2,grasschar3,grasschar2,grasschar3,grasschar4]
    leafgroundchars = [leafground1,leafground2,leafground3,leafground4]
    swampchars = [swampchar1,swampchar2,swampchar3,swampchar4]
    desertchars = [desert1,desert2,desert3,desert4]
    dirtchars = [desert1,desert2,desert3,desert4,dirt1,dirt2,dirt3,dirt4]
    mountaincharshigh = [mountain1,mountain2,mountain3,mountain4]
    mountaincharslow = [mountain5,mountain6,mountain7,mountain8]
    snowchars = [snow1,snow2,snow3,snow4]
    glacierchars = [glacier1,glacier2,glacier3,glacier4]

    vectorchar1 = [21,16,255]
    vectorchar2 = [21,17,255]
    vectorchar3 = [21,18,255]
    vectorchar4 = [21,19,255]
    vectorchar5 = [21,20,255]
    vectorchar6 = [21,21,255]
    vectorchar7 = [21,22,255]
    vectorchar8 = [21,23,255]
    vectorchar9 = [21,24,255]
    vectorchar10 = [21,25,255]
    vectorchar11 = [21,26,255]
    vectorchar12 = [22,16,255]
    vectorchars = [vectorchar1,vectorchar2,vectorchar3,vectorchar4,vectorchar5,vectorchar6, \
                   vectorchar7,vectorchar8,vectorchar9,vectorchar10,vectorchar11,vectorchar12]

    if init['FULLSCREEN'] == 'yes':
        libtcod.console_set_fullscreen(not libtcod.console_is_fullscreen())

    pygame.mixer.init()
    pygame.mixer.set_num_channels(32)

    doIntroSetup()
    movetime = time.time()
    cursorswitch = True
    libtcod.console_set_keyboard_repeat(500,250)
    lock = threading.Lock()
    key = libtcod.Key()
    mouse = libtcod.Mouse()
    ocx,ocy = mouse.cx,mouse.cy
    libtcod.sys_set_fps(25)

    q = Queue.Queue()
    
    while not libtcod.console_is_window_closed():
        if not (KeyLock or NoKeys):
            ev = libtcod.sys_check_for_event(libtcod.EVENT_ANY,key,mouse)
        if (mouse.cx,mouse.cy) == (ocx,ocy):
            mouse.dcx,mouse.dcy = 0,0
        ocx,ocy = mouse.cx,mouse.cy
        if not key.pressed:
            key.vk = 0
            key.c = 0
        renderButtons()
        renderMenus()
        renderText()
        if ev:
            game_exit = handle_keys()
            if game_exit:
                break
        if DOSCREEN == 0:
            doIntro()
        elif DOSCREEN == 1:
            doWorldGen()
        elif DOSCREEN == 2:
            doMainGame()
        elif DOSCREEN == 4:
            doWorldAtlas()
        renderLights()
        renderGraphics()
        libtcod.console_blit(GraphicsLayer,0,0,SCREEN_WIDTH,SCREEN_HEIGHT,0,0,0,1.0,0.0)
        if not NoRefresh:
            libtcod.console_flush()
    for thread in threading.enumerate():
        thread.killswitch = True
